<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter 5 软件定时器管理</title>
      <link href="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/"/>
      <url>/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="软件定时器管理"><a href="#软件定时器管理" class="headerlink" title="软件定时器管理"></a>软件定时器管理</h1><h2 id="章节介绍和范围"><a href="#章节介绍和范围" class="headerlink" title="章节介绍和范围"></a>章节介绍和范围</h2><p>软件定时器用于安排函数在设定的未来时间点执行，或者以固定频率定期执行。 软件定时器执行的函数称为软件定时器的回调函数。</p><p>软件定时器由 FreeRTOS 内核实现，并受 FreeRTOS内核 的控制。它们不需要硬件支持，也与硬件定时器或硬件计数器无关。</p><p>请注意，根据 FreeRTOS 使用创新设计以确保最高效率的理念，软件定时器不会使用任何处理时间，除非实际执行软件定时器回调函数。</p><p>软件定时器功能是可选的。要包含软件定时器功能，请执行以下操作:</p><ol><li>将FreeRTOS源文件 <code>FreeRTOS/Source/timers.c</code> 构建为项目的一部分 </li><li>在 <code>FreeRTOSConfig.h</code> 中将<code>configUSE_TIMERS</code>设置为1。</li></ol><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h3><p>本章旨在让读者更好地了解以下内容：</p><ul><li>软件定时器的特性与任务特性的比较。</li><li>RTOS 守护进程任务。</li><li>定时器命令队列。</li><li>一次性软件定时器和周期性软件定时器之间的区别。</li><li>如何创建、启动、重置和更改软件定时器的周期。</li></ul><h2 id="软件定时器回调函数"><a href="#软件定时器回调函数" class="headerlink" title="软件定时器回调函数"></a>软件定时器回调函数</h2><p>软件定时器回调函数被实现为 C 函数。它们唯一的特别之处是它们的原型，它必须返回void，并将软件定时器的句柄作为其唯一的参数。清单 72 演示了回调函数原型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 72. 软件定时器回调函数原型</p><p>软件定时器回调函数自始至终执行，并以正常方式退出。它们应该保持简短，并且不能进入阻塞状态。</p><blockquote><p>注意：正如将看到的，软件定时器回调函数在启动 FreeRTOS 调度程序时自动创建的任务的上下文中执行。 因此，软件定时器回调函数决不能调用会导致调用任务进入阻塞状态的FreeRTOS API 函数，这一点至关重要。 可以调用 xQueueReceive() 之类的函数，但前提是该函数的 xTicksToWait 参数(指定函数的阻塞时间)设置为 0。 调用 vTaskDelay() 之类的函数是不对的，因为调用vTaskDelay()会始终将调用任务置于阻塞状态。</p></blockquote><h2 id="软件定时器的属性和状态"><a href="#软件定时器的属性和状态" class="headerlink" title="软件定时器的属性和状态"></a>软件定时器的属性和状态</h2><h3 id="软件定时器的周期"><a href="#软件定时器的周期" class="headerlink" title="软件定时器的周期"></a><strong>软件定时器的周期</strong></h3><p>软件定时器的 <code>‘周期’(period)</code> 是软件定时器启动和软件定时器的回调函数执行之间的时间</p><h3 id="一次性定时器和自动重载定时器"><a href="#一次性定时器和自动重载定时器" class="headerlink" title="一次性定时器和自动重载定时器"></a><strong>一次性定时器和自动重载定时器</strong></h3><p>有两种类型的软件定时器：</p><ol><li><p>一次性定时器 一旦启动</p><p>一旦启动，一次性定时器将仅执行一次其回调函数。一次性定时器可以手动重新启动，但不会自行重新启动。</p></li><li><p>自动重载定时器 </p><p>一旦启动，自动重载定时器将在每次到期时重新启动，从而定期执行其回调函数。</p></li></ol><p>图38显示了一次性定时器和自动重载定时器之间的行为差异。虚线垂直线标记滴答中断发生的时间。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330161114285.png" alt="图38一次性软件定时器和自动重载软件定时器之间的行为差异"></p><p>参考图38：</p><ul><li><p>定时器 1 </p><p>定时器 1 是具有 6 个滴答长的周期的一次性定时器。它在 t1 时刻启动，因此它的回调函数在6个滴答之后，即 t7 时刻执行。由于定时器 1是一次性定时器，其回调函数不会再次执行。</p></li><li><p>定时器 2 </p><p>定时器 2 是具有 5 个滴答长的周期的自动重载定时器。它在 t1 时刻启动，因此它的回调函数在 t1 时刻之后每5 滴答执行一次。在图38中，这是 t6 、 t11 和 t16 时刻。</p></li></ul><h3 id="软件定时器状态"><a href="#软件定时器状态" class="headerlink" title="软件定时器状态"></a><strong>软件定时器状态</strong></h3><p>软件定时器可以处于以下两种状态之一：</p><ul><li><p>休眠</p><p>休眠的软件定时器存在，并且可以通过其句柄引用，但未运行，因此其回调函数将不会执行。</p></li><li><p>运行</p><p>正在运行的软件定时器将在从软件定时器进入运行状态起或者从软件定时器最后被重置起经过等于其周期的时间之后执行其回调函数。</p></li></ul><p>图39和图40分别显示了自动重载定时器和一次性定时器在休眠状态和运行状态之间的可能的转换。这两个图的关键区别在于定时器到期后进入的状态；自动重载定时器执行其回调函数，然后重新进入运行状态，一次性定时器执行其回调函数，然后进入休眠状态。</p><p>xTimerDelete() API 函数的作用是：删除一个定时器。可以随时删除定时器。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240615012641295.png" alt="图 39 自动重载软件定时器状态和转换"></p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330163007600.png" alt="图 40 一次性软件定时器状态和转换"></p><h2 id="软件定时器的上下文"><a href="#软件定时器的上下文" class="headerlink" title="软件定时器的上下文"></a>软件定时器的上下文</h2><h3 id="RTOS守护进程-定时器服务-任务"><a href="#RTOS守护进程-定时器服务-任务" class="headerlink" title="RTOS守护进程(定时器服务)任务"></a><strong>RTOS守护进程(定时器服务)任务</strong></h3><p>所有软件定时器回调函数都在同一 RTOS <code>守护进程任务-daemon task</code> (或 <code>“定时器服务任务-timer service task”</code> ) 的上下文中执行[1]。</p><blockquote><p>[1] 该任务过去被称为 “定时器服务任务” ，因为最初它只用于执行软件定时器回调函数。现在同一任务也用于其他目的，因此它被称为 “RTOS守护进程任务” 的更一般的名称。</p><p>daemon : 计算机中的概念，多翻译为守护进程，守护进程是运行在后台的一种特殊进程，它周期性地执行某种任务或循环等待处理某些事件的发生，在不需要时处于休眠状态。</p></blockquote><p>守护进程任务，是在启动调度程序时，自动创建的标准的 FreeRTOS 任务。其优先级和堆栈大小分别由 <code>configTIMER_TASK_PRIORITY</code> 和 <code>configTIMER_TASK_STACK_DEPTH</code> 编译时配置常量设置。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p><p>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API 函数，因为这样做将导致守护进程任务进入阻塞状态。</p><h3 id="定时器命令队列"><a href="#定时器命令队列" class="headerlink" title="定时器命令队列"></a><strong>定时器命令队列</strong></h3><p>软件定时器 API 函数将命令从调用任务发送到称为 “定时器命令队列” 的队列上的守护进程任务。这如图 41 所示。命令的示例包括 <code>"start a timer (启动定时器)"</code> 、<code>stop a timer (停止定时器)</code> 和 <code>reset a timer (重置定时器)</code> 。</p><p>定时器命令队列是在启动调度程序时自动创建的标准 FreeRTOS 队列。定时器命令队列的长度由 <code>FreeRTOSConfig.h</code> 中的 <code>configTIMER_QUEUE_LENGTH</code> 编译时配置常量设置。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330165153654.png" alt="图 41 软件定时器API函数使用定时器命令队列与RTOS守护进程任务通信"></p><h3 id="守护进程任务调度"><a href="#守护进程任务调度" class="headerlink" title="守护进程任务调度"></a><strong>守护进程任务调度</strong></h3><p>守护进程任务与任何其他 FreeRTOS 任务一样进行调度；当守护进程任务是能够运行的最高优先级任务时，它只会处理命令或执行定时器回调函数。图 42 和图 43 演示了 <code>configTIMER_TASK_PRIORITY</code> 设置如何影响执行模式</p><p>图 42 显示了当守护进程任务的优先级低于调用 <code>xTimerStart()</code> API 函数的任务的优先级时的执行模式</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330170229111.png" alt="图 42 调用xTimerStart()的任务的优先级高于守护进程任务的优先级时的执行模式"></p><p>参照图 42 ，其中任务1 的优先级高于守护进程任务的优先级，并且守护进程任务的优先级高于空闲任务的优先级：</p><ol><li>t1 时刻</li></ol><p>   任务1 处于运行状态，守护进程任务处于阻塞状态。</p><p>   如果有命令发送到定时器命令队列，守护进程任务将离开阻塞状态，在这种情况下，它将处理该命令，或者如果软件定时器到期，在这种情况下，它将执行软件定时器的回调函数。</p><ol start="2"><li><p>t2 时刻：</p><p>任务1 调用 <code>xTimerStart()</code> 。</p><p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。 任务1 的优先级高于守护进程任务的优先级，因此守护进程任务不会抢占任务1 。 </p><p>任务1 仍处于运行状态，守护进程任务已离开阻塞状态，进入就绪状态。</p></li><li><p>t3 时刻：</p><p>任务1 完成 <code>xTimerStart()</code> API 函数的执行。</p><p>任务1 从头到尾执行完 <code>xTimerStart()</code> ，而不离开运行状态。</p></li><li><p>t4 时刻：</p><p>任务1 调用导致其进入阻塞状态的 API 函数。守护进程任务现在是处于就绪状态的最高优先级任务，因此调度程序选择守护进程任务作为进入运行状态的任务。然后，守护进程任务开始处理任务1 发送到定时器命令队列的命令。 </p><p><em>注意：正在启动的软件定时器将到期的时间是从向定时器命令队列发送 “启动定时器” 命令开始计算的，而不是从守护进程任务从定时器命令队列接收到 “启动定时器” 命令的时间计算的。</em></p></li><li><p>t5 时刻：</p><p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。定时器命令队列为空，因此守护进程任务重新进入阻塞状态。如果将命令发送到定时器命令队列，或者如果软件定时器到期，则守护进程任务将再次离开阻塞状态。</p><p>空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p></li></ol><p>图 43 显示了类似于图 42 所示的场景，但是这一次守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240331001216768.png" alt="图 43 当调用xTimerStart()的任务的优先级低于守护进程任务的优先级时的执行模式"></p><p>参照图 43 ，其中守护进程任务的优先级高于任务1 的优先级，任务1 的优先级高于空闲任务的优先级：</p><ol><li><p>t1 时刻 </p><p>和之前一样，任务1 处于运行状态，守护进程任务处在阻塞状态。 </p></li><li><p>t2 时刻 </p><p>任务1调用 <code>xTimerStart()</code> 。</p><p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。守护进程任务的优先级高于任务1 的优先级，因此调度器选择守护进程任务作为进入运行状态的任务。</p><p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，现在处于就绪状态。守护进程任务开始处理任务1 发送到定时器命令队列的命令。</p></li><li><p>t3 时刻 </p><p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。 定时器命令队列为空，因此守护进程任务重新进入阻塞状态。</p><p>任务1 现在是处于就绪状态的最高优先级任务，因此调度程序选择任务1 作为要进入运行状态的任务。</p></li><li><p>t4 时刻 </p><p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，并且只有在重新进入运行状态后才退出 <code>xTimerStart()</code> (从<code>xTimerStart()</code> return)。</p></li><li><p>t5 时刻 </p><p>任务1 调用导致其进入阻塞状态的 API 函数。空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p></li></ol><p>在图 42 所示的场景中，任务1 向定时器命令队列发送命令与守护进程任务接收和处理命令之间经过了一段时间。在图 43 所示的场景中，在 任务1 从发送命令的函数返回之前，守护进程任务已经接收并处理了任务1 发送给它的命令。</p><p>发送到定时器命令队列的命令包含时间戳。时间戳用于计算应用程序任务发送的命令与守护进程任务处理同一命令之间经过的任何时间。例如，如果发送 “启动定时器” 命令来启动周期为 10 个滴答的定时器，则时间戳用于确保正在启动的定时器是在命令发送后 10 个滴答到期，而不是在命令被守护进程任务处理之后 10 个滴答超时。</p><h2 id="创建和开始一个软件定时器"><a href="#创建和开始一个软件定时器" class="headerlink" title="创建和开始一个软件定时器"></a>创建和开始一个软件定时器</h2><h3 id="xTimerCreate-API函数"><a href="#xTimerCreate-API函数" class="headerlink" title="xTimerCreate()API函数"></a>xTimerCreate()API函数</h3><p>FreeRTOS V9.0.0还包含 <code>xTimerCreateStatic()</code> 函数，该函数在编译时静态分配创建定时器所需的内存: 软件定时器必须先显式创建，然后才能使用。</p><p>软件定时器由 <code>TimerHandle_t</code> 类型的变量引用。<code>xTimerCreate()</code> 用于创建软件定时器，并返回 <code>TimerHandle_t</code> 以引用其创建的软件定时器。软件定时器是在休眠状态下创建的。</p><p>可以在调度器运行之前创建软件定时器，也可以在调度器启动后从任务创建软件定时器。第 0 节介绍了使用的数据类型和命名约定。</p><pre class=" language-c"><code class="language-c">TimerHandle_t <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> pcTimerName<span class="token punctuation">,</span>                                 TickType_t xTimerPeriodInTicks<span class="token punctuation">,</span>                                 UBaseType_t uxAutoReload<span class="token punctuation">,</span>                                 <span class="token keyword">void</span> <span class="token operator">*</span> pvTimerID<span class="token punctuation">,</span>                                 TimerCallbackFunction_t pxCallbackFunction <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 73 . xTimerCreate()API函数原型</p><p>表 27 . xTimerCreate()参数和返回值</p><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>pcTimerName</td><td>计时器的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。使用人类可读的名称标识计时器比尝试通过其句柄标识要简单得多。</td></tr><tr><td>xTimerPeriodInTicks</td><td>以滴答为单位指定的计时器周期。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td></tr><tr><td>uxAutoReload</td><td>将 <code>uxAutoReload</code> 设置为 <code>pdTRUE</code> 以创建自动重载计时器。将 <code>uxAutoReload</code> 设置为 <code>pdFALSE</code> 以创建一次性计时器</td></tr><tr><td>pvTimerID</td><td>每个软件定时器都有一个 ID 值。ID 是一个 <code>void</code> 指针，应用程序编写者可以将其用于任何目的。当多个软件计时器使用相同的回调函数时，ID 特别有用，因为它可用于提供特定于时器的存储。本章中的一个示例演示了定时器 ID 的使用。<br><code>pvTimerID</code> 设置正在创建的任务的ID的初始值。</td></tr><tr><td>pxCallbackFunction</td><td>软件计时器回调函数仅仅是符合清单72中所示原型的C函数。<code>pxCallbackFunction</code> 参数是指向要用作正在创建的软件定时器的回调函数的函数指针 (实际上就是函数名) 。</td></tr><tr><td>返回值</td><td>如果返回 NULL ，则无法创建软件定时器，因为 FreeRTOS 没有足够的堆内存来分配必要的数据结构。<br>返回的非 NULL 值表示软件定时器已成功创建。返回值是创建的计时器的句柄。<br> 第2章提供了有关堆内存管理的更多信息。</td></tr></tbody></table><h3 id="xTimerStart-API函数"><a href="#xTimerStart-API函数" class="headerlink" title="xTimerStart()API函数"></a>xTimerStart()API函数</h3><p><code>xTimerStart()</code> 用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。<code>xTimerStop()</code> 用于停止处于运行状态的软件定时器。停止软件定时器等同于与将定时器转换到休眠状态。</p><p>可以在调度程序启动之前调用 <code>xTimerStart()</code> ，但是当这样做时，软件定时器直到调度程序启动时才会实际启动。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerStart()</code> 。应该使用中断安全版本 <code>xTimerStartFromISR()</code> 来代替它。</p></blockquote><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerStart</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 74 . xTimerStart()API函数原型</p><p>表 28 . xTimerStart()参数和返回值</p><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>正在启动或重置的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerStart()</code> 使用定时器命令队列向守护程序任务发送 “启动计时器” 命令。<br><code> xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerStart()</code> 将立即返回。<br>阻塞时间以滴答周期指定，因此它表示的绝对时间取决于滴答频率。宏 <code>pdMS_TO_TICKS()</code> 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在调度程序启动之前调用 <code>xTimerStart()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerStart()</code>的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td></tr><tr><td>返回值</td><td>有两个可能的返回值<br>1.  <code>pdPASS</code><br>只有当 “启动定时器” 命令成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级，那么调度程序将确保在 <code>xTimerStart()</code> 返回之前处理启动命令。这是因为一旦定时器命令队列中有数据，守护进程任务就会抢占调用 <code>TimerStart()</code>的任务。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br>2. <code>pdFALSE</code><br>如果由于队列已满而无法将 “启动定时器” 命令写入定时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在定时器命令队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table><h3 id="示例-13-创建一次性和自动重载计时器"><a href="#示例-13-创建一次性和自动重载计时器" class="headerlink" title="示例 13. 创建一次性和自动重载计时器"></a>示例 13. 创建一次性和自动重载计时器</h3><p>此示例创建并启动一个一次性定时器和一个自动重载定时器 - 如清单 75 所示。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 分配给一次性和自动重载定时器的周期分别为3.333秒和半秒。 */</span> <span class="token macro property">#<span class="token directive keyword">define</span> mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )</span><span class="token macro property">#<span class="token directive keyword">define</span> mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 ) </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> TimerHandle_t xAutoReloadTimer<span class="token punctuation">,</span> xOneShotTimer<span class="token punctuation">;</span> BaseType_t xTimer1Started<span class="token punctuation">,</span> xTimer2Started<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建一次性定时器，将创建的定时器的句柄存储在 xOneShotTimer 中。*/</span>      xOneShotTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span>     <span class="token comment" spellcheck="true">/* 软件定时器的文本名称-未由 FreeRTOS 使用。*/</span>    <span class="token string">"OneShot"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/*软件定时器的周期(以滴答为单位)。*/</span>    mainONE_SHOT_TIMER_PERIOD<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 将 uxAutoRealod 设置为 pdFALSE 将创建一次性软件定时器。*/</span>    pdFALSE<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 此示例不使用定时器 ID。*/</span>    <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 要由正在创建的软件定时器使用的回调函数。*/</span>    prvOneShotTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建自动重载定时器，将创建的定时器的句柄存储在 xAutoReloadTimer 中。*/</span>     xAutoReloadTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span>     <span class="token comment" spellcheck="true">/* 软件定时器的文本名称-未由 FreeRTOS 使用。 */</span>    <span class="token string">"AutoReload"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 软件定时器的周期(以滴答为单位)。*/</span>    mainAUTO_RELOAD_TIMER_PERIOD<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 将 uxAutoRealod 设置为 pdTRUE 将创建自动重载定时器。*/</span>    pdTRUE<span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">/* 此示例不使用定时器 ID。 */</span>    <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 要由正在创建的软件定时器使用的回调函数。*/</span>    prvAutoReloadTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 检查软件定时器是否已创建。*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xOneShotTimer <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xAutoReloadTimer <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span>     <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 阻塞时间设为 0 (无阻塞时间) 启动软件定时器。调度程序尚未启动，因此此处指定的任何阻塞时间都将被忽略。 */</span>    xTimer1Started <span class="token operator">=</span> <span class="token function">xTimerStart</span><span class="token punctuation">(</span> xOneShotTimer<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    xTimer2Started <span class="token operator">=</span> <span class="token function">xTimerStart</span><span class="token punctuation">(</span> xAutoReloadTimer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xTimerStart() 的实现使用定时器命令队列，如果定时器命令队列已满，xTimerStart() 将失败。守护进程任务在调度程序启动之前不会创建，因此发送到命令队列的所有命令都将保留在队列中，直到调度程序启动之后。检查传递的两个 xTimerStart() 调用。*/</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimer1Started <span class="token operator">==</span> pdPASS <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xTimer2Started <span class="token operator">==</span> pdPASS <span class="token punctuation">)</span> <span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* Start the scheduler. */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/*一如既往，这条线不应该达到。 */</span>     <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 75.  创建并启动示例 13 中使用的定时器</p><p>定时器的回调函数在每次被调用时只打印一条消息。清单 76 中显示了一次性定时器回调函数的实现。自动重载定时器回调函数的实现如清单 77 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvOneShotTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">{</span>    TickType_t xTimeNow<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取当前的滴答计数。 */</span>    xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 输出一个字符串以显示执行回调的时间*/</span>    <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"One-shot timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 文件作用域变量。(全局变量) */</span>    ulCallCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>清单 76.  示例 13 中的一次性定时器使用的回调函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvAutoReloadTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">{</span>TickType_t xTimeNow<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 获取当前的滴答计数。 */</span>    xTimeNow <span class="token operator">=</span> <span class="token function">uxTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 输出一个字符串以显示执行回调的时间*/</span>   <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Auto-reload timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>  ulCallCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>清单 77.  示例 13 中的自动重载定时器使用的回调函数</p><p>执行此示例将生成如图 44 所示的输出。图 44 显示了自动重载定时器的回调函数以500个滴答的固定周期执行 (清单 75 中的 <code>mainAUTO_RELOAD_TIMER_PERIOD</code> 设置为 500 )，当滴答计数为 3333 时，一次性定时器的回调函数只执行一次 (清单 75 中的 <code>mainOne_Shot_Timer_Period</code> 设置为 3333 )。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240331225428946.png" alt="图 44 执行示例 13 时产生的输出"></p><h2 id="定时器-ID"><a href="#定时器-ID" class="headerlink" title="定时器 ID"></a>定时器 ID</h2><p>每个软件定时器都有一个 ID，它是应用程序编写者可以出于任何目的使用的标记值。ID 存储在空指针 <code>(void*)</code> 中，因此可以直接存储整数值、指向任何其他对象或用作函数指针。</p><p>创建软件定时器时会为ID分配初始值 — 之后可以使用 <code>vTimerSetTimerID()</code> API函数更新 ID，并使用 <code>pvTimerGetTimerID()</code> API函数进行查询。</p><p>与其他软件定时器 API 函数不同，<code>vTimerSetTimerID()</code> 和 <code>pvTimerGetTimerID()</code> 直接访问软件定时器 — 它们不向定时器命令队列发送命令。</p><h3 id="vTimerSetTimerID-API函数"><a href="#vTimerSetTimerID-API函数" class="headerlink" title="vTimerSetTimerID()API函数"></a><strong>vTimerSetTimerID()API函数</strong></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTimerSetTimerID</span><span class="token punctuation">(</span> <span class="token keyword">const</span> TimerHandle_t xTimer<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvNewID <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 78.  vTimerSetTimerID() API 函数原型</p><p><strong>表 29. vTimerSetTimerID() 参数</strong></p><table><thead><tr><th align="left">参数/返回值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">xTimer</td><td align="left">使用新 ID 值更新的软件定时器的句柄。 句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td align="left">pvNewID</td><td align="left">软件定时器 ID 将被设为的值。</td></tr></tbody></table><h3 id="pvTimerGetTimerID-API-函数"><a href="#pvTimerGetTimerID-API-函数" class="headerlink" title="pvTimerGetTimerID() API 函数"></a>pvTimerGetTimerID() API 函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pvTimerGetTimerID</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 79. pvTimerGetTimerID() API 函数原型</p><p>表 30.  pvTimerGetTimerID() 参数和返回值</p><table><thead><tr><th align="left">参数/返回值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">xTimer</td><td align="left">查询的软件定时器的句柄。句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td align="left">返回值</td><td align="left">查询的软件定时器的 ID。</td></tr></tbody></table><h3 id="示例-14-使用回调函数参数和软件定时器ID"><a href="#示例-14-使用回调函数参数和软件定时器ID" class="headerlink" title="示例 14. 使用回调函数参数和软件定时器ID"></a>示例 14. 使用回调函数参数和软件定时器ID</h3><p>可以将相同的回调函数分配给多个软件定时器。完成后，回调函数参数用于确定哪个软件定时器已到期。</p><p>示例 13 使用了两个单独的回调函数；一个回调函数由一次性定时器使用，另一个回调函数由自动重载定时器使用。示例 14 创建与示例 13 创建的功能类似的功能，但将单个回调函数分配给两个软件定时器。</p><p>示例 14 使用的 main() 函数与示例 13 使用的 main() 函数几乎相同，唯一的区别是创建软件定时器的位置。清单 80 显示了这种差异，其中 <code>prvTimerCallback()</code> 用作两个定时器的回调函数。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 创建一次定时器软件定时器，将句柄存储在 xOneShotTimer 中。*/</span>xOneShotTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token string">"OneShot"</span><span class="token punctuation">,</span>                                          mainONE_SHOT_TIMER_PERIOD<span class="token punctuation">,</span>                                          pdFALSE<span class="token punctuation">,</span>                                          <span class="token comment" spellcheck="true">/* 定时器ID初始化为0*/</span>                                          <span class="token number">0</span><span class="token punctuation">,</span>                                         <span class="token comment" spellcheck="true">/* 两个定时器都使用 prvTimerCallback()。*/</span>                                         prvTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 创建自动重载软件定时器，将句柄存储在 xAutoReloadTimer 中*/</span>xAutoReloadTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token string">"AutoReload"</span><span class="token punctuation">,</span>                                               mainAUTO_RELOAD_TIMER_PERIOD<span class="token punctuation">,</span>                                               pdTRUE<span class="token punctuation">,</span>                                               <span class="token comment" spellcheck="true">/* 定时器的ID初始化为0。 */</span>                                               <span class="token number">0</span><span class="token punctuation">,</span>                                               <span class="token comment" spellcheck="true">/* 两个定时器都使用 prvTimerCallback()。*/</span>                                               prvTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 80. 创建示例 14 中使用的定时器</p><p><code>prvTimerCallback()</code> 将在任一定时器到期时执行。<code>prvTimerCallback()</code> 的实现使用函数的参数来确定调用它是因为一次性定时器已到期，还是因为自动重载定时器已到期。</p><p><code>prvTimerCallback()</code> 还演示了如何将软件定时器 ID 用作特定于定时器的存储；每个软件定时器在其自己的 ID 中保存其到期次数的计数，并且自动重载定时器在第五次执行时使用该计数停止自身。</p><p><code>prvTimerCallback()</code> 的实现如清单79所示</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">{</span>TickType_t xTimeNow<span class="token punctuation">;</span>uint32_t ulExecutionCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 此软件定时器到期次数的计数存储在定时器的 ID 中。获取 ID，将其递增，        然后将其另存为新的 ID 值。该 ID 是一个 void 指针，因此被强制转换为 uint32_t。*/</span>        ulExecutionCount <span class="token operator">=</span> <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token function">pvTimerGetTimerID</span><span class="token punctuation">(</span> xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span>        ulExecutionCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">vTimerSetTimerID</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> ulExecutionCount <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*获取当前的计时次数。*/</span>        xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*创建定时器时，一次性定时器的句柄存储在 xOneShotTimer 中。将传入此函数的句柄与        xOneShotTimer 进行比较，以确定是一次性定时器还是自动重载定时器到期，然后输出一个        字符串以显示执行回调的时间。*/</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> xTimer <span class="token operator">==</span> xOneShotTimer <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"One-shot timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*xTimer不等于 xOneShotTimer，所以一定是自动重载定时器到期，调用了回掉函数。*/</span>            <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Auto-reload timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> ulExecutionCount <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/*自动重载定时器执行 5 次后停止。此回调函数在 RTOS 守护进程任务的上下文中执行，                因此不能调用任何可能将守护进程任务置于阻塞状态的函数。因此，使用阻塞时间 0。*/</span>                <span class="token function">xTimerStop</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>清单 81. 示例 14 中使用的定时器回调函数</p><p>示例 14 产生的输出如图 45 所示。可以看到，自动重载定时器只执行了五次。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401025314788.png" alt="图 45 执行示例 14 时产生的输出"></p><h2 id="更改定时器的周期"><a href="#更改定时器的周期" class="headerlink" title="更改定时器的周期"></a>更改定时器的周期</h2><p>每个官方 FreeRTOS 移植都提供了一个或多个示例工程。大多数示例项目都是在运行中不断自检，LED用于提供项目状态的可视反馈；如果自检总是通过，则LED缓慢闪烁，如果自检失败，则LED快速闪烁。</p><p>一些示例工程在任务中执行自检，并使用 <code>vTaskDelay()</code> 函数控制LED的翻转速率。其他示例工程在软件定时器回调函数中执行自检，并使用定时器的周期来控制LED的翻转速率。</p><h3 id="xTimerChangePeriod-API函数"><a href="#xTimerChangePeriod-API函数" class="headerlink" title="xTimerChangePeriod()API函数"></a>xTimerChangePeriod()API函数</h3><p>使用 <code>xTimerChangePeriod()</code> 函数更改软件定时器的周期。</p><p>如果 <code>xTimerChangePeriod()</code> 用于更改已在运行的定时器的周期，则该定时器将使用新的周期值重新计算其到期时间。重新计算的到期时间是相对于调用 <code>xTimerChangePeriod()</code> 的时间，而不是相对于定时器最初启动的时间。</p><p>如果使用 <code>xTimerChangePeriod()</code> 来更改处于休眠状态的定时器(未运行的定时器)的周期，则定时器将计算到期时间，并转换到运行状态(定时器将开始运行)。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerChangePeriod()</code>。应该使用中断安全版本 <code>xTimerChangePerodFromISR()</code> 来代替它。</p></blockquote><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerChangePeriod</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span>                                 TickType_t xNewTimerPeriodInTicks<span class="token punctuation">,</span>                                TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 82.  xTimerChangePeriod() API 函数原型</p><p>表 31 xTimerChangePeriod() 参数和返回值</p><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTimerPeriodInTicks</td><td>软件定时器的新的周期，以滴答为单位指定。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerChangePeriod()</code> 使用定时器命令队列向守护进程任务发送 <code>"change Period"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerChangePeriod()</code> 将立即返回。<br><code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在启动调度程序之前调用了 <code>xTimerChangePeriod()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerChangePeriod()</code> 的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td></tr><tr><td>返回值</td><td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"Change Period"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table><p>清单 83 展示了包含自检的 FreeRTOS 例程是怎么在软件定时器的回调函数中使用 <code>xTimerChangePeriod()</code> 在自检失败时提高LED闪烁速度的。执行自检的软件定时器被称为 “检查定时器 — check timer”。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 检查定时器的创建周期为3000毫秒，导致LED每3秒切换一次。如果自检功能检测到意外状态，则检查定时器的周期将更改为仅200毫秒，从而导致更快的翻转速率。*/</span> <span class="token keyword">const</span> TickType_t xHealthyTimerPeriod <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">const</span> TickType_t xErrorTimerPeriod <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 检查定时器使用的回调函数。 */</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvCheckTimerCallbackFunction</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> BaseType_t xErrorDetected <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span> xErrorDetected <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>     <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/* 尚未检测到任何错误。再次运行自检功能。该函数要求示例创建的每个任务        报告自己的状态，并检查所有任务是否实际上仍在运行(因此能够正确报告其状态)。*/</span>         <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">CheckTasksAreRunningWithoutError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFAIL <span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">/*一个或多个任务报告意外状态，可能发生了错误。            减少检查定时器的周期以提高此回调函数的执行速率，这样做还可以提高 LED 的切换速率。            此回调函数在 RTOS 守护进程任务的上下文中执行，因此使用阻塞时间 0 来确保守护进程任务永            远不会进入阻塞状态。*/</span>             <span class="token function">xTimerChangePeriod</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/* 正要更新的定时器。*/</span>                                 xErrorTimerPeriod<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 定时器的新周期*/</span>                                 <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* 发送此命令时不要阻塞。 */</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">/* 锁定已检测到错误。 */</span>         xErrorDetected <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/* 切换 LED。LED 翻转的速率取决于调用此函数的频率，    该频率由检查定时器的周期确定。如果    CheckTasksAreRunningWithoutError() 曾经返回 pdFAIL，    则定时器的周期将从 3000ms 减少到 200ms。*/</span>     <span class="token function">ToggleLED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>清单 83. 使用 xTimerChangePeriod()</p><h2 id="重置一个定时器"><a href="#重置一个定时器" class="headerlink" title="重置一个定时器"></a>重置一个定时器</h2><p>重置软件定时器意味着重新启动定时器；计时器的到期时间将根据重置计时器的时间重新计算，而不是相对于计时器最初启动的时间。图 46 演示了这一点，它显示了一个以 6 为周期启动的定时器，然后重置两次，最后到期并执行其回调函数。</p><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401041311370.png" alt="图 46. 启动和重置周期为 6 个滴答的软件定时器"></p><p>参考图 46：</p><ul><li>定时器 1 在 t1 时刻启动。它的周期为 6，因此它执行回调函数的时间最初计算为 t7，即启动后的 6 个滴答。</li><li>定时器1在到达 t7 时刻之前重置，也就是在它到期并执行其回调函数之前被重置。定时器 1 在 t5 时刻 被重置，因此它将执行其回调函数的时间被重新计算为 t11，即它被重置后的6个滴答。</li><li>定时器 1 在 t11 时刻之前再次重置，因此在其到期并执行其回调函数之前再次复位。定时器1在 t9 时刻被重置，因此它将执行其回调函数的时间被重新计算为 t15，这是它上次被重置后的6个滴答。</li><li>定时器1 不会再次重置，因此它在 t15 时刻到期，并且相应地执行其回调函数。</li></ul><h3 id="xTimerReset-API函数"><a href="#xTimerReset-API函数" class="headerlink" title="xTimerReset() API函数"></a>xTimerReset() API函数</h3><p>使用 <code>xTimerReset()</code> API函数重置定时器。</p><p><code>xTimerReset()</code> 还可用于启动处于休眠状态的定时器。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerReset()</code>。应该使用中断安全版本 <code>xTimerResetFromISR()</code> 来代替它。</p></blockquote><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerReset</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 84. xTimerReset() API 函数原型</p><p>表 32. xTimerReset()参数和返回值</p><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerReset()</code> 使用定时器命令队列向守护进程任务发送 <code>"reset"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerReset()</code> 将立即返回。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有期限)，以等待定时器命令队列中的空间变得可用。</td></tr><tr><td>返回值</td><td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"reset"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table><h3 id="示例-15-重置软件定时器"><a href="#示例-15-重置软件定时器" class="headerlink" title="示例 15. 重置软件定时器"></a>示例 15. 重置软件定时器</h3><p>此示例模拟手机上的背光行为。背光：</p><ul><li>按下某个按键时打开。</li><li>如果在一定时间段内按下按键，则保持开启。</li><li>如果在一定时间段内没有按下按键，则自动关闭。</li></ul><p>使用一次性软件定时器来实现此行为：</p><ul><li>按下按键时打开 [模拟] 背光，在软件定时器的回调函数中关闭 [模拟] 背光。</li><li>每次按键按下，软件定时器重置。</li><li>因此，需要按下按键防止背光熄灭的时间段等于软件定时器的周期；如果在定时器到期之前没有通过按键重置软件定时器，则执行定时器的回调功能，关闭背光。</li></ul><p><code>xSimulatedBacklightOn</code> 变量保存背光状态。<code>xSimulatedBacklightOn</code> 设置为pdTRUE表示背光打开，设置为 <code>pdFALSE</code> 表示背光关闭。</p><p>软件定时器回调函数如清单85所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvBacklightTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">{</span>     TickType_t xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 背光定时器超时，关闭背光。*/</span>        xSimulatedBacklightOn <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/*打印背光关闭的时间。*/</span>         <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Timer expired, turning backlight OFF at time\t\t"</span><span class="token punctuation">,</span> xTimeNow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>清单 85. 示例 15 中使用的一次性定时器的回调函数</p><p>示例 15 创建一个任务来轮询键盘[1]。清单 86 显示了该任务，但是由于下一段中描述的原因，清单 86 并不是最佳设计的代表。</p><p><em>[1].打印到 Windows 控制台和从 Windows 控制台读取按键都会导致执行 Windows 系统调用。Windows 系统调用 ( 包括使用 Windows 控制台、磁盘或 TCP/IP 堆栈 )，可能会对 FreeRTOS Windows 移植的行为产生不利影响，因此通常应避免使用。</em></p><p>使用FreeRTOS允许您的应用程序是事件驱动的。事件驱动设计非常有效地使用处理时间，因为处理时间仅在事件已发生时使用，并且处理时间不会浪费在轮询尚未发生的事件上。示例 15 不能由事件驱动，因为在使用 FreeRTOS Windows 移植时处理键盘中断是不切实际的，因此必须使用效率低得多的轮询技术。如果清单 86 是一个中断服务例程，那么将使用 <code>xTimerResetFromISR()</code> 代替 <code>xTimerReset()</code>。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vKeyHitTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">const</span> TickType_t xShortDelay <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">50</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>TickType_t xTimeNow<span class="token punctuation">;</span>    <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Press a key to turn the backlight on.\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 理想情况下，应用程序应该是事件驱动的，并使用中断来处理按键。    在使用 FreeRTOS Windows 移植时使用键盘中断是不切实际的，    因此此任务用于轮询按键。*/</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 按键被按下了吗?*/</span>         <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">_kbhit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 已按下一个按键。记录时间。 */</span>             xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> xSimulatedBacklightOn <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 背光已关闭，因此将其打开并打印其打开的时间。 */</span>                 xSimulatedBacklightOn <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span> <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span>                                            <span class="token string">"Key pressed, turning backlight ON at time\t\t"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">/* 背光已打开，因此打印一条消息，说明定时器即将重置以及重置的时间。*/</span>                <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span>                                    <span class="token string">"Key pressed, resetting software timer at time\t\t"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">/* 重置软件定时器。如果之前关闭了背光，则此调用将启动定时器。             如果背光先前处于打开状态，则此调用将重新启动定时器。             真实的应用程序可以读取中断中的按键。如果此函数是中断服务例程，             则必须使用xTimerResetFromISR()而不是xTimerReset()。*/</span>             <span class="token function">xTimerReset</span><span class="token punctuation">(</span> xBacklightTimer<span class="token punctuation">,</span> xShortDelay <span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* 读取并丢弃按下的按键 --- 这在这个简单的示例中不是必需的。*/</span>              <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">_getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 86. 示例15中用于重置软件定时器的任务</p><p>执行示例 15 时产生的输出如图 47 所示。参考图 47 ：</p><ul><li>在滴答计数为 812 的时候发生第一次按键。此时，打开背光，并启动一次性定时器。</li><li>当滴答计数为 1813、3114、4015 和 5016 时，发生了进一步的按键。所有这些按键都会导致定时器在到期之前被重置。</li><li>定时器在滴答计数为 10016 时到期。此时，关闭背光。</li></ul><p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401055137191.png" alt="图 47 执行示例 15 时产生的输出"></p><p>在图 47 中可以看到，定时器有 5000 个滴答的周期；最后一次按下按键后，背光恰好在 5000 次滴答后关闭，所以在最后一次重置定时器之后有 5000 个滴答。</p>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3 任务管理</title>
      <link href="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/"/>
      <url>/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-3-任务管理"><a href="#Chapter-3-任务管理" class="headerlink" title="Chapter 3 任务管理"></a>Chapter 3 任务管理</h1><h2 id="3-1-章节介绍和范围"><a href="#3-1-章节介绍和范围" class="headerlink" title="3.1 章节介绍和范围"></a>3.1 章节介绍和范围</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章旨在让读者更好地理解 : </p><ul><li>FreeRTOS 如何为应用程序中的每个任务分配处理时间。</li><li>FreeRTOS 如何选择在任何给定时间应该执行哪个任务。</li><li>每个任务的相对优先级如何影响系统行为。 </li><li>任务可以存在的状态。</li></ul><p>读者还应该充分了解 : </p><ul><li>如何实现任务。</li><li>如何创建任务的一个或多个实例 ( instance ) 。</li><li>如何使用任务参数。</li><li>如何更改已创建任务的优先级。</li><li>如何删除任务。</li><li>如何使用任务实现周期性处理 ( 软件定时器将在后面的章节中讨论 ) 。</li><li>空闲任务何时执行以及如何使用。</li></ul><p>本章介绍的概念对于理解如何使用 FreeRTOS 以及 FreeRTOS 应用程序的行为至关重要。因此，这是书中最详细的一章。</p><h2 id="3-2-任务函数"><a href="#3-2-任务函数" class="headerlink" title="3.2 任务函数"></a>3.2 任务函数</h2><p>任务被实现为 C 函数。 它们唯一的特殊之处是它们的原型，它必须返回 <code>void</code> 并接受一个 <code>void</code> 指针参数。 清单 11 展示了原型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 11. 任务函数原型</p><p>每个任务本身都是一个小程序。 它有一个入口点，通常会在无限循环内永远运行，并且不会退出。典型任务的结构如清单 12 所示。</p><p>不得允许 FreeRTOS 任务以任何方式从其实现函数返回 —— 它们不得包含 <code>return</code> 语句，并且不得允许执行到函数末尾之后。如果不再需要某个任务，则应将其显式删除。清单 12 也演示了这一点。</p><p>单个任务函数定义可用于创建任意数量的任务 —— 每个创建的任务都是一个单独的执行实例 ( instance )，具有自己的堆栈和在任务本身内定义的任何自动 ( 堆栈 ) 变量的副本。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* 变量可以像普通函数一样声明。使用此示例函数创建的任务的每个实例都将拥有自己的 lVariableExample 变量副本。如果变量被声明为静态，则情况并非如此——在这种情况下，只会存在该变量的一个副本，并且该副本将由每个创建的任务实例共享。 ( 添加到变量名称的前缀在第 1.5 节“数据类型和编码风格指南”中描述。 )*/</span>int32_t lVariableExample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 任务通常会以无限循环的形式实现。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 实现任务功能的代码将放在这里。 */</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 如果任务实现突破上述循环，则必须在到达其实现功能结束之前删除该任务。 传递给 vTaskDelete()     API 函数的 NULL 参数指示要删除的任务是调用（当前）任务。 用于命名 API 函数的约定在第 0 节中    描述，使用早于 V9.0.0 的 FreeRTOS 版本的项目必须构建一个 heap_n.c 文件。 从     FreeRTOS V9.0.0 开始，只有在 FreeRTOSConfig.h 中将 configSUPPORT_DYNAMIC_ALLOCATION    设置为 1 或者未定义 configSUPPORT_DYNAMIC_ALLOCATION 时才需要 heap_n.c 文件。 有关更多    信息，请参阅第 2 章堆内存管理。 数据类型和编码风格指南。    如果任务实现从上述循环中突破，则必须在到达其实现函数末尾之前删除该任务。    传递给 vTaskDelete() API 函数的 NULL 参数指示要删除的任务是调用 (此) 任务。    用于命名 API 函数的约定在第 0 节中进行了描述，使用早于 V9.0.0 的 FreeRTOS     版本的项目必须构建 heap_n.c 文件之一。从 FreeRTOS V9.0.0 开始，    仅当 FreeRTOSConfig.h 中的 configSUPPORT_DYNAMIC_ALLOCATION 设置为 1     或 configSUPPORT_DYNAMIC_ALLOCATION 未定义时才需要 heap_n.c 文件。    有关详细信息，请参阅第 2 章“堆内存管理”。      数据类型和编码风格指南。*/</span>    <span class="token function">vTaskDelete</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 12.  一个典型的任务函数的结构</p><h2 id="3-3-顶层任务状态"><a href="#3-3-顶层任务状态" class="headerlink" title="3.3 顶层任务状态"></a>3.3 顶层任务状态</h2><p>应用程序可以包含许多任务。 如果运行应用程序的处理器是单核的，那么在任何给定时间只能执行一个任务。 这意味着任务可以存在两种状态：运行和未运行。 首先考虑这种简单化的模型，但请记住，这是一种过度简化。 在本章的后面，显示 “未运行” 状态实际上包含许多子状态。</p><p>一个应用程序可以包含许多任务。如果运行应用程序的处理器是单核的，则在任何给定时间只能执行一个任务。这意味着任务可以存在于两种状态之一：<code>运行 ( Running )</code> 和 <code>非运行 ( No Running )</code> 。首先考虑这种简单化的模型，但请记住，它过于简单化了。本章后面显示 <code>"非运行 ( No Running )"</code> 状态实际上包含许多子状态。</p><p>当任务处于运行状态时，处理器正在执行任务的代码。当任务处于 <code>"非运行 ( No Running )"</code> 状态时，该任务处于休眠状态，其状态已被保存，以便下次调度程序决定它应该进入 <code>"运行 ( Running ) "</code> 状态时恢复执行。   当任务恢复执行时，它会从上次离开 <code>"运行 ( Running )"</code> 状态之前即将执行的指令开始执行。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240526132629539.png" alt="图 9. 顶层任务状态和转换"></p><p>从 “未运行” 状态转换为 “运行” 状态的任务被称为 “切入” 或 “换入”。 相反，从 “运行” 状态转换到 “未运行” 状态的任务据说已被 “切出” 或 “换出”。 FreeRTOS 的调度程序是唯一可以切换任务的实体。</p><p>从非运行状态转换到运行状态的任务被称为 <code>"切换入 ( switched in ) "</code> 或 <code>"交换入 ( swapped in )"</code>。相反，从运行状态转换到非运行状态的任务被称为 <code>"切换出 ( switched out )"</code> 或 <code>"交换出 ( swapped out )"</code>。FreeRTOS 调度程序是唯一可以切换入和切换出任务的实体。</p><h2 id="3-4-创建任务"><a href="#3-4-创建任务" class="headerlink" title="3.4 创建任务"></a>3.4 创建任务</h2><h3 id="xTaskCreate-API-函数"><a href="#xTaskCreate-API-函数" class="headerlink" title="xTaskCreate() API 函数"></a>xTaskCreate() API 函数</h3><p>FreeRTOS V9.0.0 还包括 <code>xTaskCreateStatic()</code> 函数，该函数在编译时静态地分配创建任务所需的内存: 使用 FreeRTOS <code>xTaskCreate()</code> API 函数创建任务。这可能是所有 API 函数中最复杂的，因此很不幸，它是第一个遇到的函数，但是必须首先掌握任务，因为它们是多任务系统中最基本的组件。本书附带的所有示例都使用了 <code>xTaskCreate()</code> 函数，因此有大量示例可供参考。</p><p>第 1.5 节 “数据类型和编程样式指南” 描述了所使用的数据类型和命名约定。</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> TaskFunction_t pvTaskCode<span class="token punctuation">,</span>                         <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>                         uint16_t usStackDepth<span class="token punctuation">,</span>                         <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">,</span>                         UBaseType_t uxPriority<span class="token punctuation">,</span>                         TaskHandle_t <span class="token operator">*</span>pxCreatedTask <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 13. <code>xTaskCreate()</code> API 函数原型</p><p>表 8. <code>xTaskCreate()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pvTaskCode</code></td><td>任务只是永不退出的 C 函数，因此通常作为无限循环实现。 <code>pvTaskCode</code> 参数只是一个指向实现任务的函数的指针（实际上，只是函数的名称）。</td></tr><tr><td><code>pcName</code></td><td>任务的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。通过人类可读的名称来识别任务要比尝试通过其句柄来识别任务简单得多。<br><br>应用程序定义的常量 <code>configMAX_TASK_NAME_LEN</code> 定义了任务名称可以采用的最大长度 — 包括空终止符。提供长度超过此最大值的字符串将导致字符串被自动截断。<p></p></td></tr><tr><td><code>usStackDepth</code></td><td>每个任务都有自己的唯一堆栈，该堆栈在任务创建时由内核分配给任务。 <code>usStackDepth</code> 值告诉内核堆栈的大小。<br>该值指定堆栈可以容纳的字数，而不是字节数。 例如，如果堆栈是 32 位宽并且 <code>usStackDepth</code> 作为 100 传入，则将分配 400 字节的堆栈空间（100 * 4 字节）。 堆栈深度乘以堆栈宽度不得超过 <code>uint16_t</code> 类型的变量中可包含的最大值。<br>空闲任务使用的堆栈大小由应用程序定义的常量 <code>configMINIMAL_STACK_SIZE</code> [1] 定义。在 FreeRTOS 演示应用程序中为所使用的处理器架构分配给该常量的值是建议用于任何任务的最小值。如果您的任务使用了大量堆栈的空间，则必须分配一个更大的值。<br>没有简单的方法可以确定任务所需的堆栈空间。   可以计算，但大多数用户会简单地分配一个他们认为合理的值，然后使用FreeRTOS提供的功能来确保分配的空间确实足够，并且RAM不会被不必要地浪费。第 12.3 节 “堆栈溢出” 包含有关如何查询任务实际已使用的最大堆栈空间的信息。</td></tr><tr><td><code>pvParameters</code></td><td>任务函数接受指向 <code>void ( void* )</code> 的指针类型的参数。分配给 <code>pvParameters</code> 的值是传递到任务中的值。   本书中的一些示例演示了如何使用该参数。</td></tr><tr><td><code>uxPriority</code></td><td>定义任务执行的优先级。优先级可以从 0（最低优先级）到 ( <code>configMAX_PRIORITIES</code> – 1)（最高优先级）进行分配。 <code>configMAX_PRIORITIES</code> 是一个用户定义的常量，在 3.5 节中描述。<br>传递高于 ( <code>configMAX_PRIORITIES</code> - 1 ) 的 <code>uxPriority</code> 值将导致分配给任务的优先级被静默地限制为最大合法值。</td></tr><tr><td><code>pxCreatedTask</code></td><td><code>pxCreatedTask</code> 可用于传递正在创建的任务的句柄。然后，该句柄可用于在 API 调用中引用任务，例如更改任务优先级或删除任务<br>如果您的应用程序不需要任务句柄，则可以将 <code>pxCreatedTask</code> 设置为 <code>NULL</code>。</td></tr><tr><td>返回值</td><td>有两种可能的返回值：<br><code>pdPASS</code>：<br>这表明任务已成功创建。<br><code>pdFAIL</code>：<br>这表明任务尚未创建，因为没有足够的堆内存可供FreeRTOS分配足够的RAM来容纳任务数据结构和堆栈。<br>第 2 章提供了有关堆内存管理的更多信息。</td></tr></tbody></table><blockquote><p>[1] : 这是 FreeRTOS 源代码使用 <code>configMINIMAL_STACK_SIZE</code> 设置的唯一方式，尽管该常量也在演示应用程序内部使用，以帮助演示在多个处理器架构之间移植。</p></blockquote><h3 id="示例-1-创建任务"><a href="#示例-1-创建任务" class="headerlink" title="示例 1. 创建任务"></a>示例 1. 创建任务</h3><p>此示例演示了创建两个简单任务，然后启动任务执行所需的步骤。这些任务只是周期性地打印出一个字符串，使用一个粗略的空循环来创建周期延迟。这两个任务都是以相同的优先级创建的，除了它们打印出来的字符串之外，它们都是相同的 —— 它们各自的实现见清单14和清单15。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask1</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName <span class="token operator">=</span> <span class="token string">"Task 1 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">volatile</span> uint32_t ul<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* volatile 以确保 ul 不会被优化掉。 */</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟一段时间。 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> ul <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ul <span class="token operator">&lt;</span> mainDELAY_LOOP_COUNT<span class="token punctuation">;</span> ul<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 14. 示例 1 中使用的第一个任务的实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask2</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName <span class="token operator">=</span> <span class="token string">"Task 2 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">volatile</span> uint32_t ul<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* volatile 以确保 ul 不会被优化掉。 */</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟一段时间。 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> ul <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ul <span class="token operator">&lt;</span> mainDELAY_LOOP_COUNT<span class="token punctuation">;</span> ul<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。*/</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 15. 示例 1 中使用的第二个任务的实现</p><p><code>main()</code> 函数在启动调度程序之前创建任务，有关其实现请参见清单 16。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建两个任务之一。请注意，真正的应用程序应该检查 xTaskCreate()     调用的返回值，以确保任务创建成功。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>    vTask1<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* 指向实现任务的函数的指针。 */</span>                    <span class="token string">"Task 1"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 任务的文本名称。这只是为了方便调试。 */</span>                    <span class="token number">1000</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 堆栈深度，小型微控制器将使用比这少得多的堆栈。 */</span>                    <span class="token constant">NULL</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/* 此示例不使用任务参数。 */</span>                    <span class="token number">1</span><span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">/* 此任务将以优先级 1 运行。 */</span>                    <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 此示例不使用任务句柄。 */</span>    <span class="token comment" spellcheck="true">/* 以完全相同的方式，以相同的优先级创建另一个任务。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>vTask2<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 启动调度程序，以便任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了    关于堆内存管理的更多信息。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 16. 启动示例 1 任务</p><p>执行该示例将产生图 10 中所示的输出。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240526181455382.png" alt="图 10. 执行示例 1 时产生的输出"></p><blockquote><p>屏幕截图显示每个任务在下一个任务执行之前打印一次其消息。   这是使用 FreeRTOS Windows 模拟器产生的人为场景。 Windows 模拟器并不是真正的实时。此外，写入 Windows 控制台需要相对较长的时间，并会导致一系列 Windows 系统调用。在具有快速且非阻塞打印功能的真正嵌入式目标上执行相同的代码可能会导致每个任务在切换出去以允许其他任务运行之前多次打印其字符串。</p></blockquote><p>图 10 显示了两个任务似乎同时执行；然而，由于两个任务都在同一处理器核心上执行，因此情况并非如此。实际上，这两个任务都在快速进入和退出运行状态。两个任务都以相同的优先级运行，因此在同一处理器核心上共享时间。它们的实际执行模式如图 11 所示。</p><p>图11底部的箭头显示了从时间 t1 开始的时间流逝。彩色线显示每个时间点正在执行哪个任务 —— 例如，任务 1 在时间 t1 和时间 t2 之间执行。</p><p>任何时候只有一个任务可以处于运行状态。 因此，当一个任务进入 <code>"运行 ( Running ) "</code>  状态 ( 任务被切入 ) 时，另一个任务进入 <code>"非运行 ( No Running ) "</code> 状态（任务被切出）。 </p><p>任一时刻只能有一个任务处于运行状态。因此，当一个任务进入“正在运行”状态（任务被切换入）时，另一个任务进入“未运行”状态（任务被切换出）。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240526182954329.png" alt="图 11. 两个示例 1 任务的实际执行模式"></p><p>示例 1 在启动调度程序之前从 <code>main()</code> 中创建了两个任务。也可以从另一个任务中创建一个任务。例如，可以从任务 1 中创建任务 2，如清单 17 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask1</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName <span class="token operator">=</span> <span class="token string">"Task 1 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">volatile</span> uint32_t ul<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* volatile 以确保 ul 不会被优化掉。 */</span>    <span class="token comment" spellcheck="true">/* 如果正在执行此任务代码，则调度程序必须已经启动。    在进入无限循环之前创建另一个任务。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTask2<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟一段时间。 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> ul <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ul <span class="token operator">&lt;</span> mainDELAY_LOOP_COUNT<span class="token punctuation">;</span> ul<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 17. 调度程序启动后从另一个任务中创建一个任务</p><h3 id="示例-2-使用任务参数"><a href="#示例-2-使用任务参数" class="headerlink" title="示例 2. 使用任务参数"></a>示例 2. 使用任务参数</h3><p>在示例 1 中创建的两个任务是字面上的，它们之间的唯一区别是它们打印出来的文本字符串。 相反，可以通过创建单个任务实现的两个实例来消除这种重复。 然后可以使用任务参数将其应打印的字符串传递给每个任务。</p><p>清单 18 包含示例 2 使用的单任务函数（ <code>vTaskFunction</code> ）的代码。此单个函数替换了示例 1 中使用的两个任务函数（ <code>vTask1</code> 和  <code>vTask2</code> ）。请注意如何将任务参数转换为 <code>char *</code> 以获得任务应该打印出来的字符串。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName<span class="token punctuation">;</span><span class="token keyword">volatile</span> uint32_t ul<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* volatile 以确保 ul 不被优化掉。 */</span>    <span class="token comment" spellcheck="true">/* 要打印出来的字符串是通过参数传入的。将其强制转换为字符指针。 */</span>    pcTaskName <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pvParameters<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟一段时间。 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> ul <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ul <span class="token operator">&lt;</span> mainDELAY_LOOP_COUNT<span class="token punctuation">;</span> ul<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 18. 用于在示例 2 中创建两个任务的单个任务函数</p><p>即使现在只有一个任务实现（<code>vTaskFunction</code>），也可以创建多个已定义任务的实例。每个创建的实例将在 FreeRTOS 调度程序的控制下独立执行。</p><p>清单 19 演示了如何使用 <code>xTaskCreate()</code> 函数的 <code>pvParameters</code> 参数将文本字符串传递给任务。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 定义将作为任务参数传入的字符串。它们被定义为 const 并且不在堆栈上，以确保它们在任务执行时保持有效。 */</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTextForTask1 <span class="token operator">=</span> <span class="token string">"Task 1 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTextForTask2 <span class="token operator">=</span> <span class="token string">"Task 2 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建两个任务之一。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>    vTaskFunction<span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">/* 指向实现任务的函数的指针。 */</span>                    <span class="token string">"Task 1"</span><span class="token punctuation">,</span>              <span class="token comment" spellcheck="true">/* 任务的文本名称。这只是为了方便调试。 */</span>                    <span class="token number">1000</span><span class="token punctuation">,</span>                  <span class="token comment" spellcheck="true">/* 堆栈深度 - 小型微控制器将使用比这少得多的堆栈。 */</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>pcTextForTask1<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 使用任务参数将要打印的文本传递到任务中。 */</span>                    <span class="token number">1</span><span class="token punctuation">,</span>                     <span class="token comment" spellcheck="true">/* 这个任务将以优先级 1 运行。 */</span>                    <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* 本例中没有使用任务句柄。 */</span>    <span class="token comment" spellcheck="true">/* 用完全相同的方法创建另一个任务。注意，这一次将从同一个任务实现 (vTaskFunction)     创建多个任务。只有参数中传递的值不同。正在创建同一任务的两个实例。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTaskFunction<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>pcTextForTask2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 启动调度程序，使任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆    内存管理的更多信息。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 19. 示例 2 所使用的 <code>main()</code> 函数</p><p>示例 2 的输出与图 10 中示例 1 所示的输出完全相同。</p><h2 id="3-5-任务优先级"><a href="#3-5-任务优先级" class="headerlink" title="3.5 任务优先级"></a>3.5 任务优先级</h2><p><code>xTaskCreate()</code> API 函数的 <code>uxPriority</code> 参数为正在创建的任务分配初始优先级。调度程序启动后，可以使用 <code>vTaskPrioritySet()</code> API 函数更改优先级。</p><p>可用优先级的最大数量由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configMAX_PRIORITIES</code> 编译时配置常量设置。低数字优先级值表示低优先级任务，优先级 0 是可能的最低优先级。因此，可用优先级的范围是 0 到 ( <code>configMAX_PRIORITIES</code> – 1)。   任意数量的任务可以共享相同的优先级 —— 确保最大的设计灵活性。</p><p>FreeRTOS 调度程序可以使用两种方法之一来决定哪个任务将处于运行状态。 <code>configMAX_PRIORITIES</code> 可以设置的最大值取决于所使用的方法：</p><ol><li><p>通用方法：通用方法在 C 中实现，可以与所有 FreeRTOS 架构移植一起使用。</p><p>使用通用方法时，FreeRTOS 不会限制 <code>configMAX_PRIORITIES</code> 可以设置的最大值。 但是，始终建议将 <code>configMAX_PRIORITIES</code> 值保持在必要的最小值，因为该值越高，消耗的 RAM 就越多，并且最坏情况下的执行时间也就越长。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 0，或者如果 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 未定义，或者通用方法是为正在使用的 FreeRTOS 移植提供的唯一方法，则将使用通用方法。</p></li><li><p>架构优化方法：</p><p>体系结构优化方法使用少量汇编代码，并且比通用方法更快。 <code>configMAX_PRIORITIES</code> 置不会影响最坏情况下的执行时间。</p><p>如果使用架构优化方法，则 <code>configMAX_PRIORITIES</code> 不能大于 32。与通用方法一样，建议将 <code>configMAX_PRIORITIES</code> 保持在必要的最小值，因为其值越高，消耗的 RAM 就越多。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 1，则将使用架构优化方法。并非所有 FreeRTOS 移植都提供架构优化方法。</p></li></ol><p>FreeRTOS 调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务。 当多个具有相同优先级的任务能够运行时，调度程序将依次将每个任务转入和转出运行状态。</p><h2 id="3-6-时间测量和嘀嗒中断"><a href="#3-6-时间测量和嘀嗒中断" class="headerlink" title="3.6 时间测量和嘀嗒中断"></a>3.6 时间测量和嘀嗒中断</h2><p>第 3.12 节 “调度算法” 描述了一个名为 “时间切片 ( time slicing )” 的可选功能。 到目前为止所提供的示例中使用了时间切片，并且是在它们生成的输出中观察到的行为。在示例中，两个任务都是以相同的优先级创建的，并且两个任务始终能够运行。 因此，每个任务执行一个 <code>"时间片 ( time slice )"</code>，在时间片开始时进入运行状态，在时间片结束时退出运行状态。在图 11 中，t1 和 t2 之间的时间等于单个时间片。</p><p>为了能够选择下一个要运行的任务，调度程序本身必须在每个时间片 <strong>[1]</strong> 的末尾执行。称为 <code>"嘀嗒中断 ( tick interrupt )"</code> 的周期性中断用于此目的。时间片的长度由嘀嗒中断频率有效地设置，该频率由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100 (Hz)，则时间片将为 10 毫秒。两次嘀嗒中断之间的时间称为 <code>"嘀嗒周期 (tick period)"</code>。   一个时间片等于一个嘀嗒周期。</p><blockquote><p>[1] : 需要注意的是，时间片的末尾并不是调度程序可以选择运行新任务的唯一位置；正如本书将演示的那样，在当前正在执行的任务进入阻塞状态后，或者当中断将更高优先级的任务移至就绪状态时，调度程序还将选择一个新任务立即运行。</p></blockquote><p>为了能够选择要运行的下一个任务，调度程序本身必须在每个时间片的末尾执行。 称为 “嘀嗒中断” 的周期性中断用于此目的。 时间片的长度由嘀嗒中断频率有效设置，嘀嗒中断频率由应用程序在 <code>FreeRTOSConfig.h</code> 中定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。 例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100（Hz），则时间片将为 10 毫秒。 两次嘀嗒中断之间的时间称为 “嘀嗒期”。 一个时间片等于一个嘀嗒时间段。</p><p>图 11 可以展开来显示调度程序本身在执行序列中的执行情况。如图 12 所示，其中顶部行显示调度程序何时执行，细箭头显示从任务到嘀嗒中断，然后从嘀嗒中断返回到不同任务的执行顺序。</p><p><code>configTICK_RATE_HZ</code> 的最佳值取决于正在开发的应用程序，但其值通常为 100。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240527235850366.png" alt="图 12. 执行序列展开以显示嘀嗒中断执行"></p><p>FreeRTOS API 调用始终以嘀嗒周期的倍数指定时间，这通常被简单地称为嘀嗒。<code>pdMS_TO_TICKS()</code> 宏将以毫秒为单位的时间转换为以嘀嗒为单位的时间。可用的分辨率取决于定义的嘀嗒频率，如果嘀嗒频率高于 1 KHz (<code>configTICK RATE HZ</code> 大于 1000)，则不能使用 <code>pdMS_TO_TICKS()</code>。则无法使用 <code>pdMS_TO_TICKS()</code>。清单 20 显示了如何使用 <code>pdMS_TO_TICKS()</code> 将指定为 200 毫秒的时间转换为以嘀嗒为单位指定的等效时间。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* pdMS_TO_TICKS() 将以毫秒为单位的时间作为其唯一参数，并计算为以嘀嗒周期为单位的等效时间。 此示例显示 xTimeInTicks 设置为等于 200 毫秒的嘀嗒周期数。 */</span>TickType_t xTimeInTicks <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 20. 使用 <code>pdMS_TO_TICKS()</code> 宏将 200 毫秒转换为嘀嗒周期中的等效时间</p><blockquote><p>注意 : 不建议在应用程序中直接以嘀嗒为单位指定时间，而是使用 <code>pdMS_TO_TICKS()</code> 宏来指定以毫秒为单位的时间，这样做可以确保如果嘀嗒频率发生变化，应用程序中指定的时间不会发生变化。</p></blockquote><p><code>"嘀嗒计数 ( tick count )"</code> 值是自调度器启动以来发生的嘀嗒中断的总数，假设嘀嗒计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为时间一致性由 FreeRTOS 内部管理。</p><p>第 3.12 节 “调度算法” 描述了影响调度程序何时选择要运行的新任务以及何时执行嘀嗒中断的配置常量。</p><h3 id="示例-3-使用优先级进行实验"><a href="#示例-3-使用优先级进行实验" class="headerlink" title="示例 3. 使用优先级进行实验"></a>示例 3. 使用优先级进行实验</h3><p>调度程序将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。 到目前为止，在我们的示例中，已经以相同的优先级创建了两个任务，因此它们是依次进入和退出运行状态的。 此示例研究当示例 2 中创建的两个任务之一的优先级发生更改时会发生什么情况。 这次，第一个任务将以优先级 1 创建，第二个任务将以优先级 2 创建。创建任务的代码如清单 21 所示。实现这两个任务的单个函数没有改变；它仍然只是定期打印出一个字符串，使用空循环来创建延迟。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 定义将作为任务参数传入的字符串。它们被定义为 const 并且不在堆栈上，以确保它们在任务执行时保持有效。 */</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTextForTask1 <span class="token operator">=</span> <span class="token string">"Task 1 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTextForTask2 <span class="token operator">=</span> <span class="token string">"Task 2 is running\r\n"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 以优先级 1 创建第一个任务。优先级是倒数第二个参数。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTaskFunction<span class="token punctuation">,</span> <span class="token string">"Task 1"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>pcTextForTask1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 以优先级 2 创建第二个任务，该任务高于优先级 1。优先级是倒数第二个参数。。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTaskFunction<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>pcTextForTask2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 启动调度程序以便任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 不会到达这里。 */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 21. 创建两个不同优先级的任务</p><p>示例 3 生成的输出如图 13 所示。</p><p>调度程序将始终选择能够运行的最高优先级任务。 任务 2 的优先级高于任务 1，并且始终能够运行；因此，任务 2 是唯一进入运行状态的任务。 由于任务 1 永远不会进入运行状态，因此它永远不会打印出其字符串。则称任务1被任务2 “ 剥夺 “ 了处理时间。( Task 1 is said to be ‘starved’ of processing time by Task 2.  )</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240529001654557.png" alt="图 13. 以不同优先级运行两个任务"></p><p>任务2总是能够运行，因为它永远不需要等待任何东西  —— 它要么是在一个空循环中循环，要么打印到终端。</p><p>图 14 显示了示例 3 的执行顺序。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240529001913254.png" alt="图 14. 当一个任务的优先级高于另一个任务时的执行模式"></p><h2 id="3-7-展开说明-“-非运行-“-状态"><a href="#3-7-展开说明-“-非运行-“-状态" class="headerlink" title="3.7 展开说明 “ 非运行 “ 状态"></a>3.7 展开说明 “ 非运行 “ 状态</h2><p>到目前为止，创建的任务总是有处理要执行，并且不需要等待任何事情 —— 因为它们不需要等待任何事情，所以它们总是能够进入运行状态。这种类型的 “ 连续处理 ( continuous processing ) “ 任务的用途有限，因为它们只能以最低优先级创建。如果它们以任何其他优先级运行，它们将完全阻止优先级较低的任务运行。</p><p>为了使任务有用，必须重写它们以使其成为事件驱动的。 事件驱动的任务只有在触发它的事件发生后才能执行工作 ( 处理 )，并且在该事件发生之前无法进入运行状态。 调度程序始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度程序无法选择它们，而必须选择能够运行的较低优先级任务。 因此，使用事件驱动的任务意味着可以以不同的优先级创建任务，而最高优先级的任务不会耗尽所有较低优先级的任务的处理时间。</p><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>正在等待事件的任务被认为处于 <code>"阻塞 ( Blocked ) "</code> 状态，这是 <code>"非运行 ( No Running ) "</code> 状态的子状态。</p><p>任务可以进入阻止状态以等待两种不同类型的事件:</p><ol><li>时间 ( 与时间相关 time-related ) 事件 Temporal events —— 该事件要么是延迟期到期，要么是达到绝对时间。例如，任务可能会进入阻塞状态，等待 10 毫秒过去。</li><li>同步事件 Synchronization events —— 事件源自另一个任务或中断。例如，任务可能会进入阻塞状态以等待数据到达队列。   同步事件涵盖了广泛的事件类型。</li></ol><p>FreeRTOS 的队列，二进制信号量，计数信号量，互斥量，递归互斥量，事件组和直接到任务通知都可用于创建同步事件。 所有这些功能都将在本书的后续章节中介绍。</p><p>任务可以在具有超时的同步事件上阻塞，从而有效地同时阻塞两种类型的事件。例如，任务可以选择等待最多 10 毫秒以便数据到达队列。如果 10 毫秒内有数据到达，或者 10 毫秒后没有数据到达，任务将离开阻塞状态。</p><h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p><code>" 暂停 ( Suspended ) "</code> 也是 <code>"非运行 ( No Running ) "</code> 状态的子状态。 处于暂停状态的任务对调度程序是不可用的。 进入暂停状态的唯一方法是通过调用 <code>vTaskSuspend()</code> API 函数，退出暂停状态的唯一方法是通过调用 <code>vTaskResume()</code> 或 <code>xTaskResumeFromISR()</code> API 函数。大多数应用程序不使用暂停状态。</p><h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><p>处于 “未运行” 状态但未被阻塞或挂起的任务被称为处于 “就绪” 状态。 它们能够运行，因此 “准备好” 运行，但当前不处于 “运行” 状态。</p><p>处于 <code>"非运行 ( No Running )"</code> 状态但未被 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 的任务被称为 <code>"就绪 ( Ready ) "</code> 状态。它们能够运行，因此 “准备 ( ready ) “ 运行，但目前不处于 <code>"运行 ( Running ) "</code> 状态。</p><h3 id="完成状态转换图"><a href="#完成状态转换图" class="headerlink" title="完成状态转换图"></a>完成状态转换图</h3><p>图 15 扩展了之前过于简化的状态图，以包含本节中描述的所有<code>"非运行 ( No Running )"</code>子状态。到目前为止，示例中创建的任务尚未使用 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 状态；它们仅在  <code>"就绪 ( Ready ) "</code> 状态和 <code>"运行 ( Running ) "</code> 状态之间转换 —— 在图 15 中用粗线突出显示。</p><img src="image-20240529231955847.png" alt="图 15. 完整任务状态机" style="zoom:67%;"><h3 id="示例-4-使用阻塞状态创建延迟"><a href="#示例-4-使用阻塞状态创建延迟" class="headerlink" title="示例 4. 使用阻塞状态创建延迟"></a>示例 4. 使用阻塞状态创建延迟</h3><p>到目前为止，示例中创建的所有任务都是 “周期性的”——它们会延迟一段时间并打印出字符串，然后再延迟一次，依此类推。延迟是使用空循环非常粗略地生成的 —— 任务有效地轮询一个递增的循环计数器，直到它达到固定值。示例 3 清楚地展示了这种方法的缺点。优先级较高的任务在执行空循环时始终保持运行状态，” 剥夺 ( starving ) “ 了优先级较低的任务的任何处理时间。</p><p>任何形式的轮询都存在其他一些缺点，其中最主要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最长的处理时间，因此浪费了处理器周期。示例 4 通过将轮询空循环替换为对 <code>vTaskDelay()</code> API 函数的调用来纠正此行为，该函数的原型如清单 22 所示。新任务定义如清单 23 所示。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelay</code> 设置为 1 时，<code>vTaskDelay()</code> API 函数才可用。</p><p><code>vTaskDelay()</code> 将调用任务置于阻塞状态，并持续固定数量的嘀嗒中断。任务处于阻塞状态时不使用任何处理时间，因此任务仅在实际有工作要做时才使用处理时间。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> TickType_txTicksToDelay <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 22. <code>vTaskDelay()</code> 的函数原型</p><p>表 9. <code>vTaskDelay()</code> 参数 </p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>xTicksToDelay</code></td><td>调用任务在转换回就绪状态之前将保持在阻塞状态的嘀嗒中断数。<br>例如，调用 <code>vTaskDelay(pdMS_TO_TICKS(100))</code> 将导致调用任务保持阻塞状态 100 毫秒。<p></p>例如，如果一个任务在嘀嗒 ( tick ) 计数为 <code>10,000</code> 时调用 <code>vTaskDelay( 100 )</code>，那么它将立即进入阻塞状态，并保持阻塞状态，直到嘀嗒 ( tick ) 计数达到 <code>10,100</code>。</td></tr></tbody></table><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName<span class="token punctuation">;</span> <span class="token keyword">const</span> TickType_t xDelay250ms <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">250</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span>    pcTaskName <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pvParameters<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟一段时间。这次调用 vTaskDelay()，将任务置于阻塞状态，直到延迟时间到期。        该参数采用以 "ticks" 为单位指定的时间，并使用 pdMS_TO_TICKS() 宏         ( 其中声明了 xDelay250ms 常量 ) 将 250 毫秒转换为以 ticks 为单位的等效时间。*/</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> xDelay250ms <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 23. 空循环延迟已被 <code>vTaskDelay()</code> 调用替换后的示例任务的源代码</p><p>尽管这两个任务仍以不同的优先级创建，但现在它们都将运行。示例 4 的输出（如图 16 所示）证实了预期的行为。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240605201928489.png" alt="图 16. 执行示例 4 时产生的输出"></p><p>图 17 所示的执行序列解释了为什么两个任务都会运行，即使它们是以不同的优先级创建的。为简单起见，这里省略了调度程序本身的执行。</p><p>空闲任务在调度程序启动时自动创建，以确保始终至少有一个任务可以运行 ( 至少有一个任务处于就绪状态 ) 。第 3.8 节 空闲任务和空闲任务钩子 更详细地描述了空闲任务。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240605202818532.png" alt="图 17. 任务使用 vTaskDelay() 代替空循环时的执行顺序"></p><p>这两个任务只有实现方式发生了变化，功能没有变化。将图 17 与图 12 进行比较可以清楚地看出，此功能是以更高效的方式实现的。</p><p>图 12 显示了当任务使用空循环来创建延迟时的执行模式——始终运行，因此在任务之间使用百分之百的可用处理器时间。 图 17 显示了任务在整个延迟期间进入阻塞状态时的执行模式，因此只有当它们确实有需要执行的工作时 ( 在本例中只是一条要打印出来的消息 ) 才会使用处理器时间，因此仅使用可用处理时间的一小部分。</p><p>在图 17 的场景中，每次任务离开阻塞状态时，它们都会执行一小段时钟周期，然后重新进入阻塞状态。大多数时候，没有应用程序任务可以运行 ( 没有应用程序任务处于就绪状态 ) ，因此，没有应用程序任务可以选择进入运行状态。在这种情况下，空闲任务将运行。分配给空闲任务的处理时间量是系统中备用处理能力的衡量标准。使用 RTOS 可以显著增加备用处理能力，只需允许应用程序完全由事件驱动即可。</p><p>图 18 中的粗线显示了示例 4 中的任务执行的转换，每个任务现在都经过阻塞状态，然后返回到就绪状态。</p><img src="image-20240605235232308.png" alt="图 18. 粗线表示示例 4 中的任务执行的状态转换" style="zoom:67%;"><h3 id="vTaskDelayUntil-API-函数"><a href="#vTaskDelayUntil-API-函数" class="headerlink" title="vTaskDelayUntil() API 函数"></a>vTaskDelayUntil() API 函数</h3><p><code>vTaskDelayUntil()</code> 与 <code>vTaskDelay()</code> 类似。正如刚才所演示的，<code>vTaskDelay()</code> 参数指定在调用 <code>vTaskDelay()</code> 的任务和同一任务再次退出阻塞状态之间应发生的嘀嗒 ( tick ) 中断数。任务保持阻塞状态的时间长度由 <code>vTaskDelay()</code> 参数指定，但任务离开阻塞状态的时间与调用 <code>vTaskDelay()</code> 的时间有关。</p><p>相反，<code>vTaskDelayUntil()</code> 的参数指定调用任务应从阻塞状态移至就绪状态的确切嘀嗒 ( tick ) 计数值。<code>vTaskDelayUntil()</code> 是当需要固定执行周期 ( 您希望任务以固定频率定期执行 ) 时应使用的 API 函数，因为调用任务被解除阻塞的时间是绝对的，而不是相对于调用函数的时间 ( 与 <code>vTaskDelay()</code> 的情况一样 ) 。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> TickType_t<span class="token operator">*</span> pxPreviousWakeTime<span class="token punctuation">,</span> TickType_t xTimeIncrement <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 24. <code>vTaskDelayUntil()</code> API 函数原型</p><p>表 10. <code>vTaskDelayUntil()</code> 的参数</p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>pxPreviousWakeTime</code></td><td>此参数的命名基于以下假设：<code>vTaskDelayUntil()</code> 用于实现定期且以固定频率执行的任务。在这种情况下，<code>pxPreviousWakeTime</code> 保存任务上次离开阻塞状态 ( 被 <code>" 唤醒 ( woken ) "</code> ) 的时间。此时间用作参考点，以计算任务下次离开阻塞状态的时间。<br><code>pxPreviousWakeTime</code> 指向的变量在 <code>vTaskDelayUntil()</code> 函数中自动更新；它通常不会被应用程序代码修改，但在第一次使用之前必须初始化为当前嘀嗒计数。清单 25 演示了如何执行初始化。</td></tr><tr><td><code>xTimeIncrement</code></td><td>此参数的命名也是基于这样的假设：<code>vTaskDelayUntil()</code> 用于实现定期执行且具有固定频率 ( 由 <code>xTimeIncrement</code> 值设置的频率 ) 的任务。</td></tr></tbody></table><h3 id="示例-5-将示例任务转换为使用-vTaskDelayUntil"><a href="#示例-5-将示例任务转换为使用-vTaskDelayUntil" class="headerlink" title="示例 5. 将示例任务转换为使用 vTaskDelayUntil()"></a>示例 5. 将示例任务转换为使用 vTaskDelayUntil()</h3><p>示例 4 中创建的两个任务是周期性任务，但是使用 <code>vTaskDelay()</code> 并不保证它们运行的频率是固定的，因为任务离开阻塞状态的时间与它们调用 <code>vTaskDelay()</code> 的时间相关。 将任务转换为使用<code>vTaskDelayUntil()</code> 而不是 <code>vTaskDelay()</code> 可以解决这个潜在的问题。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName<span class="token punctuation">;</span>TickType_t xLastWakeTime<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span>    pcTaskName <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pvParameters<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 需要使用当前嘀嗒计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。    此后，xLastWakeTime 将在 vTaskDelayUntil() 中自动更新。 */</span>    xLastWakeTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 这个任务应该精确地每 250 毫秒执行一次。根据 vTaskDelay() 函数，时间是以嘀嗒为        单位度量的，pdMS_TO_TICKS() 宏用于将毫秒转换为嘀嗒。xLastWakeTime 在         vTaskDelayUntil() 中自动更新，因此任务不会显式地更新 xLastWakeTime。 */</span>        <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xLastWakeTime<span class="token punctuation">,</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">250</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 25. 使用 <code>vTaskDelayUntil()</code> 实现示例任务</p><p>示例 5 产生的输出与图 16 中的示例 4 所示的输出完全相同。</p><h3 id="示例-6-组合阻塞和非阻塞任务"><a href="#示例-6-组合阻塞和非阻塞任务" class="headerlink" title="示例 6. 组合阻塞和非阻塞任务"></a>示例 6. 组合阻塞和非阻塞任务</h3><p>前面的示例已经单独检查了轮询和阻塞任务的行为。该示例通过演示两个方案组合时的执行序列来重新实施所述的预期系统行为，如下所述。</p><ol><li><p>创建两个优先级为 1 的任务。它们除了连续打印出一个字符串之外不执行任何操作。</p><p>这些任务从不进行任何可能导致它们进入阻塞状态的 API 函数调用，因此始终处于就绪状态或运行状态。这种性质的任务被称为 <code>" 连续处理 ( continuous processing ) "</code> 任务，因为它们总是有工作要做（尽管在这种情况下是相当琐碎的工作）。清单 26 显示了连续处理任务的源代码。</p></li><li><p>然后创建优先级为 2 的第三个任务，因此优先级高于其他两个任务。第三个任务也只是打印出一个字符串，但这次是定期打印的，所以使用 <code>vTaskDelayUntil()</code> API 函数在每次打印迭代之间将自己置于阻塞状态。</p></li></ol><p>周期性任务的源代码如清单 27 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vContinuousProcessingTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span>    pcTaskName <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pvParameters<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。此任务只是重复执行此操作，不会阻塞或延迟。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 26. 示例 6 中使用的连续处理任务</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vPeriodicTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>TickType_t xLastWakeTime<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xDelay3ms <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 需要使用当前滴答计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。    在此之后，xLastWakeTime 由 vTaskDelayUntil() API 函数自动管理。 */</span>    xLastWakeTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Periodic task is running\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 该任务应每 3 毫秒准确执行一次 - 请参阅此函数中 xDelay3ms 的声明。 */</span>        <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>xLastWakeTime<span class="token punctuation">,</span> xDelay3ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 27. 示例 6 中使用的周期性任务</p><p>图 19 显示了示例 6 产生的输出，并解释了图 20 中显示的执行序列所观察到的行为。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240609003733891.png" alt="图 19. 执行示例 6 时产生的输出"></p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240609004733190.png" alt="图 20. 示例 6 的执行模式"></p><h2 id="3-8-空闲任务和空闲任务钩子"><a href="#3-8-空闲任务和空闲任务钩子" class="headerlink" title="3.8 空闲任务和空闲任务钩子"></a>3.8 空闲任务和空闲任务钩子</h2><p>示例 4 中创建的任务大部分时间处于阻塞状态。处于此状态时，它们无法运行，因此无法被调度程序选中。</p><p>必须始终至少有一个任务可以进入运行状态 [1] 。为确保这种情况，在调用 <code>vTaskStartScheduler()</code> 时，调度程序会自动创建一个空闲任务。空闲任务除了处于循环中之外几乎不执行其他操作 — 因此，与最初第一个示例中的任务一样，它始终能够运行。</p><blockquote><p>[1] : 即使在使用 FreeRTOS 的特殊低功耗功能时也是如此，在这种情况下，如果应用程序创建的任务都无法执行，则执行 FreeRTOS 的微控制器将进入低功耗模式。</p></blockquote><p>空闲任务具有可能的最低优先级 ( 优先级为零 ) ，以确保它永远不会阻止更高优先级的应用程序任务进入运行状态 —— 尽管没有什么可以阻止应用程序设计人员在空闲任务优先级上创建任务，从而共享空闲任务优先级 ( 如果需要 ) ，<code>FreeRTOSConfig.h</code> 中的 <code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于防止空闲任务消耗处理时间，而这些时间可以更有效地分配给应用程序任务。<code>configIDLE_SHOULD_YIELD</code> 在第 3.12 节 “ 调度算法 “ 中进行了描述。</p><p>以最低优先级运行可确保只要优先级较高的任务进入就绪状态，空闲任务就会从运行状态转移出来。 这可以在图 17 中的时间点看到，其中空闲任务被立即换出以允许任务 2 在任务 2 离开被阻止状态的瞬间执行。 据说任务 2 已经抢占了空闲任务。 抢先自动发生，并且不知道任务被抢占。</p><p>以最低优先级运行可确保空闲任务在更高优先级任务进入就绪状态时立即退出运行状态。这可以在图 17 中的时间 tn 处看到，其中空闲任务立即被换出，以允许任务 2 在任务 2 离开阻塞状态的瞬间执行。则称任务 2 已抢占 ( pre-empted ) 空闲任务。抢占是自动发生的，被抢占的任务对此并不知情。Pre-emption occurs automatically, and without the knowledge of the task being pre-empted.</p><p>如果应用程序使用 <code>vTaskDelete()</code> API 函数，那么空闲任务就不会浪费处理时间。这是因为空闲任务负责在删除任务之后清理内核资源。</p><blockquote><p>注意 : 注意：如果应用程序使用 vTaskDelete() API 函数，则空闲任务不能缺少处理时间，这一点至关重要。这是因为空闲任务负责在删除任务后清理内核资源。</p></blockquote><h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>可以通过使用空闲钩子 idle hook ( 或空闲回调 idle callback ) 函数将特定于应用程序的功能直接添加到空闲任务中 —— 该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。</p><p>空闲任务钩子的常见用途包括：</p><ul><li><p>执行低优先级、后台或连续处理功能。</p></li><li><p>测量备用处理能力的数量。（当所有优先级较高的应用程序任务无法执行时，空闲任务将会运行；因此，测量分配给空闲任务的处理时间量可清楚地指示多少处理时间。）</p><p>测量空闲处理能力的数量。( 只有当所有优先级较高的应用程序任务都没有工作要执行时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地表明有多少空闲处理时间。)</p></li><li><p>将处理器置于低功耗模式，提供一种在没有应用程序处理需要执行时节省电量的简单而自动的方法 ( 尽管使用此方法可以实现的电量节省效果不如使用第 10 章 “ 低功耗支持 “ 中描述的无滴答空闲模式  tick-less idle mode 可以实现的电量节省效果 ) 。</p></li></ul><h3 id="对空闲任务钩子函数实现的限制"><a href="#对空闲任务钩子函数实现的限制" class="headerlink" title="对空闲任务钩子函数实现的限制"></a>对空闲任务钩子函数实现的限制</h3><p>空闲任务钩子函数必须遵守以下规则。</p><ol><li><p>空闲任务钩子函数绝不能尝试阻塞或暂停。</p><blockquote><p>注意 : 以任何方式阻塞空闲任务都可能导致没有可用任务进入运行状态的情况。</p></blockquote></li><li><p>如果应用程序使用了 <code>vTaskDelete()</code> API函数，则空闲任务钩子必须始终在合理的时间段内返回其调用者。这是因为空闲任务负责在任务被删除后清理内核资源。如果空闲任务永久地保持在空闲钩子函数中，则无法进行清理。</p></li></ol><p>空闲任务钩子函数必须具有清单 28 所示的名称和原型。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vApplicationIdleHook</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 28. 空闲任务钩子函数名称和原型</p><h3 id="示例-7-定义一个空闲任务钩子函数"><a href="#示例-7-定义一个空闲任务钩子函数" class="headerlink" title="示例 7. 定义一个空闲任务钩子函数"></a>示例 7. 定义一个空闲任务钩子函数</h3><p>示例 4 中使用阻塞 vTaskDelay() API 调用会产生大量空闲时间 — 因为两个应用程序任务都处于阻塞状态，所以空闲任务正在执行的时间。示例 7 通过添加空闲钩子函数来利用此空闲时间，其源代码如清单 29 所示。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 声明一个将由钩子函数递增的变量。 */</span><span class="token keyword">volatile</span> uint32_tulIdleCycleCount <span class="token operator">=</span> <span class="token number">0UL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 空闲钩子函数必须命名为 vApplicationIdleHook()，不带参数，并且返回 void。 */</span><span class="token keyword">void</span> <span class="token function">vApplicationIdleHook</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 这个钩子函数除了递增计数器外什么都不做。 */</span>    ulIdleCycleCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 29. 一个非常简单的空闲钩子函数</p><p>必须在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_IDLE_HOOK</code> 设置为 1，才能调用空闲挂钩函数。</p><p>对实现创建任务的函数稍加修改，以打印出 <code>ulIdleCycleCount</code> 值，如清单 30 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> <span class="token operator">*</span>pcTaskName<span class="token punctuation">;</span><span class="token keyword">const</span> TickType_t xDelay250ms <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">250</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span>    pcTaskName <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> pvParameters<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与大多数任务一样，此任务在无限循环中实现。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称和 ulIdleCycleCount 已增加的次数。 */</span>        <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> pcTaskName<span class="token punctuation">,</span> ulIdleCycleCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 延迟 250 毫秒。 */</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> xDelay250ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 30. 示例任务的源代码现在打印出 <code>ulIdleCycleCount</code> 值</p><p>示例 7 产生的输出如图 21 所示。 因此，在应用任务的每次迭代之间，空闲任务钩子函数被调用大约 400 万次（迭代次数取决于演示执行的硬件的速度）。</p><p>示例 7 产生的输出如图 21 所示。它表明空闲任务钩子函数在应用程序任务的每次迭代之间被调用大约 400 万次 ( 迭代次数取决于执行演示的硬件的速度 ) 。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240609143325610.png" alt="图 21. 执行示例 7 时产生的输出"></p><h2 id="3-9-更改任务的优先级"><a href="#3-9-更改任务的优先级" class="headerlink" title="3.9 更改任务的优先级"></a>3.9 更改任务的优先级</h2><h3 id="vTaskPrioritySet-API-函数"><a href="#vTaskPrioritySet-API-函数" class="headerlink" title="vTaskPrioritySet() API 函数"></a>vTaskPrioritySet() API 函数</h3><p><code>vTaskPrioritySet()</code> API 函数可用于在调度程序启动后更改任何任务的优先级。请注意，当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数是可用的。</p><p>启动调度程序后，可以使用 <code>vTaskPrioritySet()</code> API 函数来更改任何任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数才可用。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskPrioritySet</span><span class="token punctuation">(</span> TaskHandle_t pxTask<span class="token punctuation">,</span> UBaseType_t uxNewPriority <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 31. <code>vTaskPrioritySet()</code> API 函数原型</p><p>表 11. <code>vTaskPrioritySet()</code> 参数</p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTask</code></td><td>正在修改其优先级的任务 ( 主题任务 the subject task ) 的句柄—— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来更改自己的优先级。</td></tr><tr><td><code>uxNewPriority</code></td><td>主题任务要设置的优先级。该优先级自动限制在最大可用优先级 ( <code>configMAX_PRIORITIES - 1</code> ) 内，其中 <code>configMAX_PRIORITIES</code> 是 <code>FreeRTOSConfig.h</code> 头文件中设置的编译时常量。</td></tr></tbody></table><h3 id="uxTaskPriorityGet-API-函数"><a href="#uxTaskPriorityGet-API-函数" class="headerlink" title="uxTaskPriorityGet() API 函数"></a>uxTaskPriorityGet() API 函数</h3><p><code>uxTaskPriorityGet()</code> API 函数可用于查询任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_uxTaskPriorityGet</code> 设置为 1 时，<code>uxTaskPriorityGet()</code> API 函数才可用。</p><pre class=" language-c"><code class="language-c">UBaseType_t <span class="token function">uxTaskPriorityGet</span><span class="token punctuation">(</span> TaskHandle_t pxTask <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 32. <code>uxTaskPriorityGet()</code> API 函数原型</p><p>表 12. <code>uxTaskPriorityGet()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTask</code></td><td>正在查询其优先级的任务 ( 主题任务 ) 的句柄 —— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来查询自己的优先级。</td></tr><tr><td>返回值</td><td>当前分配给正在查询的任务的优先级。</td></tr></tbody></table><h3 id="示例-8-更改任务优先级"><a href="#示例-8-更改任务优先级" class="headerlink" title="示例 8. 更改任务优先级"></a>示例 8. 更改任务优先级</h3><p>调度程序将始终选择最高 ( 优先级 ) 就绪状态的任务作为进入运行状态的任务。示例 8 通过使用 <code>vTaskPrioritySet()</code> API 函数更改两个任务相对于彼此的优先级来演示这一点。</p><p>示例 8 创建了两个优先级不同的任务。两个任务均未进行任何可能导致其进入阻塞状态的 API 函数调用，因此它们始终处于就绪状态或运行状态。因此，具有最高相对优先级的任务将始终是调度程序选择处于运行状态的任务。</p><p>示例 8 的行为如下：</p><ol><li><p>任务 1 ( 清单 33 ) 创建时具有最高优先级，因此保证首先运行。 任务 1 在将任务 2 ( 清单 34 ) 的优先级提高到高于自己的优先级之前打印出几个字符串。</p></li><li><p>任务 2 一旦具有最高相对优先级就开始运行（进入运行状态）。 任何时候只有一个任务可以处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p><p>任务 2 一旦具有最高的相对优先级，就会开始运行 ( 进入运行状态 ) 。任何时刻只能有一个任务处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p></li><li><p>任务 2 在将自己的优先级设置回低于任务 1 的优先级之前打印出一条消息。</p></li><li><p>任务 2 将自己的优先级调低意味着任务 1 再次成为最高优先级任务，因此任务 1 重新进入运行状态，迫使任务 2 回到就绪状态。</p></li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask1</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>UBaseType_t uxPriority<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 此任务将始终在任务 2 之前运行，因为它以更高的优先级创建。    任务 1 和任务 2 都不会阻塞，因此两者始终处于正在运行或就绪状态。     查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " 。 */</span>    uxPriority <span class="token operator">=</span> <span class="token function">uxTaskPriorityGet</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Task 1 is running\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 将任务 2 的优先级设置为高于任务 1 的优先级将导致任务 2 立即开始运行         ( 因为任务 2 的优先级在两个创建的任务中更高 ) 。        请注意在调用 vTaskPrioritySet() 时使用任务 2 的句柄 (xTask2Handle)。        清单 35 显示了如何获取句柄。*/</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"About to raise the Task 2 priority\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vTaskPrioritySet</span><span class="token punctuation">(</span> xTask2Handle<span class="token punctuation">,</span> <span class="token punctuation">(</span> uxPriority <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 任务 1 只有在优先级高于任务 2 时才会运行。因此，要使此任务达到此点，        任务 2 必须已经执行，并将其优先级重新设置回低于此任务的优先级。 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 33. 示例 8 中任务 1 的实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask2</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>UBaseType_t uxPriority<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 任务 1 将始终在此任务之前运行，因为任务 1 的创建优先级更高。    任务 1 和任务 2 都不会阻塞，因此将始终处于正在运行或就绪状态。    查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " */</span>    uxPriority <span class="token operator">=</span> <span class="token function">uxTaskPriorityGet</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 要使此任务达到此点，任务 1 必须已经运行，并将此任务的优先级设置为高        于其自身的优先级。         打印出此任务的名称。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Task 2 is running\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 传入 NULL 作为任务句柄意味着 " 更改调用任务的优先级 "。        将优先级设置为低于任务 1 的优先级将导致任务 1 立即再次开始运行         - 抢占此任务。*/</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"About to lower the Task 2 priority\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vTaskPrioritySet</span><span class="token punctuation">(</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span> uxPriority <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 34. 示例 8 中任务 2 的实现</p><p>每个任务都可以查询和设置自己的优先级，而无需使用有效的任务句柄，只需使用 <code>NULL</code> 即可。只有当任务希望引用除自身之外的其他任务时，才需要任务句柄，例如当任务 1 更改任务 2 的优先级时。为了允许任务 1 执行此操作，在创建任务 2 时获取并保存任务 2 句柄，如清单 35 中的注释中突出显示的那样。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 声明一个用于保存任务 2 的句柄的变量。 */</span>TaskHandle_t xTask2Handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建优先级为 2 的第一个任务。任务参数未使用，    设置为 NULL。任务句柄也未使用，因此也设置为 NULL。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTask1<span class="token punctuation">,</span> <span class="token string">"Task 1"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 任务以优先级 2 创建 ______________________^. */</span>    <span class="token comment" spellcheck="true">/* 创建优先级为 1 的第二个任务 - 该优先级低于赋予任务 1 的优先级。    同样，任务参数未使用因此设置为 NULL - 但这次需要任务句柄，    因此 xTask2Handle 的地址在最后一个参数中传递。*/</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTask2<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTask2Handle <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 任务句柄是最后一个参数 _______________________^^^^^^^^^^^^^ */</span>    <span class="token comment" spellcheck="true">/* 启动调度程序，使任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存可用于创建空闲任务。第 2 章    提供了关于堆内存管理的更多信息。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 35. 示例 8 的 <code>main()</code> 实现</p><p>图 22 演示了示例 8 任务的执行顺序，其结果输出如图 23 所示。</p><img src="image-20240609163053423.png" alt="图 22. 运行示例 8 时的任务执行顺序" style="zoom:67%;"><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240609163343194.png" alt="图 23. 执行示例 8 时产生的输出"></p><h2 id="3-10-删除任务"><a href="#3-10-删除任务" class="headerlink" title="3.10 删除任务"></a>3.10 删除任务</h2><h3 id="vTaskDelete-API-函数"><a href="#vTaskDelete-API-函数" class="headerlink" title="vTaskDelete() API 函数"></a>vTaskDelete() API 函数</h3><p>任务可以使用 <code>vTaskDelete()</code> API 函数删除自身或任何其他任务。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelete</code> 设置为 1 时，<code>vTaskDelete()</code> API 函数才可用。</p><p>删除的任务不再存在，无法再次进入运行状态。</p><p>空闲任务负责释放分配给已删除任务的内存。因此，使用 <code>vTaskDelete()</code> API 函数的应用程序不要完全剥夺 ( starve ) 空闲任务的所有处理时间，这一点很重要。</p><blockquote><p>注意 : 只有内核分配给任务的内存才会在任务被删除时自动释放。任何由任务实现分配的内存或其他资源必须显式释放。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTaskDelete</span><span class="token punctuation">(</span> TaskHandle_t pxTaskToDelete <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 36. <code>vTaskDelete()</code> 函数原型</p><p>表 13. <code>vTaskDelete()</code> 参数</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTaskToDelete</code></td><td>要删除的任务 ( 主题任务 ) 的句柄——有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 来代替有效的任务句柄来删除自身。</td></tr></tbody></table><h3 id="示例9-删除任务"><a href="#示例9-删除任务" class="headerlink" title="示例9. 删除任务"></a>示例9. 删除任务</h3><p>这是一个非常简单的示例，其行为如下。</p><ol><li>任务 1 由 <code>main()</code> 创建，优先级为 1。当它运行时，它会创建优先级为 2 的任务 2。任务 2 现在是最高优先级的任务，因此它会立即开始执行。<code>main()</code> 的源代码如清单 37 所示，任务 1 的源代码如清单 38 所示。</li><li>任务 2 除了删除自己之外，什么也不会做。它可以通过向 <code>vTaskDelete()</code> 传递 <code>NULL</code> 来删除自己，但是出于演示目的，它会使用自己的任务句柄。任务 2  的源代码如清单 39 所示。</li><li>当任务 2 被删除时，任务 1 再次成为优先级最高的任务，所以它将继续执行 —— 此时它会调用 <code>vTaskDelay()</code> 来阻塞一小段时间。</li><li>空空闲任务在任务 1 处于阻塞状态时执行，并释放分配给现已删除的任务 2 的内存。</li><li>当任务 1 离开阻塞状态时，它将再次变为最高优先级的就绪状态任务，从而抢占空闲任务。当进它入运行状态时，它将再次创建任务 2， 以此类推。</li></ol><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 以优先级 1 创建第一个任务。不使用任务参数，因此将其设置为NULL。     任务句柄也未使用，因此同样设置为 NULL 。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTask1<span class="token punctuation">,</span> <span class="token string">"Task 1"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 该任务以优先级 1 创建 ____________________^. */</span>    <span class="token comment" spellcheck="true">/* 启动调度程序，以便任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 由于调度程序已经启动，main() 永远不会到达此处。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 37. 示例 9 的 main() 的实现</p><pre class=" language-c"><code class="language-c">TaskHandle_t xTask2Handle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">vTask1</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> TickType_txDelay100ms <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">100UL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 打印这个任务的名称 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Task 1 is running\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 创创建优先级更高的任务 2。 同样没有使用任务参数，所以将其设置为 NULL         —— 但是这次需要任务句柄，因此将 xTask2Handle 的地址作为最后一个参数传递。*/</span>        <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vTask2<span class="token punctuation">,</span> <span class="token string">"Task 2"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>xTask2Handle <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */</span>        <span class="token comment" spellcheck="true">/* 任务 2 具有更高的优先级，因此，任务 1 到达此处时，        任务 2 必须已执行并删除自身。延迟 100 毫秒。 */</span>        <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> xDelay100ms <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 38. 示例 9 的任务 1 的实现</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTask2</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 任务 2 什么也不做，只是删除自身。为此，它可以使用 NULL     作为参数来调用 vTaskDelete()，但出于演示目的，    它调用 vTaskDelete() 并传递自己的任务句柄。 */</span>    <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Task 2 is running and about to delete itself\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">vTaskDelete</span><span class="token punctuation">(</span> xTask2Handle <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 39. 示例 9 的任务 2 的实现</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240610022134603.png" alt="执行示例 9 时产生的输出"></p><p>![图 25. 示例 9 的执行顺序](Chapter 3 任务管理/image-20240610023224251.png)</p><h2 id="3-11-线程本地存储"><a href="#3-11-线程本地存储" class="headerlink" title="3.11 线程本地存储"></a>3.11 线程本地存储</h2><p>待完成。本节将在最终发布之前编写。</p><blockquote><p>译者注 : 原文就是待完成。</p></blockquote><h2 id="3-12-调度算法"><a href="#3-12-调度算法" class="headerlink" title="3.12 调度算法"></a>3.12 调度算法</h2><h3 id="任务状态和事件的回顾"><a href="#任务状态和事件的回顾" class="headerlink" title="任务状态和事件的回顾"></a>任务状态和事件的回顾</h3><p>实际正在运行 ( 使用处理时间 ) 的任务处于运行状态。在单核处理器上，在任何给定时间只能有一个任务处于运行状态。</p><p>未实际运行但未处于阻塞状态或暂停状态的任务处于就绪状态。处于就绪状态的任务可被调度程序选择为进入运行状态的任务。调度程序将始终选择优先级最高的就绪状态任务进入运行状态。</p><p>任务可以在阻塞状态下等待事件，并在事件发生时自动移回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发出异步活动信号，例如数据到达外设。</p><p>任务可以在阻塞状态下等待事件，并在事件发生时自动返回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发信号通知异步活动，例如数据到达外设。</p><h3 id="配置调度算法"><a href="#配置调度算法" class="headerlink" title="配置调度算法"></a>配置调度算法</h3><p>调度算法是决定哪个就绪状态任务转换到运行状态的软件例程。</p><p>到目前为止，所有示例都使用了相同的调度算法，但可以使用 <code>configUSE_PREEMPTION</code> 和 <code>configUSE_TIME_SLICING</code> 配置常量更改算法。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p><p>第三个配置常量 <code>configUSE_TICKLESS_IDLE</code> 也会影响调度算法，因为使用该常量会导致嘀嗒中断在较长时间内完全关闭。<code>configUSE_TICKLESS_IDLE</code> 是一个高级选项，专门用于必须最小化其功耗的应用程序。第 10 章 “ 低功耗支持 “ 中介绍了 <code>configUSE_TICKLESS_IDLE</code> 。本节提供的描述假设 <code>configUSE_TICKLESS_IDLE</code> 设置为 0，如果常量未定义，则这是默认设置。</p><p>在所有可能的配置中，FreeRTOS 调度程序将确保选择具有同等优先级的任务依次进入运行状态。这种 “ 轮流使用 take it in turn” 策略通常称为 <code>" 循环调度 ( Round Robin Scheduling ) "</code> 。循环调度算法不保证在具有同等优先级的任务之间平均分配时间，而只保证具有同等优先级的就绪状态任务将依次进入运行状态。</p><h3 id="带时间片的优先抢占式调度"><a href="#带时间片的优先抢占式调度" class="headerlink" title="带时间片的优先抢占式调度"></a>带时间片的优先抢占式调度</h3><p>表 14 中显示的配置将 FreeRTOS 调度程序设置为使用一种称为 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code> 的调度算法，这是大多数小型 RTOS 应用程序使用的调度算法，也是本书迄今为止介绍的所有示例使用的算法。表 15 提供了算法名称中使用的术语的描述。</p><p>表 14. 将内核配置为使用带时间片的优先抢占式调度的 <code>FreeRTOSConfig.h</code> 设置</p><table><thead><tr><th align="center">常量</th><th align="center">值</th></tr></thead><tbody><tr><td align="center"><code>configUSE_PREEMPTION</code></td><td align="center">1</td></tr><tr><td align="center"><code>configUSE_TIME_SLICING</code></td><td align="center">1</td></tr></tbody></table><p>表 15. 用于描述调度策略的术语的解释</p><table><thead><tr><th align="center">术语</th><th>定义</th></tr></thead><tbody><tr><td align="center">固定优先级<br>( Fixed Priority  )</td><td>被描述为 “ 固定优先级 “ 的调度算法不会更改分配给被调度任务的优先级，但也不会阻止任务本身更改自己的优先级或其他任务的优先级。</td></tr><tr><td align="center">抢占<br>( Pre-emptive )</td><td>如果优先级高于运行状态任务的任务进入就绪状态，抢占式调度算法将立即 “ 抢占 ( pre-empt ) “ 运行状态任务。被抢占意味着非自愿地 ( 无需显式地让出 yielding 或阻塞 blocking ) 移出运行状态并进入就绪状态，以允许不同的任务进入运行状态。</td></tr><tr><td align="center">时间片<br>( Time Slicing )</td><td>时间片用于在优先级相同的任务之间共享处理时间，即使任务没有显式地让出 ( yield ) 或进入阻塞 ( blocked) 状态。如果存在其他与运行任务具有相同优先级的就绪状态任务，描述为使用 <code>" 时间片 ( Time Slicing ) "</code> 的调度算法将在每个时间片结束时选择一个新任务进入运行状态。时间片等于两个 RTOS 嘀嗒中断之间的时间。</td></tr></tbody></table><p>图 26 和图 27 说明了当使用具有时间分片算法的固定优先级抢占式调度时如何调度任务。 图 26 显示了当应用程序中的所有任务具有唯一优先级时，选择任务以进入“运行”状态的顺序。 图 27 显示了当应用程序中的两个任务共享优先级时，选择任务以进入“运行”状态的顺序。</p><p>图 26 和图 27 演示了使用 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code>  算法时任务的调度方式。图 26 显示了当应用程序中的所有任务都具有唯一的优先级时，选择任务进入运行状态的顺序。图 27 显示了当应用程序中的两个任务共享一个优先级时，选择任务进入运行状态的顺序。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240610125928163.png" alt="图 26. 执行模式突出显示假设应用程序中的任务优先级和抢占，其中每个任务都被分配了唯一的优先级"></p><p>参考图26 : </p><ol><li><p><strong>空闲任务</strong> ：空闲任务以最低优先级运行，因此每次较高优先级的任务进入就绪状态时，空闲任务都会被抢占 —— 例如在时间 t3、t5 和 t9。</p></li><li><p><strong>任务 3</strong> ：任务 3 是一个事件驱动的任务，它以相对较低的优先级执行，但高于空闲优先级。 它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次事件发生时从阻塞状态转换到就绪状态。 所有 FreeRTOS 任务间通信机制 ( 任务通知，队列，信号量，事件组等 ) 都可用于以这种方式发出事件信号和解除任务阻塞。</p><p>事件发生在时间 t3 和 t5，以及 t9 和 t12 之间的某个时间。发生在时间 t3 和 t5 的事件会立即得到处理，因为在这些时间，任务 3 是能够运行的最高优先级任务。发生在时间 t9 和 t12 之间的某个时间的事件直到 t12 才会得到处理，因为在此之前，优先级较高的任务任务 1 和任务 2 仍在执行。只有在时间 t12 时，任务 1 和任务 2 才处于阻塞状态，从而使任务 3 成为优先级最高的就绪状态任务。</p></li><li><p><strong>任务 2</strong> : 任务 2 是一个周期性任务，其执行优先级高于任务 3 的优先级，但低于任务 1 的优先级。该任务的周期间隔意味着任务 2 想要在时间 t1、t6 和 t9 执行。</p><p>在时间 t6，任务 3 处于运行状态，但任务 2 具有较高的相对优先级，因此抢占任务 3 并立即开始执行。任务 2 完成其处理并在时间 t7 重新进入阻塞状态，此时任务 3 可以重新进入运行状态以完成其处理。任务 3 本身在时间 t8 阻塞。</p></li><li><p><strong>任务 1</strong> : 任务 1 也是一个事件驱动任务。它以最高的优先级执行，因此可以抢占系统中的任何其他任务。图中显示的唯一任务 1 事件发生在时间 t10，此时任务 1 抢占任务 2。只有在任务 1 于时间 t11 重新进入阻塞状态后，任务 2 才能完成其处理。</p></li></ol><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240610154453687.png" alt="图 27. 执行模式突出显示假设应用程序中的任务优先级和时间片，其中两个任务以相同的优先级运行"></p><p>参考图 27 : </p><ol><li><p><strong>空闲任务与任务 2</strong>：空闲任务和任务 2 都是连续处理 ( continuous processing ) 任务，优先级均为 0 ( 最低优先级 ) 。调度程序仅在没有更高优先级的任务可运行时才将处理时间分配给优先级 0 任务，并通过时间分片共享分配给优先级 0 任务的时间。每次嘀嗒中断都会开始一个新的时间片，在图 27 中，时间片为 t1、t2、t3、t4、t5、t8、t9、t10 和 t11。</p><p>空闲任务和任务 2 依次进入运行状态，这会导致两个任务在同一时间片的部分时间内处于运行状态，就像在时间 t5 和时间 t8 之间发生的情况一样。</p></li><li><p><strong>任务 1</strong>：任务 1 的优先级高于空闲优先级。任务 1 是一个事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次发生事件时，它都会从阻塞状态转换到就绪状态。</p><p>感兴趣的事件发生在时间 t6，因此在 t6 时任务 1 成为能够运行的最高优先级任务，因此任务 1 在时间片中抢占空闲任务。事件处理在时间 t7 时完成，此时任务 1 重新进入阻塞状态。</p></li></ol><p>图 27 显示了空闲任务与应用程序编写者创建的任务共享处理时间。如果应用程序编写者创建的空闲优先级任务有工作要做，而空闲任务没有工作要做，那么为空闲任务分配那么多处理时间可能并不可取。<code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于更改空闲任务的调度方式：</p><ul><li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 0，则空闲任务将在整个时间片内保持运行状态，除非它被更高优先级的任务抢占。</li><li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 1，则如果有其他空闲优先级任务处于就绪状态，则空闲任务将在其循环的每次迭代中让出 yield ( 自愿放弃其分配的时间片的剩余部分 ) 。</li></ul><p>图 27 中所示的执行模式是当 <code>configIDLE_SHOULD_YIELD</code> 设置为 0 时将观察到的内容。图 28 中所示的执行模式是在 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时在相同场景中观察到的内容。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240611075853590.png" alt="图 28. 与图 27 所示场景相同的执行模式，但这次将 configIDLE_SHOULD_YIELD 设置为 1"></p><p>图 28 还显示，当 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时，在空闲任务之后被选择进入运行状态的任务不会执行整个时间片，而是执行空闲任务让出的时间片的剩余部分。</p><h3 id="优先级抢占式调度-无时间片"><a href="#优先级抢占式调度-无时间片" class="headerlink" title="优先级抢占式调度 ( 无时间片 )"></a>优先级抢占式调度 ( 无时间片 )</h3><p>没有时间切片的优先抢占式调度保持与上一节中描述的相同的任务选择和抢占算法，但不使用时间切片在具有相同优先级的任务之间共享处理时间。</p><p>表 16 显示了将 FreeRTOS 调度程序配置为使用无时间片的优先级抢占式调度的 <code>FreeRTOSConfig.h</code> 设置。</p><p>表 16.  <code>FreeRTOSConfig.h</code> 设置，用于将内核配置为使用无时间片的优先级抢占式调度 </p><table><thead><tr><th align="center">常量</th><th align="center">值</th></tr></thead><tbody><tr><td align="center"><code>configUSE_PREEMPTION</code></td><td align="center">1</td></tr><tr><td align="center"><code>configUSE_TIME_SLICING</code></td><td align="center">0</td></tr></tbody></table><p>如图 27 所示，如果使用时间分片，并且有多个处于最高优先级的就绪状态任务能够运行，那么调度程序将在每个RTOS滴答中断 ( 标记时间片结束的滴答中断 ) 期间选择一个新任务进入运行状态。如果不使用时间分片，则调度程序将仅在以下任一情况下选择新任务进入运行状态 :  &lt;—- here</p><ul><li>更高优先级的任务进入就绪状态。</li><li>处于运行状态的任务进入阻塞状态或者暂停状态。</li></ul><p>不使用时间片时，任务上下文切换次数比使用时间片时少。因此，关闭时间片可减少调度程序的处理开销。但是，关闭时间片也会导致优先级相同的任务收到的处理时间量相差很大，如图 29 所示。因此，不使用时间片运行调度程序被视为一种高级技术，仅应由经验丰富的用户使用。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240612131241019.png" alt="图 29. 执行模式，演示当不使用时间片时，相同优先级的任务如何获得截然不同的处理时间"></p><p>参考图 29 ，假设 <code>configIDLE_SHOULD_YIELD</code> 设置为 0：</p><ol><li><p><strong>嘀嗒中断</strong>：</p><p>嘀嗒中断发生在时间 t1、t2、t3、t4、t5、t8、t11、t12 和 t13 。</p></li><li><p><strong>任务 1</strong>：</p><p>任务 1 是一个高优先级事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件。每次事件发生时，任务 1 都会从阻塞状态转换为就绪状态 ( 随后，由于它是优先级最高的就绪状态任务，因此会转换为运行状态 ) 。图 29 显示任务 1 在时间 t6 和 t7 之间处理事件，然后在时间 t9 和 t10 之间再次处理事件。</p></li><li><p><strong>空闲任务与任务 2</strong>：</p><p>空闲任务和任务2都是连续处理任务，并且优先级都为 0  ( 空闲优先级 ) 。连续处理任务不进入阻塞状态。</p><p>由于未使用时间片，因此处于运行状态的空闲优先级任务将保持运行状态，直到被更高优先级的任务 1 抢占。</p><p>在图 29 中，空闲任务在时间 t1 开始运行，并保持运行状态，直到在时间 t6 被任务 1 抢占——此时距离其进入运行状态已过去了四个完整的嘀嗒周期以上。 </p><p>任务 2 在时间 t7 开始运行，此时任务 1 重新进入阻塞状态以等待另一个事件。任务 2 一直处于运行状态，直到它也在时间 t9 被任务 1 抢占——此时距离它进入运行状态还不到一个嘀嗒周期。</p><p>在时间 t10，空闲任务重新进入运行状态，尽管其已获得比任务 2 多四倍以上的处理时间。</p></li></ol><h3 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h3><p>本书主要介绍抢占式调度，但 FreeRTOS 也可以使用 <code>协作式调度 ( co-operative scheduling )</code> 。配置 FreeRTOS 调度程序使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置如表 17 所示。</p><p>表 17. 将内核配置为使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置</p><table><thead><tr><th align="center">常量</th><th align="center">值</th></tr></thead><tbody><tr><td align="center"><code>configUSE_PREEMPTION</code></td><td align="center">0</td></tr><tr><td align="center"><code>configUSE_TIME_SLICING</code></td><td align="center">任何值</td></tr></tbody></table><p>当使用协作式调度程序时，仅当运行状态任务进入阻塞状态，或运行状态任务通过调用 <code>taskYIELD()</code> 显式地让出 ( 手动请求重新调度 ) 时，才会发生上下文切换。任务永远不会被抢占，因此不能使用时间片。</p><p>图 30 演示了协作式调度程序的行为。图 30 中的水平虚线显示任务何时处于就绪状态。</p><p><img src="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/image-20240613005719519.png" alt="图 30. 演示协作式调度程序行为的执行模式"></p><p>参考图 30 : </p><ol><li><p><strong>任务 1</strong>：</p><p>任务 1 有最高优先级，它开始于阻塞状态，等待一个信号量。</p><p>在时间 t3 处，一个中断会 <code>给出 ( give )</code> 信号量，导致任务 1 离开阻塞状态并进入就绪状态 ( 第 6 章介绍从中断给出信号量 ) 。</p><p>在时间 t3 时，任务 1 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 1 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 1 保持在就绪状态，直到时间 t4 — 即运行状态任务调用 <code>taskYIELD()</code> 时。</p></li><li><p><strong>任务 2</strong>：</p><p>任务 2 的优先级介于任务 1 和任务 3 之间。它开始于阻塞状态，等待由任务 3 在时间 t2 发送给它的消息。</p><p>在时间 t2 时，任务 2 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 2 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 2 保持在就绪状态，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 。</p><p>运行状态任务在时刻 t4 调用 <code>taskYIELD()</code> ，但此时任务 1 是优先级最高的就绪状态任务，因此直到任务 1 在时刻 t5 重新进入阻塞状态时，任务 2 才真正成为运行状态任务。</p><p>在时间 t6 时，任务 2 重新进入阻塞状态以等待下一条消息，此时任务 3 再次成为最高优先级的就绪状态任务。</p></li></ol><p>在一个多任务应用程序中，应用程序编写者必须注意不要让多个任务同时访问同一个资源，因为同时访问可能会损坏资源。例如，考虑以下场景，其中访问的资源是 UART ( 串行端口 )。两个任务正在将字符串写入 UART；任务 1 正在写入 <code>"abcdefghijklmnop"</code>，任务 2 正在写入 <code>"123456789"</code> ：</p><ol><li>任务 1 处于运行状态并开始写入其字符串。它将 <code>"abcdefg"</code> 写入 UART，但在写入任何其他字符之前离开运行状态。</li><li>任务 2 进入运行状态，并在离开运行状态之前将 <code>"123456789"</code> 写入UART。</li><li>任务 1 重新进入运行状态，并将其字符串的剩余字符写入 UART。</li></ol><p>在这种情况下，实际写入 UART 的是 <code>"abcdefg123456789hijklmnop"</code> 。任务 1 写入的字符串并未按预期以不间断的顺序写入 UART，而是被破坏了，因为任务 2 写入 UART 的字符串出现在其中。</p><p>通常，使用协作调度程序比使用抢占式调度程序更容易避免由同时访问引起的问题 [1]：</p><blockquote><p>[1] : 在任务之间安全共享资源的方法将在本书后面介绍。FreeRTOS 本身提供的资源 ( 如队列和信号量 ) 始终可以在任务之间安全共享。</p></blockquote><ul><li>当使用抢占式调度程序时，运行状态任务可以随时被抢占，包括当它与另一个任务共享的资源处于不一致状态时。正如 UART 示例所展示的那样，让资源处于不一致状态可能会导致数据损坏。</li><li>当使用协作调度程序时，应用程序编写者可以控制何时切换到另一个任务。因此，应用程序编写者可以确保在资源处于不一致状态时不会切换到另一项任务。</li><li>在上面的 UART 示例中，应用程序编写者可以确保任务 1 在其整个字符串写入 UART 之前不会离开运行状态，这样就消除了字符串被另一个任务的操作破坏的可能性。</li></ul><p>如图 30 所示，使用协作调度程序时系统的响应速度比使用抢占式调度程序时要慢：</p><ul><li>当使用抢占式调度器时，一旦某个任务成为最高优先级的就绪状态任务，调度器会立即开始运行该任务。这在必须在规定时间内响应高优先级事件的实时系统中通常是至关重要的。</li><li>当使用协作调度程序时，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 时，才会切换到成为最高优先级的就绪状态任务的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 6 中断管理</title>
      <link href="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/"/>
      <url>/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="中断管理"><a href="#中断管理" class="headerlink" title="中断管理"></a>中断管理</h1><h2 id="章节介绍和范围"><a href="#章节介绍和范围" class="headerlink" title="章节介绍和范围"></a>章节介绍和范围</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>嵌入式实时系统必须对源自环境的事件做出响应。例如，到达以太网外设的数据包（事件）可能需要传递到 TCP/IP 栈进行处理（操作）。非平凡的系统必须服务于来自多个源的事件，所有这些源都有不同的处理开销和响应时间要求。在每种情况下，都必须对最佳事件处理实施策略作出判断：</p><ol><li>如何检测事件？通常使用中断，但也可以轮询输入。</li><li>当使用中断时，应在中断服务例程 (ISR) 内部执行多少处理，在外部执行多少处理？通常希望每个 ISR 尽可能短。</li><li>如何将事件与主 (非 ISR) 代码通信，以及如何构造此代码以最佳地适应潜在异步事件的处理？</li></ol><p>FreeRTOS 不会对应用程序设计者强加任何特定的事件处理策略，但确实提供了允许以简单且可维护的方式实现所选策略的功能。</p><p>重要的是区分任务的优先级和中断的优先级：</p><ul><li>任务是与运行 FreeRTOS 的硬件无关的软件功能。 任务的优先级由应用程序编写者在软件中分配，软件算法 (调度器) 决定哪个任务将处于运行状态。</li><li>虽然中断服务例程是用软件编写的，但它是一个硬件特性，因为硬件控制哪个中断服务例程将运行，以及何时运行。任务只会在没有 ISR 运行时运行，因此最低优先级的中断将中断最高优先级的任务，并且任务无法抢占 ISR 。</li></ul><p>所有运行 FreeRTOS 的体系结构都能够处理中断，但是与中断进入和中断优先级分配有关的架构之间有所不同。</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章旨在让读者更好地理解：</p><ul><li>哪些 FreeRTOS API 函数可以在中断服务程序中使用。</li><li>将中断处理延迟到任务的方法。</li><li>如何创建和使用二进制信号量和计数信号量。</li><li>二进制和计数信号量之间的区别。</li><li>如何使用队列将数据传入和传出中断服务程序。</li><li>中断嵌套模型可用于一些 FreeRTOS 移植。</li></ul><h2 id="从-ISR-使用-FreeRTOS-API"><a href="#从-ISR-使用-FreeRTOS-API" class="headerlink" title="从 ISR 使用 FreeRTOS API"></a>从 ISR 使用 FreeRTOS API</h2><h3 id="中断安全-API"><a href="#中断安全-API" class="headerlink" title="中断安全 API"></a>中断安全 API</h3><p>通常需要从中断服务例程 (ISR) 中使用 FreeRTOS API 函数提供的功能，但是许多FreeRTOS API 函数执行的操作在 ISR 中无效——其中最值得注意的是将调用 API 函数的任务置于阻塞状态； 如果从 ISR 调用 API 函数，则它不是从任务调用的，所以没有调用任务可以被置于阻塞状态。 FreeRTOS 通过提供一些 API 函数的两个版本来解决这个问题；一个版本用于任务，另一个版本用于 ISR。打算从 ISR 中使用的函数在其名称后附加了  “<code>FromISR</code>” 。</p><blockquote><p>注意：切勿从 ISR 调用名称中不含 “<code>FromISR</code>” 的 FreeRTOS API 函数。</p></blockquote><h3 id="使用单独的中断安全-API-的好处"><a href="#使用单独的中断安全-API-的好处" class="headerlink" title="使用单独的中断安全 API 的好处"></a>使用单独的中断安全 API 的好处</h3><p>具有用于中断的单独 API 可以使任务代码更高效，ISR 代码更有效，并且进入中断更简单。 要了解原因，请考虑另一种解决方案，该解决方案将提供可以从任务和 ISR 调用的每个 API 函数的单个版本。如果可以从任务和 ISR 调用相同版本的 API 函数，则：</p><ul><li>API 函数将需要额外的逻辑来确定它们是从任务还是 ISR 调用的。额外的逻辑将引入通过函数的新路径，使函数更长，更复杂，更难测试。</li><li>当从任务调用函数时，某些 API 函数参数将过时，而当从 ISR 调用函数时，其他 API 函数参数将过时。</li><li>每个 FreeRTOS 移植都需要提供一个用于确定执行上下文 (任务或ISR) 的机制。</li><li>难以确定执行上下文（任务或 ISR）的架构将需要额外的、浪费的、使用起来更复杂的非标准中断进入代码，允许软件提供执行上下文。</li></ul><h3 id="使用单独的中断安全-API-的缺点"><a href="#使用单独的中断安全-API-的缺点" class="headerlink" title="使用单独的中断安全 API 的缺点"></a>使用单独的中断安全 API 的缺点</h3><p>拥有两个版本的一些 API 函数可以提高任务和 ISR 的效率，但会带来新的问题；有时需要从任务和 ISR 调用不属于 FreeRTOS API 的函数，但使用 FreeRTOS API。</p><p>这通常只是集成第三方代码时的问题，因为这是软件设计不受应用程序编写者控制的唯一时候。 如果这确实成为一个问题，那么可以使用以下技术之一来克服该问题：</p><ol><li><p>将中断处理延迟到任务，因此只从任务的上下文中调用 API 函数。</p><blockquote><p>本书的下一节将介绍延迟中断处理。</p></blockquote></li><li><p>如果您使用的是支持中断嵌套的 FreeRTOS 移植，则使用以 “<code>FromISR</code>” 结尾的 API 函数版本，因为该版本可以从任务和 ISR 中调用（反之则不然，不以 “<code>FromISR</code>” 结尾的 API 函数不能从 ISR 调用）。</p></li><li><p>第三方代码通常包括一个 RTOS 抽象层，可以实现该抽象层来测试调用函数的上下文 (任务或中断) ，然后调用适合该上下文的 API 函数。</p></li></ol><h3 id="xHigherPriorityTaskWoken-参数"><a href="#xHigherPriorityTaskWoken-参数" class="headerlink" title="xHigherPriorityTaskWoken 参数"></a>xHigherPriorityTaskWoken 参数</h3><p>本节介绍了 <code>xHigherPriorityTaskWoken</code> 参数的概念。 如果您还没有完全理解本节，请不要担心，因为后续章节提供了实际示例。</p><p>如果上下文切换是由中断执行的，那么中断退出时运行的任务可能与进入中断时运行的任务不同——中断将中断一个任务，但返回到另一个任务。</p><p>一些 FreeRTOS API 函数可以将任务从阻塞状态移动到就绪状态。 这已经在诸如 <code>xQueueSendToBack()</code> 之类的函数中看到了，如果有一个任务在阻塞状态等待数据在主题队列上可用，它将解除对任务的阻塞。</p><p>如果被 FreeRTOS API 函数解除阻塞的任务的优先级高于处于运行状态下的任务的优先级，那么根据 FreeRTOS 调度策略，应该切换到更高优先级的任务。 实际切换到更高优先级任务的时间取决于调用 API 函数的上下文：</p><ul><li><p>如果从任务中调用 API 函数</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PREEMPTION</code> 设置为 1，那么在 API 函数中会自动切换到更高优先级的任务——所以在 API 函数退出之前。 这已经在图 43 中看到，其中写入定时器命令队列导致在写入命令队列的函数退出之前切换到 RTOS 守护任务。</p></li><li><p>如果从中断调用 API 函数</p><p>中断内不会自动切换到更高优先级的任务。 相反，设置了一个变量来通知应用程序编写者应该执行上下文切换。 中断安全 API 函数（以 “<code>FromISR</code>” 结尾的函数）有一个名为 <code>pxHigherPriorityTaskWoken</code> 的指针参数，用于此目的。</p><p>如果应该执行上下文切换，则中断安全 API 函数会将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。 为了能够检测到这种情况，<code>pxHigherPriorityTaskWoken</code> 指向的变量在第一次使用之前必须初始化为 <code>pdFALSE</code>。</p><p>如果应用程序编写者选择不从 ISR 请求上下文切换，则更高优先级的任务将保持就绪状态，直到调度程序下次运行——在最坏的情况下将在下一次滴答中断期间。</p><p>FreeRTOS API 函数只能将 <code>*pxHighPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。 如果一个 ISR 调用了多个 FreeRTOS API 函数，那么可以在每个 API 函数调用将同一个的变量作为 <code>pxHigherPriorityTaskWoken</code> 参数传递，并且只需要在第一次使用该变量之前初始化为 <code>pdFALSE</code>。</p></li></ul><p>上下文切换不会在 API 函数的中断安全版本中自动发生的原因有几个:</p><ol><li><p>避免不必要的上下文切换</p><p>在任务需要执行任何处理之前，中断可能会执行多次。 例如，考虑一个任务处理一个由中断驱动的 <code>UART</code> 接收到的字符串的场景； 每次接收到一个字符时，<code>UART ISR</code> 都切换到任务是一种浪费，因为任务只有在接收到完整字符串后才能执行。</p></li><li><p>控制执行顺序</p><p>中断可能偶尔发生，而且发生的时间不可预测。 专业的 FreeRTOS 用户可能希望暂时避免在其应用程序中的特定点不可预测地切换到不同的任务——尽管这也可以使用 FreeRTOS 调度程序锁定机制来实现。</p></li><li><p>可移植性</p><p>这是可以在所有FreeRTOS移植上使用的最简单的机制。</p></li><li><p>效率</p><p>面向较小处理器架构的移植仅允许在 ISR 的最后请求上下文切换，而消除该限制将需要额外且更复杂的代码。 它还允许在同一 ISR 内多次调用 FreeRTOS API 函数，而不会在同一 ISR 内生成多个上下文切换请求。</p></li><li><p>在 RTOS 滴答定时中断执行</p><p>正如本书后面将看到的，可以将应用程序代码添加到 RTOS 滴答中断中。 尝试在滴答中断内进行上下文切换的结果取决于正在使用的 FreeRTOS 移植。在最好的情况下，它只会导致不必要的调度程序调用。</p></li></ol><p> <code>pxHigherPriorityTaskWoken</code> 参数的使用是可选的。 如果不需要，则将 <code>pxHigherPriorityTaskWoken</code> 设置为 <code>NULL</code>。</p><h3 id="portYIELD-FROM-ISR-和-portEND-SWITCHING-ISR-宏"><a href="#portYIELD-FROM-ISR-和-portEND-SWITCHING-ISR-宏" class="headerlink" title="portYIELD_FROM_ISR() 和 portEND_SWITCHING_ISR() 宏"></a>portYIELD_FROM_ISR() 和 portEND_SWITCHING_ISR() 宏</h3><p>本节介绍用于从 ISR 请求上下文切换的宏。 如果您尚未完全理解本节，请不要担心，因为后续章节提供了实际示例。</p><p><code>taskYIELD()</code> 是一个宏，可以在任务中调用以请求上下文切换。 <code>portYIELD_FROM_ISR()</code> 和 <code>portEND_SWITCHING_ISR()</code> 都是 <code>taskYIELD()</code> 的中断安全版本。 <code>portYIELD_FROM_ISR()</code> 和 <code>portEND_SWITCHING_ISR()</code> 都以同样的方式使用，并且做同样的事情[1]。 某些 FreeRTOS 移植仅提供两个宏之一。 较新的 FreeRTOS 移植提供这两种宏。本书中的示例使用 <code>portYIELD_FROM_ISR()</code>。</p><blockquote><p>[1] : 从历史上看，portEND_SWITCHING_ISR() 是要求中断处理程序使用汇编代码包装器的 FreeRTOS 移植中使用的名称，而 portYIELD_FROM_ISR() 是允许整个中断处理程序用 C 编写的 FreeRTOS 移植中使用的名称。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token function">portEND_SWITCHING_ISR</span><span class="token punctuation">(</span> xHigherPriorityTaskWoken <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 87. <code>portEND_SWITCHING_ISR()</code> 宏</p><pre class=" language-c"><code class="language-c"><span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span> xHigherPriorityTaskWoken <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 88. <code>portYIELD_FROM_ISR()</code> 宏</p><p>从中断安全 API 函数传出的 <code>xHigherPriorityTaskWoken</code> 参数可以直接用作 <code>portYIELD_FROM_ISR()</code> 调用中的参数。</p><p>如果 <code>portYIELD_FROM_ISR()</code> <code>xHigherPriorityTaskWoken</code> 参数是 <code>pdFALSE(0)</code>，则不请求上下文切换，并且宏不起作用。 如果 <code>portYIELD_FROM_ISR()</code> <code>xHigherPriorityTaskWoken</code> 参数不是 <code>pdFALSE</code>，则请求上下文切换，并且处于运行状态的任务可能会更改。 中断将始终返回到处于运行状态的任务，即使在中断执行期间处于运行状态的任务发生了变化。</p><p>大多数 FreeRTOS 移植允许在 ISR 内的任何位置调用 <code>portYIELD_FROM_ISR()</code>。 一些 FreeRTOS 移植（主要用于较小的架构）仅允许在 ISR 的最后调用 <code>portYIELD_FROM_ISR()</code>。</p><h2 id="延迟中断处理"><a href="#延迟中断处理" class="headerlink" title="延迟中断处理"></a>延迟中断处理</h2><p>通常认为最佳实践是使 ISR 尽可能短。 其原因包括：</p><ul><li>即使已经为任务分配了非常高的优先级，它们也仅在硬件没有服务中断时运行。</li><li>ISR 可以中断（添加“抖动”）任务的开始时间和执行时间。</li><li>根据运行 FreeRTOS 的架构，在执行 ISR 时可能无法接受任何新中断，或至少无法接受新中断的子集。</li><li>应用程序编写者需要考虑并防范任务和 ISR 同时访问变量、外设和内存缓冲区等资源的后果。</li><li>一些 FreeRTOS 移植允许中断嵌套，但中断嵌套会增加复杂性并降低可预测性。中断越短，嵌套的可能性就越小。</li></ul><p>中断服务程序必须记录中断的原因，并清除中断。 中断所需的任何其他处理通常可以在任务中执行，从而允许中断服务程序尽可能快地退出。这称为 <code>"延迟中断处理"</code>，因为中断所需的处理被从 ISR “延迟” 到任务。</p><p>将中断处理延迟到任务还允许应用程序编写者相对于应用程序中的其他任务确定处理的优先级，并使用所有 FreeRTOS API 函数。</p><p>如果中断处理延迟到的任务的优先级高于任何其他任务的优先级，则处理将立即执行，就像在 ISR 本身中执行处理一样。 这种情况如图 48 所示，其中任务 1 是一个正常的应用程序任务，任务 2 是中断处理被延迟到的任务。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240401105637107.png" alt="图 48 在高优先级任务中完成中断处理"></p><p>在图 48 中，中断处理从 t2 时刻开始，实际上在 t4 时刻有效地结束，但只有 t2 和 t3 时刻之间的时间段用于 ISR。 如果未使用延迟中断处理，则时间 t2 和 t4 之间的整个时间段都将花费在 ISR 中。</p><p>对于何时最好执行 ISR 中的中断所需的所有处理，以及何时最好将部分处理延迟到任务，没有绝对的规则。在以下情况下，将处理延迟到任务最有用 :</p><ul><li>中断所必需的处理不是微不足道的。 例如，如果中断只是存储模数转换的结果，那么几乎可以肯定这最好在 ISR 内部执行，但如果转换结果还必须通过软件过滤器，那么可能最好是在任务中执行过滤器。</li><li>中断处理可以方便地执行无法在 ISR 内部执行的操作，例如写入控制台或分配内存。</li><li>中断处理不是确定性的——这意味着事先不知道处理将要花费多长时间。</li></ul><p>以下各节描述并演示了本章到目前为止介绍的概念，包括可用于实现延迟中断处理的 FreeRTOS 功能。</p><h2 id="用于同步的二进制信号量"><a href="#用于同步的二进制信号量" class="headerlink" title="用于同步的二进制信号量"></a>用于同步的二进制信号量</h2><p>二进制信号量 API 的中断安全版本可以用于在每次特定中断发生时解除任务阻塞，从而有效地将任务与中断同步。这允许大部分中断事件处理在同步任务中实现，只有非常快和短的部分直接留在ISR中。如前一节所述，二进制信号量用于将中断处理 “延迟” 到任务[1]。</p><blockquote><p>[1] 任务：使用直接到任务的通知将一个任务从中断中解禁，比使用二进制信号量更有效率。直接到任务的通知在第9章 “任务通知 “中才会涉及。</p></blockquote><p>正如之前在图 48 中所展示的，如果中断处理是特别时间关键的，则可以设置延迟处理任务的优先级，以确保该任务总是抢占系统中的其他任务。然后可以实现 ISR 以包含对 <code>portYIELD_FROM_ISR()</code> 的调用，确保 ISR 直接返回到中断处理被延迟到的任务。这样做的效果是确保整个事件处理在在时间上连续执行 ( 没有中断 )，就好像它全部在ISR本身内实现一样。图 49 重复了图 48 中的场景，但是更新了文本以描述如何使用信号量来控制延迟处理任务的执行。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240401132340213.png" alt="图 49 使用二进制信号量实现延迟中断处理"></p><p>延迟处理任务使用对信号量的阻塞 <code>"take"</code> 调用作为进入阻塞状态以等待事件发生的方法。当事件发生时，ISR 对同一信号量使用 <code>"give" </code> 操作来解锁任务，以便继续进行所需的事件处理。</p><p><code>"Taking a semaphore (获取信号量)"</code> 和 <code>"giving a semaphore (给出信号量)"</code> 是根据其使用场景具有不同含义的概念。在这种中断同步场景中，二进制信号量在概念上可以被视为长度为 1 的队列。队列在任何时候最多可以包含一项，因此始终要么为空，要么为满（因此是二进制）。通过调用 <code>xSemaphoreTake()</code>，中断处理被延迟到的任务有效地试图用一个阻塞时间从队列中读取数据，从而导致任务在队列为空时进入阻塞状态。当事件发生时，ISR 使用 <code>xSemaphoreGiveFromISR()</code> 函数将一个令牌（信号量）放入队列中，使队列变满。这将导致任务退出阻塞状态并移除令牌，使队列再次为空。当任务完成其处理后，它会再次尝试从队列中读取，并发现队列为空，然后重新进入阻塞状态以等待下一个事件。图 50 演示了这个序列。</p><p>图 50 显示了中断 <code>"giving (给出)"</code> 信号量，即使它没有首先 <code>"taking (获取)"</code> 信号量，以及任务 <code>"taking (获取)"</code> 信号量，但从未将其给出 (giving it back)。这就是为什么该场景被描述为在概念上类似于向队列写入和从队列读取的原因。它经常会引起混乱，因为它不遵循与其他信号量使用场景相同的规则，在其他信号量使用场景中，获取 (takes) 信号量的任务必须始终将其给出 (give it back)，例如第 7 章 “资源管理” 中描述的场景。</p><img src="Chapter 6 中断管理/image-20240401141329400.png" alt="图 50 使用二进制信号量使任务与中断同步" style="zoom:67%;"><h3 id="xSemaphoreCreateBinary-API函数"><a href="#xSemaphoreCreateBinary-API函数" class="headerlink" title="xSemaphoreCreateBinary() API函数"></a>xSemaphoreCreateBinary() API函数</h3><p>FreeRTOS V9.0.0 还包括 <code>xSemaphoreCreateBinaryStatic()</code> 函数，该函数在编译时静态地分配创建二进制信号量所需的内存 : 所有各种类型的 FreeRTOS 信号量的句柄都存储在 <code>SemaphoreHandle_t</code> 类型的变量中。</p><p>在使用信号量之前，必须先创建它。要创建一个二进制信号量，请使用 <code>xSemaphoreCreateBinary()</code> API 函数 [1]。</p><blockquote><p>[1] : 一些信号量 API 函数实际上是宏，而不是函数。为简单起见，在本书中，它们都被称为函数。</p></blockquote><pre class=" language-c"><code class="language-c">SemaphoreHandle_t <span class="token function">xSemaphoreCreateBinary</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 89. <code>xSemaphoreCreateBinary()</code> API 函数原型</p><p>表 33. <code>xSemaphoreCreateBinary()</code> 的返回值</p><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>如果返回的是 <code>NULL</code>，则无法创建信号量，因为没有足够的堆内存可供FreeRTOS分配给信号量数据结构。<br>如果返回的值不是<code>NULL</code>，则表明该信号已被成功创建。返回值应存储为创建的信号量的句柄。</td></tr></tbody></table><h3 id="xSemaphoreTake-API函数"><a href="#xSemaphoreTake-API函数" class="headerlink" title="xSemaphoreTake() API函数"></a>xSemaphoreTake() API函数</h3><p> <code>"Taking (获取)"</code> 信号量意味着 <code>"obtain (获得)"</code> 或 <code>receive (接收)</code> 信号量。仅当信号量可用时才可以获取该信号量。</p><p>所有不同类型的 FreeRTOS 信号量，除了递归互斥锁，都可以使用 <code>xSemaphoreTake()</code> 函数。</p><p><code>xSemaphoreTake()</code> 不能从一个中断服务例程中使用。</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span> SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 90. <code>xSemaphoreTake()</code> 的 API 函数原型</p><p>表 34. <code>xSemaphoreTake()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>被 <code>"taking (获取)"</code> 的信号量。<br>信号量由 <code>SemaphoreHandle_t</code> 类型的变量引用。必须先显式创建它，然后才能使用它。</td></tr><tr><td><code>xTicksToWait</code></td><td>如果信号量尚不可用，任务应保持在阻塞状态以等待信号量的最长时间。<br>如果<code>xTicksToWait</code> 为 0，那么如果信号量不可用，<code>xSemaphoreTake()</code> 将立即返回。<br>阻塞时间是以滴答周期指定的，因此它表示的绝对时间取决于滴答频率。宏pdMS_TO_TICKS() 可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。<br>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>INCLUDE_vTaskSuspend</code> 设置为 1，则将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致任务无限期等待 ( 没有超时期限 )。</td></tr><tr><td>返回值</td><td>有两个可能的返回值：<br>1. <code>pdPASS</code><br>仅当调用 <code>xSemaphoreTake()</code> 成功获取信号量时才返回 <code>pdPASS</code>。<br>如果指定了阻塞时间（<code>xTicksToWait</code> 不是 0 ），则调用任务可能被置于阻塞状态以等待信号量 (如果信号量不是立即可用)，但信号量在阻止时间到期之前变为可用。<br>2. <code>pdFALSE</code><br>信号量不可用。<br>如果指定了阻塞时间（<code>xTicksToWait</code> 不是0），则调用任务将被置于阻塞状态以等待信号量变为可用，但阻塞时间在此之前已过期。<p></p></td></tr></tbody></table><h3 id="xSemaphoreGiveFromISR-API函数"><a href="#xSemaphoreGiveFromISR-API函数" class="headerlink" title="xSemaphoreGiveFromISR() API函数"></a>xSemaphoreGiveFromISR() API函数</h3><p>可以使用<code>xSemaphoreGiveFromISR()</code>函数 <code>"giving (给出)"</code> 二进制和计数信号量。</p><blockquote><p>计数信号量将在本书后面的章节中介绍。</p></blockquote><p><code>xSemaphoreGiveFromISR()</code> 是 <code>xSemaphoreGive()</code> 的中断安全版本，所以具有 <code>pxHigherPriorityTaskWoken</code> 参数，这在本章开始时已经描述过。</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span> SemaphoreHandle_t xSemaphore<span class="token punctuation">,</span>                                  BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单91. <code>xSemaphoreGiveFromISR()</code> API 函数原型</p><p>表35. <code>xSemaphoreGiveFromISR()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>将要被 <code>"给出"</code> 的信号量。<br>一个信号量是由一个类型为 <code>SemaphoreHandle_t</code> 的变量来引用的，并且必须在使用前显式创建。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td>单个信号量可能会阻塞一个或多个任务，等待信号量可用。调用 <code>xSemaphoreGiveFromISR()</code> 可以使信号量可用，从而使等待信号量的任务离开阻塞状态。如果调用 <code>xSemaphoreGiveFromISR()</code> 导致一个任务离开阻塞状态，并且未阻塞任务的优先级高于当前正在执行的任务 (被中断的任务)，那么，在内部，<code>xSemaphoreGiveFromISR()</code> 将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。<br>如果 <code>xSemaphoreGiveFromISR()</code> 把这个值设置为  <code>pdTRUE</code>。则通常应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级就绪状态任务。</td></tr><tr><td>返回值</td><td>有两个可能的返回值：<br>1. <code>pdPASS</code><br>只有当对 <code>xSemaphoreGiveFromISR()</code> 的调用成功时，才会返回 <code>pdPASS</code>。<br>2. <code>pdFAIL</code><br>如果信号量已经可用，则不能被 <code>"给出"</code>，并且 <code>xSemaphoreGiveFromISR()</code> 将返回 <code>pdFAIL</code>。<p></p></td></tr></tbody></table><h3 id="示例-16-使用二进制信号量使一个任务与中断同步"><a href="#示例-16-使用二进制信号量使一个任务与中断同步" class="headerlink" title="示例 16. 使用二进制信号量使一个任务与中断同步"></a>示例 16. 使用二进制信号量使一个任务与中断同步</h3><p>此示例使用二进制信号量从中断服务例程中取消阻阻塞任务 — 有效地将任务与中断同步。</p><p>一个简单的周期性任务被用来每 500 毫秒产生一次软件中断。一个软件中断是为了方便而使用的，由于在某些目标环境中挂钩到真实中断的复杂性，因此使用软件中断是为了方便。清单 92 显示了周期性任务的实现。请注意，该任务在生成中断之前和之后都打印出一个字符串。这允许在执行示例时产生的输出中观察执行顺序。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 本例中使用的软件中断的编号。显示的代码来自 Windows 工程，其中数字0到2是由 FreeRTOS Windows 移植本身使用的，所以 3 是应用程序可用的第一个数字。*/</span><span class="token macro property">#<span class="token directive keyword">define</span> mainINTERRUPT_NUMBER 3</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vPeriodicTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> TickType_t xDelay500ms <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">500UL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 和大多数任务一样，这个任务是在一个无限循环中实现的。*/</span>         <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>         <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">/* 阻塞直到再次产生软件中断。*/</span>              <span class="token function">vTaskDelay</span><span class="token punctuation">(</span> xDelay500ms <span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 生成中断，在中断产生前后打印信息。这样就可以从输出中看出执行的顺序。             用于生成软件中断的语法取决于所使用的 FreeRTOS 移植。下面使用的语法只能用于             FreeRTOS Windows 移植，在该移植中，这种中断只是模拟的。*/</span>              <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Periodic task - About to generate an interrupt.\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">vPortGenerateSimulatedInterrupt</span><span class="token punctuation">(</span> mainINTERRUPT_NUMBER <span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Periodic task - Interrupt generated.\r\n\r\n\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>清单 92. 示例 16 中周期性生成软件中断的任务的实现</p><p>清单 93 显示了中断处理被延迟到的任务的实现 —— 通过使用二进制信号量与软件中断同步的任务。同样，在任务的每次迭代中都会打印出一个字符串，因此从执行示例时产生的输出中可以明显看出任务和中断执行的顺序。</p><p>需要注意的是，虽然清单 93 中所示的代码足够满足由软件生成中断的示例 16 ，但它不足以满足由硬件外设生成中断的场景。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vHandlerTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 和大多数任务一样，这个任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 使用信号量来等待事件。信号量是在调度程序启动之前创建的，        因此在此任务第一次运行之前。任务无限期地阻塞，        这意味着这个函数调用只会在成功获得信号量后返回——        所以不需要检查 xSemaphoreTake() 返回的值。*/</span>        <span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span>xBinarySemaphore<span class="token punctuation">,</span> portMAX_DELAY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 要到达这里，这个事件必须已经发生。处理该事件 (在本例中，只是打印出一条信息)。 */</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span><span class="token string">"Handler task - Processing event.\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 93. 示例 16 中延迟中断处理的任务 (与中断同步的任务) 的实现。</p><p>清单 94 显示了 ISR 。除了 <code>"给出"</code> 信号量以取消阻塞中断处理被延迟到的任务之外，几乎没有什么作用。</p><p>注意 <code>xHigherPriorityTaskWoken</code> 变量是如何被使用的。在调用 <code>xSemaphoreGiveFromISR()</code> 之前，它被设置为 <code>pdFALSE</code> ，然后在调用 <code>portYIELD_FROM_ISR()</code> 时作为参数使用。如果 <code>xHigherPriorityTaskWoken</code> 等于 <code>pdTRUE</code>，则将在 <code>portYIELD_FROM_ISR()</code> 宏请求上下文切换。</p><p>ISR 的原型和用于强制上下文切换的宏，对于FreeRTOS Windows 移植都是正确的，对于其他 FreeRTOS 移植可能有所不同。请参阅 <a href="http://www.example.com/">www.example.com</a> 网站上的移植特定文档页面，以及 FreeRTOS 下载中提供的示例，以查找您正在使用的移植所需的语法。</p><p>与运行 FreeRTOS 的大多数架构不同，FreeRTOS 的 Windows 移植需要一个 ISR 来返回一个值。与 Windows 移植一起提供的 <code>portYIELD_FROM_ISR()</code> 宏的实现包括 return 语句，因此清单 94 没有显示显式返回的值。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> uint32_t <span class="token function">ulExampleInterruptHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BaseType_t xHigherPriorityTaskWoken<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xHigherPriorityTaskWoken参数必须被初始化为pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为 pdTRUE。 */</span>    xHigherPriorityTaskWoken <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* “给出” semaphore以解除对任务的阻塞，将 xHigherPriorityTaskWoken     的地址作为中断安全API函数的参数 pxHigherPriorityTaskWoken 传入。 */</span>    <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span>xBinarySemaphore<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将 xHigherPriorityTaskWoken 的值传给 portYIELD_FROM_ISR()。  如果 xHigherPriorityTaskWoken 在 xSemaphoreGiveFromISR() 中被设置为 pdTRUE，  那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。  如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，  那么调用 portYIELD_FROM_ISR() 将没有任何影响。  与大多数 FreeRTOS 移植不同， Windows 移植要求 ISR 返回一个值 ——  return 语句在 Windows 版本的 portYIELD_FROM_ISR() 中。*/</span>    <span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 94. 示例 16 中使用的软件中断的 ISR</p><p><code>main() </code> 函数创建二进制信号量，创建任务，安装中断处理 ( interrupt handler ) 程序。并启动调度程序。实现如清单 95 所示。</p><p>为安装中断处理程序而调用的函数的语法特定于 FreeRTOS Windows 移植，对于其他 FreeRTOS 移植可能有所不同。请参考 FreeRTOS.org 网站上的特定移植文档页面，以及 FreeRTOS 下载中提供的示例，以找到你正在使用的移植所需的语法。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 在使用 semaphore 之前，必须显示地创建它。在这个例子中，我们创建了一个 binary semaphore。 */</span>    xBinarySemaphore <span class="token operator">=</span> <span class="token function">xSemaphoreCreateBinary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 检查 semaphore 是否成功创建。*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xBinarySemaphore <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 创建 "处理(handler)"任务，该任务是中断处理被延迟到的任务。        这是将与中断同步的任务。处理任务是以高优先级创建的，        以确保它在中断退出后立即运行。        在这种情况下，我们选择了优先级 3 。 */</span>        <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>vHandlerTask<span class="token punctuation">,</span> <span class="token string">"Handler"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 创建将定期生成软件中断的任务。这个任务的优先级低于处理任务，        以确保每次处理任务退出阻塞状态时它将被抢占。 */</span>        <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>vPeriodicTask<span class="token punctuation">,</span> <span class="token string">"Periodic"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 安装软件中断的处理程序。这样做所需的语法取决于正在使用的FreeRTOS移植。        这里显示的语法只能用于 FreeRTOS windows 移植，在那里这种中断只是模拟的。 */</span>        <span class="token function">vPortSetInterruptHandler</span><span class="token punctuation">(</span>mainINTERRUPT_NUMBER<span class="token punctuation">,</span> ulExampleInterruptHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 启动调度器，使创建的任务开始执行。 */</span>        <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 正常情况下，绝对不能达到下面这一行。 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 95. 示例 16 中 <code>main()</code> 的实现</p><p>示例 16 产生的输出如图 51 所示。正如预期的那样，<code>vHandlerTask()</code> 在中断产生后立即进入了运行状态，因此任务的输出会拆分周期性任务产生的输出。在图52中提供了进一步的解释。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240408200251795.png" alt="图 51. 执行示例 16 时产生的输出"></p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240408200543993.png" alt="图 52. 执行例 16 时的执行顺序"></p><h3 id="改进示例16中使用的任务的实现"><a href="#改进示例16中使用的任务的实现" class="headerlink" title="改进示例16中使用的任务的实现"></a>改进示例16中使用的任务的实现</h3><p>示例 16 使用一个二进制信号量来同步一个任务和一个中断。其执行顺序如下：</p><ol><li>中断发生了。</li><li>ISR 执行并 <code>"给出"</code> 信号量以解除对任务的阻塞。</li><li>任务在 ISR 之后立即执行，并 <code>"获取"</code> 了信号量。</li><li>任务处理了该事件，然后试图再次 <code>"获取"</code> 信号量——进入阻塞状态，因为信号量还不可用（另一个中断还没有发生）。</li></ol><p>示例 16 中使用的任务的结构仅在中断以相对低的频率发生时是适当的。要理解其中的原因，我们可以考虑一下，如果在任务完成对第一个中断的处理之前，又发生了第二个、第三个中断，会发生什么：</p><ul><li>当第二个 ISR 执行时，信号量将为空，所以 ISR 将 <code>"给出"</code> 信号量，并且任务将在完成处理第一个事件之后立即处理第二个事件。该场景如图 53 所示。</li><li>当第三个 ISR 执行时，信号量已经可用，防止ISR再次给出信号量，所以任务不会知道第三个事件已经发生。这种情况在图54中显示。</li></ul><img src="Chapter 6 中断管理/image-20240408204641581.png" alt="图 53. 在任务处理完第一个事件之前发生一个中断时的情景" style="zoom:67%;"><img src="Chapter 6 中断管理/image-20240408205305113.png" alt="图 54. 在任务处理完第一个事件之前发生两个中断时的情景" style="zoom:67%;"><p>示例 16 中使用的延迟中断处理任务（如清单 93 所示）被构建为在每次调用 <code>xSemaphoreTake()</code> 之间仅处理一个事件。这对于示例 16 来说已经足够了，因为生成事件的中断是由软件触发的，并且发生在可预测的时间。在实际应用中，中断是由硬件产生的，并且发生的时间是不可预测的。因此，为了最大限度地减少错过中断的机会，必须构建延迟中断处理任务，以便它处理每次调用 <code>xSemaphoreTake()</code> 之间已经可用的所有事件 [1]。清单 96 对此进行了演示，其中展示了如何构建 UART 的延迟中断处理程序。在清单 96 中，假设 UART 在每次接收到字符时生成接收中断，并且 UART 将接收到的字符放入硬件 FIFO ( 硬件缓冲区 ) 中。</p><blockquote><p> [1] 事件：或者，也可以使用计数信号量或直接到任务的通知来对事件进行计数。计数信号量将在下一节中描述。第 9 章 “任务通知” 中描述了直接到任务的通知。直接到任务的通知是首选方法，因为它们在运行时间和 RAM 使用方面都是最有效率的。</p></blockquote><p>示例 16 中使用的延迟中断处理任务还有一个弱点；它在调用 <code>xSemaphoreTake()</code> 时没有使用超时。相反，该任务将 <code>portMAX_DELAY</code> 作为 <code>xSemaphoreTake()</code> 的 <code>xTicksToWait</code> 参数传递，这会导致任务无限期地等待 ( 没有超时期限 ) 信号量可用。无限期超时经常被用在示例代码中，因为它们的使用简化了示例的结构，从而使示例更易于理解。然而，在实际应用中，无限期超时通常是不好的做法，因为它们使得从错误中恢复变得困难。例如，考虑这样的场景：任务正在等待中断以提供信号量，但硬件中的错误状态阻止中断产生 ：</p><ul><li>如果任务在没有超时的情况下等待，它将不知道错误状态，并将永远等待。</li><li>如果任务在等待时有超时，则 <code>xSemaphoreTake()</code>  将在超时到期时返回 <code>pdFAIL</code> ，然后任务可以在下次执行时检测并清除错误。清单 96 也演示了这个场景。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vUARTReceiveHandlerTask</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* xMaxExpectedBlockTime 保存两个中断之间预期的最大时间。 */</span>    <span class="token keyword">const</span> TickType_t xMaxExpectedBlockTime <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 和大多数任务一样，这个任务是在一个无限循环中实现的。 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* semaphore 由 UART 的接收(Rx)中断 "给出"。        等待下一个中断的时间最多为 xMaxExpectedBlockTime 个滴答。*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">xSemaphoreTake</span><span class="token punctuation">(</span>xBinarySemaphore<span class="token punctuation">,</span> xMaxExpectedBlockTime<span class="token punctuation">)</span> <span class="token operator">==</span> pdPASS<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 获得了 semaphore 。在再次调用 xSemaphoreTake() 之前，            处理所有挂起的 Rx 事件。每个 Rx 事件都会在UART 的接收FIFO中放置一个字符，            并且假定 UART_RxCount() 返回 FIFO 中的字符数。*/</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">UART_RxCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/* 假设 UART_ProcessNextRxEvent() 处理一个Rx字符，                将 FIFO 中的字符数减少 1 。 */</span>                <span class="token function">UART_ProcessNextRxEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/* 没有更多挂起的 Rx 事件(FIFO 中没有更多的字符)，            所以循环返回并调用 xSemaphoreTake() 以等待下一个中断。            在代码的这一点与调用 xSemaphoreTake() 之间发生的任何中断            都将被锁在 semaphore 中，所以不会丢失。 */</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 在预期时间内未收到事件。检查并在必要时清除 UART 中            可能阻止 UART 生成更多中断的任何错误条件。 */</span>            <span class="token function">UART_ClearErrors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 96. 推荐的延迟中断处理任务的构建，以 UART 接收处理程序为例</p><h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p>正如二进制信号量可以被认为是长度为 1 的队列一样，计数信号量可以被认为是长度大于 1 的队列。任务对存储在队列中的数据不感兴趣，只对队列中的项目数量感兴趣。<code>FreeRTOSConfig.h</code> 中的 <code>configUSE_COUNTING_SEMAPHORES</code>必须设置为 1 ，以使计数信号量可用 。</p><p>每次 <code>"给出"</code> 计数信号量时，都会使用其队列中的另一个空间。队列中的项目数是信号量的 <code>"计数(count)"</code> 值。</p><ol><li><p>计数事件 [1]</p><p>在这种情况下，事件处理程序将在每次事件发生时 <code>"给出"</code> 一个信号量，从而导致信号量的计数值在每次 <code>"给出"</code> 时递增。任务每次处理事件时都会 <code>"获取"</code> 一个信号量，从而导致信号量的计数值在每次  <code>"获取"</code>  时递减。计数值是已发生的事件数与已处理的事件数之间的差值。该机制如图 55 所示。</p><p>创建用于对事件进行计数的计数信号量时，其初始计数值为 0 。</p></li></ol><blockquote><p>[1] 使用直接到任务的通知来计数事件比使用计数信号量更有效。 直到第 9 章才介绍直接到任务的通知。</p></blockquote><ol><li><p>资源管理</p><p>在这种情况下，计数值指示可用资源的数量。为了获得对资源的控制，任务必须首先获得信号量——减少信号量的计数值。当计数值达到 0 时，表示没有空闲资源。当任务完成资源使用时，它会归还信号量——增加信号量的计数值。</p><p>创建用于管理资源的计数信号量，使其初始计数值等于可用资源的数量。第 7 章介绍了如何使用信号量管理资源。</p></li></ol><img src="Chapter 6 中断管理/image-20240409011504838.png" alt="图 55. 使用一个计数信号量来 '计数' 事件" style="zoom:67%;"><h3 id="xSemaphoreCreateCounting-API函数"><a href="#xSemaphoreCreateCounting-API函数" class="headerlink" title="xSemaphoreCreateCounting() API函数"></a>xSemaphoreCreateCounting() API函数</h3><p>FreeRTOS V9.0.0还包括 <code>xSemaphoreCreateCountingStatic()</code> 函数，该函数在编译时静态地分配创建计数信号量所需的内存 : 所有不同类型的 FreeRTOS 信号量的句柄都存储在 <code>SemaphoreHandle_t</code> 类型的变量中。</p><p>在使用信号量之前，必须先创建它。要创建一个计数信号量，请使用 <code>xSemaphoreCreateCounting()</code> API 函数。</p><pre class=" language-c"><code class="language-c">SemaphoreHandle_t <span class="token function">xSemaphoreCreateCounting</span><span class="token punctuation">(</span> UBaseType_t uxMaxCount<span class="token punctuation">,</span>                                            UBaseType_t uxInitialCount <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单97. <code>xSemaphoreCreateCounting()</code> API 函数原型</p><p>表36. <code>xSemaphoreCreateCounting()</code> 的参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>uxMaxCount</code></td><td>信号量将计数到的最大值。继续用队列来比喻，<code>uxMaxCount</code> 值实际上就是队列的长度。<br>当信号量用于计数或锁存事件时，<code>uxMaxCount</code> 是可以锁存的最大事件数。<br>当信号量用于管理对资源集合的访问时，<code>uxMaxCount</code> 应设置为可用资源的总数。</td></tr><tr><td><code>uxInitialCount</code></td><td>信号量创建后的初始计数值。<br>当信号量用于计数或锁存事件时，<code>uxInitialCount</code>应设置为 0 ——因为据推测，当创建信号量时，还没有事件发生。<br>当信号量用于管理对资源集合的访问时，<code>uxInitialCount</code> 应设置为等于 <code>uxMaxCount</code> ，因为据推测，当创建信号量时，所有的资源都是可用的。</td></tr><tr><td>返回值</td><td>如果返回 <code>NULL</code> ，则无法创建信号量，因为没有足够的堆内存可供 FreeRTOS 分配信号量的数据结构。第 2 章提供了更多关于堆内存管理的信息。<br>返回非 <code>NULL</code> 值表示已经成功创建了信号量。返回值应存储为创建的信号量的句柄。</td></tr></tbody></table><h3 id="例-17-使用计数信号量将任务与中断同步"><a href="#例-17-使用计数信号量将任务与中断同步" class="headerlink" title="例 17. 使用计数信号量将任务与中断同步"></a>例 17. 使用计数信号量将任务与中断同步</h3><p>示例 17 通过使用计数信号量代替二进制信号量来改进示例 16 的实现。<code>main()</code> 被修改为包含一个对 <code>xSemaphoreCreateCounting()</code> 的调用，以代替对 <code>xSemaphoreCreateBinary()</code> 的调用。新的 API 调用如清单 98 所示。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 在使用semaphore之前，必须显式创建它。在这个例子中，一个 counting semaphore 被创建。创建的 semaphore 的最大计数值为 10，初始计数值为0。 */</span>xCountingSemaphore <span class="token operator">=</span> <span class="token function">xSemaphoreCreateCounting</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 98. 示例 17 中用于创建计数信号量的 <code>xSemaphoreCreateCounting()</code> 调用</p><p>为了模拟高频率发生的多个事件，中断服务例程被改变为在每个中断中 <code>"给出"</code> 信号量不止一次。每个事件都被锁存在信号量的计数值中。修改后的中断服务例程如清单 99 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> uint32_t <span class="token function">ulExampleInterruptHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BaseType_t xHigherPriorityTaskWoken<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xHigherPriorityTaskWoken 参数必须被初始化为 pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为pdTRUE。 */</span>    xHigherPriorityTaskWoken <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 多次 "给出" semaphore 。第一次将解除对延迟的中断处理任务的阻塞，    接下来的 "给出 "是为了证明 semaphore 锁存事件，    以允许中断延迟到的任务依次处理它们，而不会丢失事件。    这模拟了处理器接收到的多个中断，即使在这种情况下，事件是在单个中断发生内模拟的。 */</span>    <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span>xCountingSemaphore<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span>xCountingSemaphore<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xSemaphoreGiveFromISR</span><span class="token punctuation">(</span>xCountingSemaphore<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 将 xHigherPriorityTaskWoken 的值传给portYIELD_FROM_ISR()。    如果 xHigherPriorityTaskWoken 在 xSemaphoreGiveFromISR() 中被设置为pdTRUE，    那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE ，    那么调用 portYIELD_FROM_ISR() 将没有任何影响。    与大多数 FreeRTOS 移植不同， Windows 移植要求 ISR 返回一个值——    return 语句在 Windows 版本的 portYIELD_FROM_ISR() 中。 */</span>    <span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 99. 示例 17 所使用的中断服务例程的实现</p><p>所有其他的函数与示例 16 中使用的函数相比都没有修改。</p><p>示例 17 执行时产生的输出如图 56 所示。可以看出，在每次产生中断时，中断处理被推迟到的任务会处理所有三个 [模拟] 事件。这些事件被锁存在信号的计数值中，允许任务依次处理它们。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240409130405568.png" alt="图 56. 执行示例 17 时产生的输出"></p><h2 id="延迟工作到-RTOS-守护进程任务"><a href="#延迟工作到-RTOS-守护进程任务" class="headerlink" title="延迟工作到 RTOS 守护进程任务"></a>延迟工作到 RTOS 守护进程任务</h2><p>到目前为止，所介绍的延迟中断处理的示例都要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。还可以使用 <code>xTimerPendFunctionCallFromISR()</code> [1] API 函数将中断处理延迟到 RTOS 守护进程任务 (daemon task) 中 —— 无需为每个中断创建一个单独的任务。将中断处理延迟到守护任务被称为 <code>"集中延迟中断处理"</code> 。</p><blockquote><p>[1] xTimerPendFunctionCallFromISR()：在第 5 章中指出，守护进程任务最初被称为定时器服务任务，因为它最初只用来执行软件定时器回调函数。因此，<code>xTimerPendFunctionCall()</code> 是在 <code>timers.c</code> 中实现的，并且根据以实现函数的文件的名称为前缀的惯例，函数的名称以 <code>"Timer"</code> 为前缀。</p></blockquote><p>第 5 章描述了与软件定时器相关的 FreeRTOS API 函数如何将命令发送到定时器命令队列上的守护进程任务。 <code>xTimerPendFunctionCall()</code>  和 <code>xTimerPendFunctionCallFromISR()</code> API 函数使用相同的定时器命令队列向守护进程任务发送 <code>"execute function (执行函数) "</code>命令。然后，发送到守护进程任务的函数在守护进程任务的上下文中被执行。</p><p>集中延迟中断处理的优点包括 ：</p><ul><li><p>较低的资源使用量</p><p>它消除了为每个延迟中断创建一个单独任务的需要。</p></li><li><p>简化的用户模型</p><p>延迟中断处理函数是标准 C 函数。</p></li></ul><p>集中式延时中断处理的缺点包括：</p><ul><li><p>灵活性较低</p><p>不可能单独设置每个延迟中断处理任务的优先级。每个延迟中断处理函数以守护进程任务的优先级执行。如第5章所述，守护进程任务的优先级由 <code>FreeRTOSConfig.h</code> 中的 <code>configTIMER_TASK_PRIORITY</code> 编译时配置常量设置。</p></li><li><p>较低的确定性</p><blockquote><p>英语原文是 Less determinism ，determinism —— 决定论（认为一切事物具有不以人的意志为转移的必然性）。结合下文， Less determinism 的意思应该是 : 当我们使用守护进程任务来延迟中断处理时，守护进程任务可能还同时用于处理软件定时器命令，这会导致中断处理的时间的确定性下降 ( 我猜的 )</p></blockquote><p><code>xTimerPendFunctionCallFromISR()</code> 将一个命令发送到定时器命令队列的尾部。在 <code>xTimerPendFunctionCallFromISR()</code> 将 <code>"execute function (执行函数)"</code> 命令发送到队列之前，守护进程任务将处理定时器命令队列中已有的命令。</p></li></ul><p>不同的中断有不同的时序约束，因此通常在同一应用程序中使用两种延迟中断处理的方法。</p><h3 id="xTimerPendFunctionCallFromISR-API-函数"><a href="#xTimerPendFunctionCallFromISR-API-函数" class="headerlink" title="xTimerPendFunctionCallFromISR() API 函数"></a>xTimerPendFunctionCallFromISR() API 函数</h3><p><code>xTimerPendFunctionCallFromISR()</code> 是 <code>xTimerPendFunctionCall()</code> 的中断安全版本。这两个 API 函数都允许由应用程序编写者提供的函数由 RTOS 守护进程任务执行，因此在 RTOS 守护进程任务的上下文中执行。要执行的函数以及函数输入参数的值都被发送到计时器命令队列上的守护进程任务。因此，该函数实际执行的时间取决于守护程序任务相对于应用程序中其他任务的优先级。</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerPendFunctionCallFromISR</span><span class="token punctuation">(</span> PendedFunction_t xFunctionToPend<span class="token punctuation">,</span>                                            <span class="token keyword">void</span> <span class="token operator">*</span>pvParameter1<span class="token punctuation">,</span>                                             uint32_t ulParameter2<span class="token punctuation">,</span>                                            BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 100.  <code>xTimerPendFunctionCallFromISR()</code> API 函数原型</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vPendableFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameter1<span class="token punctuation">,</span> uint32_t ulParameter2 <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单101. <code>xTimerPendFunctionCallFromISR()</code> 的 <code>xFunctionToPend</code> 参数中传递的函数必须符合的原型。</p><p>表37.  <code>xTimerPendFunctionCallFromISR()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xFunctionToPend</code></td><td>指向将在守护进程任务中执行的函数的指针 (实际上，就是函数名称 ) 。函数的原型必须与清单 101所示的相同。</td></tr><tr><td><code>pvParameter1</code></td><td>将被传递到由守护任务执行的函数中的值，作为该函数的 <code>pvParameter1</code> 参数。参数具有 void * 类型，以允许它用于传递任何数据类型。例如，整数类型可以直接转换为 void *，或者，void *可以用来指向一个结构。</td></tr><tr><td><code>ulParameter2</code></td><td>将被传递到由守护任务执行的函数中的值，作为该函数的 <code>ulParameter2</code> 参数。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td><code>xTimerPendFunctionCallFromISR()</code> 写入定时器命令队列。如果 RTOS 守护进程任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将使守护进程任务离开阻塞状态。如果守护进程任务的优先级高于当前正在执行的任务 ( 被中断的任务 ) 的优先级，那么在内部，<code>xTimerPendFunctionCallFromISR()</code> 将把 <code>*pxHigherPriorityTaskWoken</code> 设为 <code>pdTRUE</code>。<br>如果 <code>xTimerPendFunctionCallFromISR()</code> 将此值设置为 <code>pdTRUE</code>，那么在退出中断之前必须进行上下文切换。这将确保中断直接返回到守护进程任务，因为守护进程任务将是最高优先级的就绪状态任务。</td></tr><tr><td>返回值</td><td><p>有两个可能的返回值：<br>1. <code>pdPASS</code><br>如果 <code>"execute function"</code> 命令被写入定时器命令队列，则将返回 <code>pdPASS</code>。<br>2. <code>pdFAIL</code><br>如果由于定时器命令队列已满而无法将 <code>"execute function"</code> 命令写入定时器命令队列，则将返回 <code>pdFAIL</code>。第 5 章介绍了如何设置定时器命令队列的长度。</p></td></tr></tbody></table><h3 id="示例-18-集中的延迟中断处理"><a href="#示例-18-集中的延迟中断处理" class="headerlink" title="示例 18. 集中的延迟中断处理"></a>示例 18. 集中的延迟中断处理</h3><p>示例 18 提供了与示例 16 类似的功能，但没有使用信号量，并且不创建专门用于执行中断所必需的处理的任务。相反，该处理由 RTOS 守护进程任务执行。</p><p>示例 18 所使用的中断服务例程如清单 102 所示。它调用 <code>xTimerPendFunctionCallFromISR()</code>，将一个指向名为<code>vDeferredHandlingFunction()</code> 的函数的指针传递给守护进程任务。延迟的中断处理由 <code>vDeferredHandlingFunction()</code> 函数执行。</p><p>中断服务程序每次执行时都会增加一个名为 <code>ulParameterValue</code> 的变量。<code>ulParameterValue</code> 在对 <code>xTimerPendFunctionCallFromISR()</code> 的调用中被用作 <code>ulParameter2</code> 的值，因此当守护程序任务执行 <code>vDeferredHandlingFunction()</code> 时，也将在对 <code>vDeferredHandlingFunction()</code> 的调用中用作 <code>ulParameter2</code> 的值。在这个例子中没有使用。本例中未使用函数的另一个参数 <code>pvParameter1</code>。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> uint32_t <span class="token function">ulExampleInterruptHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> uint32_t ulParameterValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    BaseType_t xHigherPriorityTaskWoken<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* xHigherPriorityTaskWoken 参数必须被初始化为 pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为 pdTRUE。 */</span>    xHigherPriorityTaskWoken <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 将指向中断的延迟处理函数的指针发送到守护进程任务。    不使用延迟处理函数的 pvParameter1 参数，因此只需设置为 NULL。    延迟处理函数的ulParameter2参数用于传递一个数字，    这个数字在每次执行这个中断处理程序时都会递增 1 。 */</span>    <span class="token function">xTimerPendFunctionCallFromISR</span><span class="token punctuation">(</span>vDeferredHandlingFunction<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 要执行的函数。 */</span>                                  <span class="token constant">NULL</span><span class="token punctuation">,</span>                      <span class="token comment" spellcheck="true">/* 未使用。 */</span>                                  ulParameterValue<span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">/* 递增值。 */</span>                                  <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>    ulParameterValue<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 将xHigherPriorityTaskWoken 的值传给 portYIELD_FROM_ISR()。    如果 xHigherPriorityTaskWoken 在 xTimerPendFunctionCallFromISR() 中被设置为 pdTRUE，     那么调用 portYELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，     那么调用 portYIELD_FROM_ISR() 将没有任何影响。    与大多数 FreeRTOS 移植不同，Windows 移植要求 ISR 返回一个值——    返回语句在 Windows 版本的 portYIELD_FROM_ISR() 中。 */</span>    <span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单102. 示例18中使用的软件中断处理程序</p><p><code>vDeferredHandlingFunction()</code> 的实现在清单 103 中显示。它打印出一个固定的字符串及其 <code>ulParameter2</code> 的参数值。</p><p><code>vDeferredHandlingFunction()</code> 必须具有清单 101 中所示的原型，尽管在这个例子中，实际上只使用了它的一个参数。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vDeferredHandlingFunction</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameter1<span class="token punctuation">,</span> uint32_t ulParameter2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 处理事件————在本例中只是打印出一条信息和 ulParameter2 的值。    pvParameter1 在本例中没有使用。 */</span>    <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span><span class="token string">"Handler function - Processing event "</span><span class="token punctuation">,</span> ulParameter2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单103. 执行示例18中中断所需的处理的函数</p><p>示例 18 使用的 <code>main()</code> 函数在 清单 104 中显示。它比示例 16 使用的 <code>main()</code> 函数更简单，因为它既不创建信号量，也不创建任务来执行延迟中断处理。</p><p><code>vPeriodicTask()</code> 是周期性产生软件中断的任务。它的创建优先级低于守护进程任务的优先级，以确保守护进程任务一离开阻塞状态，它就会被守护进程任务抢占。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 以低于守护进程任务的优先级创建生成软件中断的任务。    守护进程任务的优先级由 FreeRTOSConfig.h 中的    configTIMER_TASK_PRIORITY 编译时配置常量设置。 */</span>    <span class="token keyword">const</span> UBaseType_t ulPeriodicTaskPriority <span class="token operator">=</span> configTIMER_TASK_PRIORITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建将周期性生成软件中断的任务。 */</span>    <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>vPeriodicTask<span class="token punctuation">,</span> <span class="token string">"Periodic"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> ulPeriodicTaskPriority<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 安装软件中断的处理程序。执行此操作所需的语法取决于所使用的 FreeRTOS 移植。    这里显示的语法只能用于 FreeRTOS 的 windows 移植，在那里这种中断只是模拟的。 */</span>    <span class="token function">vPortSetInterruptHandler</span><span class="token punctuation">(</span>mainINTERRUPT_NUMBER<span class="token punctuation">,</span> ulExampleInterruptHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 启动调度器，使创建的任务开始执行。 */</span>    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 正常情况下，不应到达以下行。 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单104. 示例18中 <code>main()</code> 的实现</p><p>示例 18 产生的输出如图 57 所示。守护进程任务的优先级高于生成软件中断的任务的优先级，因此一旦生成中断，守护进程任务就会执行 <code>vDeferredHandlingFunction()</code>。这导致 <code>vDeferredHandlingFunction()</code> 输出的消息出现在周期性任务输出的两个消息之间，就像使用信号量取消阻塞专用延迟中断处理任务时一样。在图 58 中提供了进一步的解释。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240410001119808.png" alt="图 57. 执行示例 18 时产生的输出"></p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240410001514315.png" alt="图 58. 执行示例 18 时的执行顺序"></p><h2 id="在中断服务程序中使用队列"><a href="#在中断服务程序中使用队列" class="headerlink" title="在中断服务程序中使用队列"></a>在中断服务程序中使用队列</h2><p>二进制和计数信号量用于传递事件。队列用于传递事件和传输数据。</p><p><code>xQueueSendToFrontFromISR()</code> 是 <code>xQueueSendToFront()</code> 在中断服务例程中使用安全的版本； <code>xQueueSendToBackFromISR()</code> 是 <code>xQueueSendToBack()</code> 在中断服务例程中使用安全的版本； <code>xQueueReceiveFromISR()</code> 是 <code>xQueueReceive()</code> 在中断服务例程中使用安全的版本。</p><h3 id="xQueueSendToFrontFromISR-和xQueueSendToBackFromISR-API-函数"><a href="#xQueueSendToFrontFromISR-和xQueueSendToBackFromISR-API-函数" class="headerlink" title="xQueueSendToFrontFromISR() 和xQueueSendToBackFromISR() API 函数"></a>xQueueSendToFrontFromISR() 和xQueueSendToBackFromISR() API 函数</h3><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueSendToFrontFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>                                    <span class="token keyword">void</span> <span class="token operator">*</span>pvItemToQueue                                    BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken                                    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 105. <code>xQueueSendToFrontFromISR()</code> API 函数原型</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xQueueSendToBackFromISR</span><span class="token punctuation">(</span>QueueHandle_t xQueue<span class="token punctuation">,</span>                                   <span class="token keyword">void</span> <span class="token operator">*</span>pvItemToQueue<span class="token punctuation">,</span>                                   BaseType_t <span class="token operator">*</span>pxHigherPriorityTaskWoken                                  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>清单 106. <code>xQueueSendToBackFromISR()</code> API 函数原型</p><p><code>xQueueSendFromISR()</code> 和 <code>xQueueSendToBackFromISR()</code> 在功能上是等效的。</p><p>表38. <code>xQueueSendToFrontFromISR()</code> 和 <code>xQueueSendToBackFromISR()</code> 参数和返回值</p><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>要向其发送 (写入) 数据的队列的句柄。该队列句柄将从用于创建队列的 <code>xQueueCreate()</code> 调用中返回。</td></tr><tr><td><code>pvItemToQueue</code></td><td>指向将复制到队列中的数据的指针。<br>队列所能容纳的每个项目的大小是在创建队列时设置的，因此这许多字节将从 <code>pvItemToQueue</code> 复制到队列存储区域。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td>单个队列上有可能会有一个或多个任务被阻塞，等待数据变为可用。调用 <code>xQueueSendToFrontFromISR()</code> 或 <code>xQueueSendToBackFromISR()</code> 可以使数据可用，从而导致这样一个任务离开阻塞状态。如果调用 API 函数导致一个任务离开阻塞状态，并且解除阻塞的任务的优先级高于当前执行的任务（被中断的任务），则 API 函数在内部会将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。<br>如果 <code>xQueueSendToFrontFromISR()</code> 或 <code>xQueueSendToBackFromISR()</code> 将此值设置为 <code>pdTRUE</code>，那么在中断退出之前应该进行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。</td></tr><tr><td>返回值</td><td><p>有两个可能的返回值:<br>1. <code>pdPASS</code><br><code>pdPASS</code> 仅在数据被成功发送到队列时返回。<br>2. <code>errQUEUE_FULL</code><br>如果由于队列已满而无法将数据发送到队列，则返回 <code>errQUEUE_FULL</code>。</p></td></tr></tbody></table><h3 id="从-ISR-中使用队列时的考虑因素"><a href="#从-ISR-中使用队列时的考虑因素" class="headerlink" title="从 ISR 中使用队列时的考虑因素"></a>从 ISR 中使用队列时的考虑因素</h3><p>队列提供了一种将数据从中断传递到任务的简单便捷的方法，但如果数据到达频率较高，则使用队列效率不高。</p><p>FreeRTOS 下载中的许多演示程序都包含一个简单的 UART 驱动程序，该驱动程序使用队列将字符从 UART 的接收 ISR 中传递出来。在这些演示程序中，使用队列有两个原因：演示从 ISR 使用的队列，以及故意加载系统以测试 FreeRTOS 移植。以这种方式使用队列的 ISR 绝对不是为了代表高效的设计，除非数据到达速度放慢，否则建议生产代码不要复制该技术。适用于生产环境代码的更高效的技术包括 :</p><ul><li><p>使用直接内存访问（DMA）硬件来接收和缓冲字符。这种方法实际上没有软件开销。然后可以使用直接到任务的通知 [1] 来解除对仅在检测到传输中断后才处理缓冲区的任务的阻塞。</p><blockquote><p>[1] 直接到任务的通知提供了从 ISR 取消阻塞任务的最有效方法。第9章 任务通知 中介绍了直接到任务的通知。</p></blockquote></li><li><p>将收到的每个字符复制到线程安全的 RAM 缓冲区 [2]。同样，直接任务通知可用于在收到完整消息后或在检测到传输中断后解除对将要处理缓冲区的任务的阻塞。</p><blockquote><p>[2] 作为 FreeRTOS + TCP (<a href="http://www.freertos.org/tcp">http://www.FreeRTOS.org/tcp</a>) 的一部分提供的 “Stream Buffer ( 流缓冲区 )” 可以用于此目的。</p></blockquote></li><li><p>直接在 ISR 中处理收到的字符，然后使用队列将数据处理的结果 ( 而不是原始数据 ) 发送到一个任务。图 34 先前已对此进行了演示。</p></li></ul><h3 id="示例-19-在一个队列中从一个中断中发送和接收信息"><a href="#示例-19-在一个队列中从一个中断中发送和接收信息" class="headerlink" title="示例 19. 在一个队列中从一个中断中发送和接收信息"></a>示例 19. 在一个队列中从一个中断中发送和接收信息</h3><p>此示例演示在同一中断中使用的 <code>xQueueSendToBackFromISR()</code> 和 <code>xQueueReceiveFromISR()</code>  。如前所述，为方便起见，中断由软件产生。</p><p>创建一个周期性任务，每200毫秒向一个队列发送五个数字。只有在所有五个数字都已发送后，它才会产生一个软件中断。任务实现如清单 107 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vIntegerGenerator</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pvParameters<span class="token punctuation">)</span><span class="token punctuation">{</span>    TickType_t xLastExecutionTime<span class="token punctuation">;</span>    uint32_t ulValueToSend <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 初始化调用 vTaskDelayUntil() 所使用的变量。 */</span>    xLastExecutionTime <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 这是一个周期性任务。阻塞直到它再次运行的时间。任务将每 200ms 执行一次。 */</span>        <span class="token function">vTaskDelayUntil</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xLastExecutionTime<span class="token punctuation">,</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 向队列发送五个数字，每个数字比前一个数字高一。这些数字由中断服务例程从队列中读取。        中断服务例程总是清空队列，所以这个任务保证能够写入所有五个值，而不需要指定阻塞时间。 */</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">xQueueSendToBack</span><span class="token punctuation">(</span>xIntegerQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ulValueToSend<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulValueToSend<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/* 生成中断，以便中断服务例程可以从队列中读取数值。        用于生成软件中断的语法取决于正在使用的 FreeRTOS 移植。        下面使用的语法只能用于 FreeRTOS Windows 移植，        在该移植中，这种中断只是模拟的。*/</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span><span class="token string">"Generator task - About to generate an interrupt.\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vPortGenerateSimulatedInterrupt</span><span class="token punctuation">(</span>mainINTERRUPT_NUMBER<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span><span class="token string">"Generator task - Interrupt generated.\r\n\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清单 107. 示例 19 中写入队列的任务的实现</p><p>中断服务例程重复调用 <code>xQueueReceiveFromISR()</code> ，直到周期性任务写入队列的所有值都被读出，并且队列为空。每个收到的值的最后两位被用作一个字符串数组的索引。然后通过调用 <code>xQueueSendFromISR()</code> ，将指向相应索引位置处的字符串的指针发送到不同的队列。中断服务例程的实现如清单 108 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> uint32_t <span class="token function">ulExampleInterruptHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    BaseType_t xHigherPriorityTaskWoken<span class="token punctuation">;</span>    uint32_t ulReceivedNumber<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字符串被声明为静态常量，以确保它们不被分配到中断服务例程的堆栈上，    因此即使在中断服务例程不执行时也存在。 */</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcStrings<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>        <span class="token punctuation">{</span>            <span class="token string">"String 0\r\n"</span><span class="token punctuation">,</span>            <span class="token string">"String 1\r\n"</span><span class="token punctuation">,</span>            <span class="token string">"String 2\r\n"</span><span class="token punctuation">,</span>            <span class="token string">"String 3\r\n"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 与往常一样，xHigherPriorityTaskWoken 被初始化为 pdFALSE，    以便能够检测到它在中断安全 API 函数中被设置为 pdTRUE。请注意，    由于中断安全API函数只能将 xHigherPriorityTaskWoken 设置为 pdTRUE，    因此在对 xQueueReceiveFromISR() 的调用和对 QueueSendToBackFromISR()     的调用中使用同一个 xHigherPriorityTaskWoken 变量是安全的。 */</span>    xHigherPriorityTaskWoken <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 从队列中读取，直到队列为空。 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">xQueueReceiveFromISR</span><span class="token punctuation">(</span>xIntegerQueue<span class="token punctuation">,</span>                                <span class="token operator">&amp;</span>ulReceivedNumber<span class="token punctuation">,</span>                                <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span> <span class="token operator">!=</span> errQUEUE_EMPTY<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 将接收到的值截断到最后两位 (包括值 0 到 3 )，        然后用截断的值作为 pcStrings[] 数组的索引，        选择一个字符串 (char *) 发送到另一个队列上。 */</span>        ulReceivedNumber <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0x03</span><span class="token punctuation">;</span>        <span class="token function">xQueueSendToBackFromISR</span><span class="token punctuation">(</span>xStringQueue<span class="token punctuation">,</span>                                <span class="token operator">&amp;</span>pcStrings<span class="token punctuation">[</span>ulReceivedNumber<span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token operator">&amp;</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 如果从 xIntegerQueue 接收导致任务离开阻塞状态，    并且如果离开阻塞状态的任务的优先级高于处于运行状态的任务的优先级，    那么 xHigherPriorityTaskWoken 将在 xQueueReceiveFromISR() 中被设置为 pdTRUE。        如果向 xStringQueue 发送导致任务离开阻塞状态，    并且如果离开阻塞状态的任务的优先级高于处于运行状态的任务的优先级，    那么 xHigherPriorityTaskWoken 将在 xQueueSendToBackFromISR() 中被设置为 pdTRUE。        xHigherPriorityTaskWoken 被用作 portYIELD_FROM_ISR() 的参数。    如果 xHigherPriorityTaskWoken 等于 pdTRUE，    那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，    那么调用 portYIELD_FROM_ISR() 将没有任何作用。        Windows 移植使用的 portYIELD_FROM_ISR() 的实现包括一个 return 语句，    这就是为什么这个函数没有显式返回值的原因。 */</span>    <span class="token function">portYIELD_FROM_ISR</span><span class="token punctuation">(</span>xHigherPriorityTaskWoken<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 108. 示例 19 所使用的中断服务例程的实现</p><p>从中断服务例程接收字符指针的任务在队列上阻塞，直到有消息到达，，并在接收到每个字符串时打印出来。它的实现如清单 109 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vStringPrinter</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pcString<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 在队列上阻塞以等待数据到达 */</span>        <span class="token function">xQueueReceive</span><span class="token punctuation">(</span> xStringQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pcString<span class="token punctuation">,</span> portMAX_DELAY <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 打印出接收到的字符串。*/</span>        <span class="token function">vPrintString</span><span class="token punctuation">(</span> pcString <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>清单 109. 示例 19 中打印从中断服务例程接收到的字符串的任务</p><p>像往常一样，<code>main()</code> 在启动调度程序之前创建所需的队列和任务。它的实现如清单 110 所示。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 在使用队列之前，必须首先创建队列。创建本例所使用的两个队列。 一个队列可以保存 uint32_t 类型的变量，另一个队列可以保存 char * 类型的变量。 两个队列最多可以容纳10个项目。真实的应用程序应该检查返回值以确保队列已被成功创建。 */</span> xIntegerQueue <span class="token operator">=</span> <span class="token function">xQueueCreate</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> xStringQueue <span class="token operator">=</span> <span class="token function">xQueueCreate</span><span class="token punctuation">(</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 创建使用队列将整数传递给中断服务例程的任务。任务以优先级 1 创建。 */</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vIntegerGenerator<span class="token punctuation">,</span> <span class="token string">"IntGen"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 创建打印出中断服务例程发送给它的字符串的任务。此任务以较高的优先级 2 创建。 */</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span> vStringPrinter<span class="token punctuation">,</span> <span class="token string">"String"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 安装软件中断的处理程序。这样做所需的语法取决于正在使用的 FreeRTOS 移植。 这里显示的语法只能用于 FreeRTOS Windows 移植，在那里这种中断只是模拟的。 */</span> <span class="token function">vPortSetInterruptHandler</span><span class="token punctuation">(</span> mainINTERRUPT_NUMBER<span class="token punctuation">,</span> ulExampleInterruptHandler <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 启动调度程序，使创建的任务开始执行。 */</span> <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 如果一切顺利，那么main()将永远不会到达这里，因为调度程序现在将运行任务 如果 main() 确实到达这里，那么很可能是没有足够的堆内存可用于创建空闲任务。 第 2 章提供了有关堆内存管理的更多信息。 */</span> <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>清单 110. 示例 19 的 <code>main()</code> 函数</p><p>执行示例 19 时产生的输出如图 59 所示。可以看出，中断接收了所有五个整数，并产生了五个字符串作为响应。图 60 中给出了更多的解释。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240411070715950.png" alt="图 59. 执行示例 19 时产生的输出"></p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240411071042631.png" alt="图 60. 示例 19 产生的执行顺序"></p><h2 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h2><p>在任务优先级和中断优先级之间出现混淆是很常见的。本节讨论中断优先级，本节讨论中断优先级，即中断服务例程 ( ISR ) 相对于彼此执行的优先级。分配给任务的优先级与分配给中断的优先级没有任何关系。硬件决定 ISR 何时执行，而软件决定任务何时执行。响应硬件中断而执行的 ISR 将中断任务，但任务不能抢占 ISR。</p><p>支持中断嵌套的移植需要在 <code>FreeRTOSConfig.h</code> 中定义表 39 中详述的一个或两个常量。 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 和 <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code> 都定义相同的属性。较旧的 FreeRTOS 移植使用 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>，较新的 FreeRTOS 移植使用 <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code>。</p><p>表 39. 控制中断嵌套的常量</p><table><thead><tr><th>恒定</th><th>描述</th></tr></thead><tbody><tr><td><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> or <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code></td><td>设置可以调用中断安全 FreeRTOS API 函数的最高中断优先级。</td></tr><tr><td><code>configKERNEL_INTERRUPT_PRIORITY</code></td><td>设置滴答 ( tick ) 中断使用的中断优先级，并且必须始终设置为尽可能低的中断优先级。<br>如果使用的FreeRTOS移植没有同时使用<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 常量，那么任何使用中断安全的FreeRTOS API 函数的中断也必须以 <code>configKERNEL_INTERRUPT_PRIORITY</code> 定义的优先级执行。</td></tr></tbody></table><p>每个中断源都有一个数字优先级和一个逻辑优先级 : </p><ul><li><p>数字优先级</p><p>数字优先级只是分配给中断优先级的数字。例如，如果一个中断被分配的优先级为7，那么它的数字优先级就是 7。 同样，如果一个中断被分配的优先级为 200，那么它的数字优先级就是 200。</p></li><li><p>逻辑优先级</p><p>一个中断的逻辑优先级描述了该中断相对于其他中断的优先级。</p><p>如果两个不同优先级的中断同时发生，则处理器将先执行两个中断中逻辑优先级较高的一个中断，然后再执行两个中断中逻辑优先级较低的一个中断。</p><p>一个中断可以中断 ( 嵌套 ) 任何具有较低逻辑优先级的中断，但一个中断不能中断 ( 嵌套 ) 任何具有相同或更高逻辑优先级的中断。</p></li></ul><p>中断的数字优先级和逻辑优先级之间的关系取决于处理器架构；在某些处理器上，分配给一个中断的数字优先级越高，该中断的逻辑优先级就越高，而在其他处理器架构上，分配给一个中断的数字优先级越高，该中断的逻辑优先级就越低。</p><p>通过将 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 设置为比 <code>configKERNEL_INTERRUPT_PRIORITY</code> 更高的逻辑中断优先级可以创建一个完整的中断嵌套模型。图 61 对此进行了演示，其中显示了以下场景：</p><ul><li>处理器具有 7 个唯一的中断优先级。</li><li>分配数字优先级 7 的中断比分配数字优先级 1 的中断具有更高的逻辑优先级。</li><li><code>configKERNEL_INTERRUPT_PRIORITY</code> 被设置为 1 。</li><li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 被设置为 3 。</li></ul><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240411085426838.png" alt="图 61. 影响中断嵌套行为的常量"></p><p>参考图 61：</p><ul><li>当内核或应用程序位于临界段时，使用优先级 1 到 3 ( 含 ) 的中断将被阻止执行。以这些优先级运行的 ISR 可以使用中断安全的 FreeRTOS API 函数。临界段的描述见第 7 章。</li><li>使用优先级 4 或更高优先级的中断不受临界段的影响，因此调度程序所做的任何操作都不会阻止这些中断立即执行——在硬件本身的限制范围内。以这些优先级执行的 ISR 无法使用任何 FreeRTOS API 函数。</li><li>通常，需要非常严格的时间精度的功能 ( 例如电机控制 ) 会使用高于 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 的优先级，以确保调度器不会在中断响应时间中引入抖动。</li></ul><h3 id="对ARM-Cortex-M-和ARM-GIC用户的说明"><a href="#对ARM-Cortex-M-和ARM-GIC用户的说明" class="headerlink" title="对ARM Cortex-M 和ARM GIC用户的说明"></a>对ARM Cortex-M 和ARM GIC用户的说明</h3><p><code>Cortex-M</code> 处理器上的中断配置很混乱，并且容易出错。为了协助您的开发，<code>FreeRTOS Cortex-M</code> 移植会自动检查中断配置，但前提是定义了 <code>configASSERT()</code> 。<code>configASSERT()</code> 在 11.2 节中描述。</p><blockquote><p>Cortex-M：本节仅部分适用于 <code>Cortex-M0</code> 和 <code>Cortex-M0+</code> 内核。</p></blockquote><p>ARM Cortex 内核和 ARM 通用中断控制器 (GIC — Generic Interrupt Controller ) 使用数字上的低优先级数字来表示逻辑上的高优先级中断。这似乎违反直觉，并且很容易忘记。如果您希望为中断分配逻辑上较低的优先级，则必须为其分配较高的数字值。如果您希望为中断分配逻辑上较高的优先级，则必须为其分配较低的数字值。</p><p><code>Cortex-M</code> 中断控制器允许使用最多 8 位来指定每个中断优先级，使 255 成为可能的最低优先级。0 是最高优先级。然而，<code>Cortex-M</code> 微控制器通常仅实现 8 个可能位的子集。实际实现的位数取决于微控制器系列。</p><p>当仅实现了 8 个可能位的子集时，只能使用字节的最高有效位，而最低有效位则未实现。未实现的位可以取任何值，但通常将它们设置为  1 。 图 62 对此进行了演示，该图显示了二进制 101 的优先级如何存储在一个实现了 4 个优先位的<code>Cortex-M</code>微控制器中。</p><p><img src="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/image-20240411174725336.png" alt="图 62. 实现 4 个优先级位的 Cortex-M 微控制器如何存储二进制 101 的优先级"></p><p>在图 62 中，二进制值 101 已移至最高有效四位，因为未实现最低有效四位。 未实现的位已设置为 1。</p><p>某些库函数期望在将优先级值向上移至已实现的 ( 最高有效 ) 位之后指定优先级值。在使用这样的函数时，可以将图 62 所示的优先级指定为十进制 95 ( 0101 1111 ) 。十进制 95 将二进制 101 上移 4 以生成二进制 101nnnn ( 其中 ‘ n ‘ 是一个未实现的位 )，将未实现的位设置为 1 以生成二进制 1011111 。</p><p>某些库函数期望在将优先级值向上移至已实现的 ( 最高有效 ) 位之前指定优先级值。使用此类函数时，图 62 中所示的优先级必须指定为十进制 5。十进制 5 是没有任何移位的二进制 101。</p><blockquote><p>也就是说在使用函数写入优先级寄存器时，要设置的优先级通常作为函数参数传入，有些函数要求你传入的参数要提前将优先级移至对应的有效位，函数直接将参数写入寄存器；有些函数可以直接将要设置的优先级作为参数传入，函数会帮你在内部将参数做好移位后再写入寄存器。</p></blockquote><p><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 和 <code>configKERNEL_INTERRUPT_PRIORITY</code> 必须以允许它们直接写入 <code>Cortex-M</code> 寄存器的方式来指定，所以在优先级值被上移到实现的位后。</p><p><code>configKERNEL_INTERRUPT_PRIORITY</code> 必须始终设置为可能的最低中断优先级。 未实现的优先级位可以设置为1，因此无论实际实现了多少优先级位，该常量始终可以设置为 255。</p><p><code>Cortex-M</code>中断的默认优先级为 0 —— 可能的最高优先级。<code>Cortex-M</code> 硬件的实现不允许 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 被设置为 0 ，所以使用 FreeRTOS API 的中断的优先级绝不能保留为其默认值。</p>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo的使用教程</title>
      <link href="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/"/>
      <url>/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文的内容适用性可能会随着 hexo 和相关程序的更新而改变，请以实际的操作结果为准。</p><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h2><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><p>为了把本地的网页文件上传到github上面去，需要用到工具———Git[下载地址]。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程</p><p><strong>windows：</strong>到git官网上下载.exe文件，<a href="https://git-scm.com/download/win">Download git</a>，对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。安装选项还是全部默认，只不过最后一步添加路径时选择 Use Git from the Windows Command Prompt ，这样我们就可以直接在命令提示符里打开git了。</p><p><strong>linux：</strong>对 <code>linux</code> 来说实在是太简单了，只需要一行代码</p><pre><code>sudo apt-get install git</code></pre><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2. 安装nodejs"></a>2. 安装nodejs</h3><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p><strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。</p><p><strong>linux：</strong>命令行安装：</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>不过不推荐命令行安装，有时候有问题，建议直接到<a href="http://nodejs.cn/">nodejs官网</a>去下载，如下所示：</p><p><img src="/Blogs/./hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Nodejs_download.png"></p><p>安装完后，打开命令行终端，输入：</p><pre><code>node -vnpm -v</code></pre><p>检查一下有没有安装成功，出现版本号就是成功了。</p><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h3><p>前面<code>git</code>和<code>nodejs</code>安装好后，就可以使用 <code>npm</code> 安装<code>hexo</code>了。</p><blockquote><p>npm，全名 node package manger。</p><ul><li>npm 是<code>Node</code>的开放式模块登记和管理系统，是<code>Node.js</code>包的标准发布平台，用于<code>Node.js</code>包的发布、传播、依赖控制，网址：<a href="https://link.zhihu.com/?target=https://www.npmjs.com/">https://www.npmjs.com/</a></li><li>npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包</li></ul><p><a href="https://zhuanlan.zhihu.com/p/258080852">npm 超详细教程</a></p><p><a href="https://www.runoob.com/nodejs/nodejs-npm.html">npm 使用介绍</a></p></blockquote><p>右键点击<code>Git Bash Here</code>，打开<code>git</code>的控制台窗口，以后我们所有的操作都在<code>git</code>控制台进行，就不用<code>Windows</code>自带的<code>cmd</code>了(要用也能用)。</p><p>输入<code>npm install -g hexo-cli</code>安装 <code>Hexo</code>。可能会有几个报错，无视它就行。</p><pre><code>npm install -g hexo-cli</code></pre><p>安装完后输入 <code>hexo -v</code> 验证是否安装成功。</p><p>至此 <code>hexo</code> 就安装完了。</p><blockquote><p>npm包在全局安装之后，这个包的命令就会被注册到全局，你就可以直接在命令行中执行这个命令了。其实当你全局安装一个npm包之后，这个包被存放在默认全局安装路径中，可通过命令 <code>npm root -g</code> 查看，<code>npm config ls</code> 查看 npm 的基础设置。通过 <code>npm install express -g</code> 进行全局安装，express 是包的名称。</p><p>本地(局部)安装会将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。通过 <code>npm install express</code> 进行局部安装，express 是包的名称。本地安装的包不能在命令行中直接运行包的命令，因为命令行通过环境变量检索可执行的命令，而本地安装的包的路径没有加到环境变量中，可以通过将 node_modules 路径添加到环境变量(不建议)，或者本地安装路径用路径来使用，如：<code>./node_modules/.bin/hexo g</code>  等效于全局安装时的 <code>hexo g</code> 命令，还可以使用 <code> npx hexo g</code> 。</p><p>上面的 hexo-cli 包就是全局安装，全局安装可以一个包多个项目共用，但不同的项目可能对包的版本要求各有不同，容易发生冲突，结合实际情况选择全局安装还是局部安装。</p></blockquote><h3 id="4-初始化-hexo"><a href="#4-初始化-hexo" class="headerlink" title="4. 初始化 hexo"></a>4. 初始化 hexo</h3><p>接下来初始化一下 <code>hexo</code> ，即初始化我们的网站，输入 <code>hexo init</code> 初始化文件夹</p><pre><code>hexo init &lt;folder&gt;</code></pre><p><code>folder</code> 指定一个文件夹(若该文件夹不存在，则创建自动该文件夹)，在该文件夹下新建所需要的文件。如果没有指定这个参数，将直接在当前路径下新建所需文件。</p><p>接着进入新建了所需文件的路径，输入 <code>npm install</code> ，根据运行 <code>hexo init</code> 新建的文件中的配置安装必备的组件。</p><blockquote><p>注意：这里使用的下载命令是 <code>npm install</code> ，所以是局部安装，所以每次在其他路径初始化新的网站 (<code>hexo init</code>) 后，都要执行 <code>npm install</code> 下载一遍必备的组件。前面安装 hexo 是全局安装，所以不用重新安装 hexo。</p></blockquote><p>完成后，指定目录下有：</p><ul><li><code>node_modules:</code>  依赖包</li><li><code>public: </code> 存放生成的页面</li><li><code>scaffolds:</code> <a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a> 文件夹。新建文章时，Hexo 会根据 scaffold 来创建文件。</li></ul><blockquote><p>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 <code>scaffold/post.md</code> 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p></blockquote><ul><li><code>source:</code> 用来存放用户的文章</li></ul><blockquote><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p></blockquote><ul><li><code>themes:</code> <a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li><li><code>_config.yml:</code>  网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</li><li><code>package.json:</code> 应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，可以自由移除</li></ul><p>这样本地的最简单的网站配置就弄好了，输入<code>hexo g</code> 生成静态网页，然后输入<code>hexo s</code> 打开本地服务器：</p><pre><code>hexo ghexo server(或者简写:hexo s）)</code></pre><h2 id="配置-hexo-的-config-yml"><a href="#配置-hexo-的-config-yml" class="headerlink" title="配置  hexo 的 _config.yml"></a>配置  hexo 的 _config.yml</h2><p>官方的文档更详细—-&gt;<a href="https://hexo.io/zh-cn/docs/configuration">配置</a> ，强烈建议忘记相关内容时优先看官方文档，在这里只选出部分内容配合图片进行说明。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词。支持多个关键词。</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者(如果在文章的参数中指定了另一个author，这里的author就会被覆盖，未指定就显示这里的author)。</p><p><img src="/Blogs/_config.yml-Site.png"></p><p><img src="/Blogs/./hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/_config.yml-Site.png"></p><p><img src="/Blogs/./hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/_config.yml-Site_1.png"></p><h2 id="细碎的网页配置记录"><a href="#细碎的网页配置记录" class="headerlink" title="细碎的网页配置记录"></a>细碎的网页配置记录</h2><h3 id="首页轮播"><a href="#首页轮播" class="headerlink" title="首页轮播"></a>首页轮播</h3><p>首先想要看到轮播效果必须先把文章加入轮播里，首页图片和文章图片组成了轮播，如果不把文章加入轮播里就算开启了轮播也没有办法看到轮播效果。怎么加入readme文件中有文章Front-matter的介绍(建议ctrl+f搜索关键字)，也就是新建文章需要有哪些配置</p><h3 id="首页背景颜色"><a href="#首页背景颜色" class="headerlink" title="首页背景颜色"></a>首页背景颜色</h3><p>更改颜色主题文件夹下的source/css/matery.css的606-696行， 背景颜色可以要可以不要，看你选择的轮播图片了。如果轮播图片颜色较浅就要加，因为不加的话上面的文字会看不清楚，颜色也可以更改。不过没有找到好的配色的话还是不要乱改变了，会很丑</p><h3 id="导航栏背景颜色"><a href="#导航栏背景颜色" class="headerlink" title="导航栏背景颜色"></a>导航栏背景颜色</h3><p>也是matery.css中找到.bg-cover修改，我用的是</p><pre class=" language-css"><code class="language-css">   <span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#7371BC</span> <span class="token number">0%</span>, <span class="token hexcode">#284D95</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p>改了你想用的颜色之后其他的图标、hover等等的颜色也要与导航栏相匹配才好看，怎么找其他的呢？告诉你一个比较笨又比较方便的一个办法。在matery.css中从头到尾找与刚才.bg-cover中相近的颜色(一般编辑器中都会显示颜色)全部改为你想要的颜色，轮播图片中按钮颜色找.cover-btns。具体配色看个人喜好了</p><h3 id="新建文章的模板修改"><a href="#新建文章的模板修改" class="headerlink" title="新建文章的模板修改"></a>新建文章的模板修改</h3><p>首先为了新建文章方便，我们可以修改一下文章模板，可以将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token hr punctuation">---</span>title: {{ title }}date: {{ date }}author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:keywords:tags:<span class="token title important">categories:<span class="token punctuation">---</span></span></code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，hexo会自动将这些内容复制到新建的博客中，修改对应信息就可以了。</p><h3 id="matery主题的背景图遮罩颜色"><a href="#matery主题的背景图遮罩颜色" class="headerlink" title="matery主题的背景图遮罩颜色"></a>matery主题的背景图遮罩颜色</h3><h3 id="在博客中使用本地图片"><a href="#在博客中使用本地图片" class="headerlink" title="在博客中使用本地图片"></a>在博客中使用本地图片</h3><p>对应官方文档的 <a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a> 章节</p><p>想要更有规律地提供图片和其他资源以及想要将资源分布在各个文章上时，可以将 hexo 的 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 。</p><p>这样的话 Hexo 将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><p><img src="/Blogs/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240322031826172.png" alt="新建文章"></p><p><img src="/Blogs/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240322032008441.png" alt="自动生成对应文件夹"></p><p>但是通过常规的 markdown 语法和相对路径来引用图片和其它资源在网页上并不能正常显示。</p><p><img src="/Blogs/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20240322032521818.png" alt="图片不能正常显示"></p><h4 id="使用标签插件"><a href="#使用标签插件" class="headerlink" title="使用标签插件"></a>使用标签插件</h4><p>要想让 md 文件中引用的本地图片在网页上正常显示，可以使用 hexo 提供的功能。</p><p>以上面图片中新建的 111.md 为例，把一个 <code>example.jpg</code> 图片放在了对应 111 文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](./111/example.jpg)</code> ，图片不会出现在网页上。要想在网页上正确显示图片，应该使用 hexo 插件提供的功能：</p><pre><code>{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %}</code></pre><pre><code>{% asset_img example.jpg This is an example image %}</code></pre><p>图片正常显示：</p><img src="123.jpg" alt="image-20240322040752173" style="zoom:50%;"><p>这种方法只能引用与文章同名的文件夹下的图片，上例中，如果在 111 文件夹下创建一个 222 文件夹，将图片放进去，想用  引用图片，这种操作是无效的。</p><p>通过这种方法引用的图片只能在构建成网页时显示，在 markdown 编辑器中只是一行代码而已，毕竟不是 markdown 语法的一部分，实际体验并不是很好。</p><h2 id="使用markdown语法"><a href="#使用markdown语法" class="headerlink" title="使用markdown语法"></a>使用markdown语法</h2><p>hexo-renderer-marked 允许你无需使用 <code>asset_img</code> 标签插件就可以在 markdown 中嵌入图片</p><h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><h3 id="部署-deploy-时遇到的问题"><a href="#部署-deploy-时遇到的问题" class="headerlink" title="部署(deploy)时遇到的问题"></a>部署(deploy)时遇到的问题</h3><p><img src="/Blogs/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/error1.png" alt="error1"></p><p><strong>解决方法：</strong></p><p><img src="/Blogs/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/error2.png" alt="error2"></p><p>图中提供的资料链接：<a href="https://docs.github.com/code-security/secret-scanning/pushing-a-branch-blocked-by-push-protection">Learn how to resolve a blocked push</a></p><p>黄框中用来进行验证的临时链接：</p><img src="hexo的使用教程/image-20240324035941633.png" alt="image-20240324035941633" style="zoom:67%;"><p>看了一下大概是为了保证仓库安全而采取的措施。</p><p>1</p><img src="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/error2.png" class="" title="这是一张图片"><p>2</p><p>3</p><p><img src="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/error2.png" alt="这是一张图片"></p><p>4</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/">hexo 官方中文文档</a></p><p><a href="https://blog.csdn.net/qq_58608526/article/details/124652412">Hexo+Github博客搭建教程</a></p><p><a href="https://blog.csdn.net/kuashijidexibao/article/details/112971657">Hexo-Matery主题细致美化</a></p><p><a href="https://x-hao.github.io/2021/04/22/hexo-matery-da-jian-ge-ren-bo-ke-cai-keng-ji-lu/">hexo+matery搭建个人博客踩坑记录</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
