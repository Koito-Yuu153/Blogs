<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chapter 6 中断管理</title>
      <link href="/Blogs/2024/06/15/chapter-6-zhong-duan-guan-li/"/>
      <url>/Blogs/2024/06/15/chapter-6-zhong-duan-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-6-中断管理"><a href="#Chapter-6-中断管理" class="headerlink" title="Chapter 6 中断管理"></a>Chapter 6 中断管理</h1><h2 id="章节介绍和范围"><a href="#章节介绍和范围" class="headerlink" title="章节介绍和范围"></a>章节介绍和范围</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>嵌入式实时系统必须对源自环境的事件做出响应。例如，到达以太网外设的数据包（事件）可能需要传递到 TCP/IP 栈进行处理（操作）。非平凡的系统必须服务于来自多个源的事件，所有这些源都有不同的处理开销和响应时间要求。在每种情况下，都必须对最佳事件处理实施策略作出判断：</p><ol><li>如何检测事件？通常使用中断，但也可以轮询输入。</li><li>当使用中断时，应在中断服务例程 (ISR) 内部执行多少处理，在外部执行多少处理？通常希望每个 ISR 尽可能短。</li><li>如何将事件与主 (非 ISR) 代码通信，以及如何构造此代码以最佳地适应潜在异步事件的处理？</li></ol><p>FreeRTOS 不会对应用程序设计者强加任何特定的事件处理策略，但确实提供了允许以简单且可维护的方式实现所选策略的功能。</p><p>重要的是区分任务的优先级和中断的优先级：</p><ul><li>任务是与运行 FreeRTOS 的硬件无关的软件功能。 任务的优先级由应用程序编写者在软件中分配，软件算法 (调度器) 决定哪个任务将处于运行状态。</li><li>虽然中断服务例程是用软件编写的，但它是一个硬件特性，因为硬件控制哪个中断服务例程将运行，以及何时运行。任务只会在没有 ISR 运行时运行，因此最低优先级的中断将中断最高优先级的任务，并且任务无法抢占 ISR 。</li></ul><p>所有运行 FreeRTOS 的体系结构都能够处理中断，但是与中断进入和中断优先级分配有关的架构之间有所不同。</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章旨在让读者更好地理解：</p><ul><li>哪些 FreeRTOS API 函数可以在中断服务程序中使用。</li><li>将中断处理延迟到任务的方法。</li><li>如何创建和使用二进制信号量和计数信号量。</li><li>二进制和计数信号量之间的区别。</li><li>如何使用队列将数据传入和传出中断服务程序。</li><li>中断嵌套模型可用于一些 FreeRTOS 移植。</li></ul><h2 id="从-ISR-使用-FreeRTOS-API"><a href="#从-ISR-使用-FreeRTOS-API" class="headerlink" title="从 ISR 使用 FreeRTOS API"></a>从 ISR 使用 FreeRTOS API</h2><h3 id="中断安全-API"><a href="#中断安全-API" class="headerlink" title="中断安全 API"></a>中断安全 API</h3><p>通常需要从中断服务例程 (ISR) 中使用 FreeRTOS API 函数提供的功能，但是许多FreeRTOS API 函数执行的操作在 ISR 中无效——其中最值得注意的是将调用 API 函数的任务置于阻塞状态； 如果从 ISR 调用 API 函数，则它不是从任务调用的，所以没有调用任务可以被置于阻塞状态。 FreeRTOS 通过提供一些 API 函数的两个版本来解决这个问题；一个版本用于任务，另一个版本用于 ISR。打算从 ISR 中使用的函数在其名称后附加了  “<code>FromISR</code>” 。    </p><blockquote><p>注意：切勿从 ISR 调用名称中不含 “<code>FromISR</code>” 的 FreeRTOS API 函数。</p></blockquote><h3 id="使用单独的中断安全-API-的好处"><a href="#使用单独的中断安全-API-的好处" class="headerlink" title="使用单独的中断安全 API 的好处"></a>使用单独的中断安全 API 的好处</h3><p>具有用于中断的单独 API 可以使任务代码更高效，ISR 代码更有效，并且进入中断更简单。 要了解原因，请考虑另一种解决方案，该解决方案将提供可以从任务和 ISR 调用的每个 API 函数的单个版本。如果可以从任务和 ISR 调用相同版本的 API 函数，则：</p><ul><li>API 函数将需要额外的逻辑来确定它们是从任务还是 ISR 调用的。额外的逻辑将引入通过函数的新路径，使函数更长，更复杂，更难测试。</li><li>当从任务调用函数时，某些 API 函数参数将过时，而当从 ISR 调用函数时，其他 API 函数参数将过时。</li><li>每个 FreeRTOS 移植都需要提供一个用于确定执行上下文 (任务或ISR) 的机制。</li><li>难以确定执行上下文（任务或 ISR）的架构将需要额外的、浪费的、使用起来更复杂的非标准中断进入代码，允许软件提供执行上下文。</li></ul><h3 id="使用单独的中断安全-API-的缺点"><a href="#使用单独的中断安全-API-的缺点" class="headerlink" title="使用单独的中断安全 API 的缺点"></a>使用单独的中断安全 API 的缺点</h3><p>拥有两个版本的一些 API 函数可以提高任务和 ISR 的效率，但会带来新的问题；有时需要从任务和 ISR 调用不属于 FreeRTOS API 的函数，但使用 FreeRTOS API。</p><p>这通常只是集成第三方代码时的问题，因为这是软件设计不受应用程序编写者控制的唯一时候。 如果这确实成为一个问题，那么可以使用以下技术之一来克服该问题：</p><ol><li><p>将中断处理延迟到任务，因此只从任务的上下文中调用 API 函数。</p><blockquote><p>本书的下一节将介绍延迟中断处理。</p></blockquote></li><li><p>如果您使用的是支持中断嵌套的 FreeRTOS 移植，则使用以 “<code>FromISR</code>” 结尾的 API 函数版本，因为该版本可以从任务和 ISR 中调用（反之则不然，不以 “<code>FromISR</code>” 结尾的 API 函数不能从 ISR 调用）。</p></li><li><p>第三方代码通常包括一个 RTOS 抽象层，可以实现该抽象层来测试调用函数的上下文 (任务或中断) ，然后调用适合该上下文的 API 函数。</p></li></ol><h3 id="xHigherPriorityTaskWoken-参数"><a href="#xHigherPriorityTaskWoken-参数" class="headerlink" title="xHigherPriorityTaskWoken 参数"></a>xHigherPriorityTaskWoken 参数</h3><p>本节介绍了 <code>xHigherPriorityTaskWoken</code> 参数的概念。 如果您还没有完全理解本节，请不要担心，因为后续章节提供了实际示例。</p><p>如果上下文切换是由中断执行的，那么中断退出时运行的任务可能与进入中断时运行的任务不同——中断将中断一个任务，但返回到另一个任务。</p><p>一些 FreeRTOS API 函数可以将任务从阻塞状态移动到就绪状态。 这已经在诸如 <code>xQueueSendToBack()</code> 之类的函数中看到了，如果有一个任务在阻塞状态等待数据在主题队列上可用，它将解除对任务的阻塞。</p><p>如果被 FreeRTOS API 函数解除阻塞的任务的优先级高于处于运行状态下的任务的优先级，那么根据 FreeRTOS 调度策略，应该切换到更高优先级的任务。 实际切换到更高优先级任务的时间取决于调用 API 函数的上下文：</p><ul><li><p>如果从任务中调用 API 函数</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PREEMPTION</code> 设置为 1，那么在 API 函数中会自动切换到更高优先级的任务——所以在 API 函数退出之前。 这已经在图 43 中看到，其中写入定时器命令队列导致在写入命令队列的函数退出之前切换到 RTOS 守护任务。</p></li><li><p>如果从中断调用 API 函数</p><p>中断内不会自动切换到更高优先级的任务。 相反，设置了一个变量来通知应用程序编写者应该执行上下文切换。 中断安全 API 函数（以 “<code>FromISR</code>” 结尾的函数）有一个名为 <code>pxHigherPriorityTaskWoken</code> 的指针参数，用于此目的。</p><p>如果应该执行上下文切换，则中断安全 API 函数会将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。 为了能够检测到这种情况，<code>pxHigherPriorityTaskWoken</code> 指向的变量在第一次使用之前必须初始化为 <code>pdFALSE</code>。</p><p>如果应用程序编写者选择不从 ISR 请求上下文切换，则更高优先级的任务将保持就绪状态，直到调度程序下次运行——在最坏的情况下将在下一次滴答中断期间。</p><p>FreeRTOS API 函数只能将 <code>*pxHighPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。 如果一个 ISR 调用了多个 FreeRTOS API 函数，那么可以在每个 API 函数调用将同一个的变量作为 <code>pxHigherPriorityTaskWoken</code> 参数传递，并且只需要在第一次使用该变量之前初始化为 <code>pdFALSE</code>。</p></li></ul><p>上下文切换不会在 API 函数的中断安全版本中自动发生的原因有几个:</p><ol><li><p>避免不必要的上下文切换</p><p>在任务需要执行任何处理之前，中断可能会执行多次。 例如，考虑一个任务处理一个由中断驱动的 <code>UART</code> 接收到的字符串的场景； 每次接收到一个字符时，<code>UART ISR</code> 都切换到任务是一种浪费，因为任务只有在接收到完整字符串后才能执行。</p></li><li><p>控制执行顺序</p><p>中断可能偶尔发生，而且发生的时间不可预测。 专业的 FreeRTOS 用户可能希望暂时避免在其应用程序中的特定点不可预测地切换到不同的任务——尽管这也可以使用 FreeRTOS 调度程序锁定机制来实现。</p></li><li><p>可移植性</p><p>这是可以在所有FreeRTOS移植上使用的最简单的机制。</p></li><li><p>效率</p><p>面向较小处理器架构的移植仅允许在 ISR 的最后请求上下文切换，而消除该限制将需要额外且更复杂的代码。 它还允许在同一 ISR 内多次调用 FreeRTOS API 函数，而不会在同一 ISR 内生成多个上下文切换请求。</p></li><li><p>在 RTOS 滴答定时中断执行</p><p>正如本书后面将看到的，可以将应用程序代码添加到 RTOS 滴答中断中。 尝试在滴答中断内进行上下文切换的结果取决于正在使用的 FreeRTOS 移植。在最好的情况下，它只会导致不必要的调度程序调用。</p><p><code>pxHigherPriorityTaskWoken</code> 参数的使用是可选的。 如果不需要，则将 <code>pxHigherPriorityTaskWoken</code> 设置为 <code>NULL</code>。</p></li></ol><h3 id="portYIELD-FROM-ISR-和-portEND-SWITCHING-ISR-宏"><a href="#portYIELD-FROM-ISR-和-portEND-SWITCHING-ISR-宏" class="headerlink" title="portYIELD_FROM_ISR() 和 portEND_SWITCHING_ISR() 宏"></a>portYIELD_FROM_ISR() 和 portEND_SWITCHING_ISR() 宏</h3><p>本节介绍用于从 ISR 请求上下文切换的宏。 如果您尚未完全理解本节，请不要担心，因为后续章节提供了实际示例。</p><p><code>taskYIELD()</code> 是一个宏，可以在任务中调用以请求上下文切换。 <code>portYIELD_FROM_ISR()</code> 和 <code>portEND_SWITCHING_ISR()</code> 都是 <code>taskYIELD()</code> 的中断安全版本。 <code>portYIELD_FROM_ISR()</code> 和 <code>portEND_SWITCHING_ISR()</code> 都以同样的方式使用，并且做同样的事情[1]。 某些 FreeRTOS 移植仅提供两个宏之一。 较新的 FreeRTOS 移植提供这两种宏。本书中的示例使用 <code>portYIELD_FROM_ISR()</code>。</p><blockquote><p>[1] : 从历史上看，portEND_SWITCHING_ISR() 是要求中断处理程序使用汇编代码包装器的 FreeRTOS 移植中使用的名称，而 portYIELD_FROM_ISR() 是允许整个中断处理程序用 C 编写的 FreeRTOS 移植中使用的名称。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</code></pre><p>清单 87. <code>portEND_SWITCHING_ISR()</code> 宏</p><pre class=" language-lang-c"><code class="language-lang-c">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</code></pre><p>清单 88. <code>portYIELD_FROM_ISR()</code> 宏</p><p>从中断安全 API 函数传出的 <code>xHigherPriorityTaskWoken</code> 参数可以直接用作 <code>portYIELD_FROM_ISR()</code> 调用中的参数。</p><p>如果 <code>portYIELD_FROM_ISR()</code> <code>xHigherPriorityTaskWoken</code> 参数是 <code>pdFALSE(0)</code>，则不请求上下文切换，并且宏不起作用。 如果 <code>portYIELD_FROM_ISR()</code> <code>xHigherPriorityTaskWoken</code> 参数不是 <code>pdFALSE</code>，则请求上下文切换，并且处于运行状态的任务可能会更改。 中断将始终返回到处于运行状态的任务，即使在中断执行期间处于运行状态的任务发生了变化。</p><p>大多数 FreeRTOS 移植允许在 ISR 内的任何位置调用 <code>portYIELD_FROM_ISR()</code>。 一些 FreeRTOS 移植（主要用于较小的架构）仅允许在 ISR 的最后调用 <code>portYIELD_FROM_ISR()</code>。</p><h2 id="延迟中断处理"><a href="#延迟中断处理" class="headerlink" title="延迟中断处理"></a>延迟中断处理</h2><p>通常认为最佳实践是使 ISR 尽可能短。 其原因包括：</p><ul><li>即使已经为任务分配了非常高的优先级，它们也仅在硬件没有服务中断时运行。</li><li>ISR 可以中断（添加“抖动”）任务的开始时间和执行时间。</li><li>根据运行 FreeRTOS 的架构，在执行 ISR 时可能无法接受任何新中断，或至少无法接受新中断的子集。</li><li>应用程序编写者需要考虑并防范任务和 ISR 同时访问变量、外设和内存缓冲区等资源的后果。</li><li>一些 FreeRTOS 移植允许中断嵌套，但中断嵌套会增加复杂性并降低可预测性。中断越短，嵌套的可能性就越小。</li></ul><p>中断服务程序必须记录中断的原因，并清除中断。 中断所需的任何其他处理通常可以在任务中执行，从而允许中断服务程序尽可能快地退出。这称为 <code>"延迟中断处理"</code>，因为中断所需的处理被从 ISR “延迟” 到任务。</p><p>将中断处理延迟到任务还允许应用程序编写者相对于应用程序中的其他任务确定处理的优先级，并使用所有 FreeRTOS API 函数。</p><p>如果中断处理延迟到的任务的优先级高于任何其他任务的优先级，则处理将立即执行，就像在 ISR 本身中执行处理一样。 这种情况如图 48 所示，其中任务 1 是一个正常的应用程序任务，任务 2 是中断处理被延迟到的任务。</p><p><img src="image-20240401105637107.png" alt="图 48 在高优先级任务中完成中断处理"></p><p>在图 48 中，中断处理从 t2 时刻开始，实际上在 t4 时刻有效地结束，但只有 t2 和 t3 时刻之间的时间段用于 ISR。 如果未使用延迟中断处理，则时间 t2 和 t4 之间的整个时间段都将花费在 ISR 中。</p><p>对于何时最好执行 ISR 中的中断所需的所有处理，以及何时最好将部分处理延迟到任务，没有绝对的规则。在以下情况下，将处理延迟到任务最有用 :</p><ul><li>中断所必需的处理不是微不足道的。 例如，如果中断只是存储模数转换的结果，那么几乎可以肯定这最好在 ISR 内部执行，但如果转换结果还必须通过软件过滤器，那么可能最好是在任务中执行过滤器。</li><li>中断处理可以方便地执行无法在 ISR 内部执行的操作，例如写入控制台或分配内存。</li><li>中断处理不是确定性的——这意味着事先不知道处理将要花费多长时间。</li></ul><p>以下各节描述并演示了本章到目前为止介绍的概念，包括可用于实现延迟中断处理的 FreeRTOS 功能。</p><h2 id="用于同步的二进制信号量"><a href="#用于同步的二进制信号量" class="headerlink" title="用于同步的二进制信号量"></a>用于同步的二进制信号量</h2><p>二进制信号量 API 的中断安全版本可以用于在每次特定中断发生时解除任务阻塞，从而有效地将任务与中断同步。这允许大部分中断事件处理在同步任务中实现，只有非常快和短的部分直接留在ISR中。如前一节所述，二进制信号量用于将中断处理 “延迟” 到任务[1]。</p><blockquote><p>[1] 任务：使用直接到任务的通知将一个任务从中断中解禁，比使用二进制信号量更有效率。直接到任务的通知在第9章 “任务通知 “中才会涉及。</p></blockquote><p>正如之前在图 48 中所展示的，如果中断处理是特别时间关键的，则可以设置延迟处理任务的优先级，以确保该任务总是抢占系统中的其他任务。然后可以实现 ISR 以包含对 <code>portYIELD_FROM_ISR()</code> 的调用，确保 ISR 直接返回到中断处理被延迟到的任务。这样做的效果是确保整个事件处理在在时间上连续执行 ( 没有中断 )，就好像它全部在ISR本身内实现一样。图 49 重复了图 48 中的场景，但是更新了文本以描述如何使用信号量来控制延迟处理任务的执行。</p><p><img src="image-20240401132340213.png" alt="图 49 使用二进制信号量实现延迟中断处理"></p><p>延迟处理任务使用对信号量的阻塞 <code>"take"</code> 调用作为进入阻塞状态以等待事件发生的方法。当事件发生时，ISR 对同一信号量使用 <code>"give"</code> 操作来解锁任务，以便继续进行所需的事件处理。</p><p><code>"Taking a semaphore (获取信号量)"</code> 和 <code>"giving a semaphore (给出信号量)"</code> 是根据其使用场景具有不同含义的概念。在这种中断同步场景中，二进制信号量在概念上可以被视为长度为 1 的队列。队列在任何时候最多可以包含一项，因此始终要么为空，要么为满（因此是二进制）。通过调用 <code>xSemaphoreTake()</code>，中断处理被延迟到的任务有效地试图用一个阻塞时间从队列中读取数据，从而导致任务在队列为空时进入阻塞状态。当事件发生时，ISR 使用 <code>xSemaphoreGiveFromISR()</code> 函数将一个令牌（信号量）放入队列中，使队列变满。这将导致任务退出阻塞状态并移除令牌，使队列再次为空。当任务完成其处理后，它会再次尝试从队列中读取，并发现队列为空，然后重新进入阻塞状态以等待下一个事件。图 50 演示了这个序列。</p><p>图 50 显示了中断 <code>"giving (给出)"</code> 信号量，即使它没有首先 <code>"taking (获取)"</code> 信号量，以及任务 <code>"taking (获取)"</code> 信号量，但从未将其给出 (giving it back)。这就是为什么该场景被描述为在概念上类似于向队列写入和从队列读取的原因。它经常会引起混乱，因为它不遵循与其他信号量使用场景相同的规则，在其他信号量使用场景中，获取 (takes) 信号量的任务必须始终将其给出 (give it back)，例如第 7 章 “资源管理” 中描述的场景。</p><p><img src="Chapter 6 中断管理/image-20240401141329400.png" alt="图 50 使用二进制信号量使任务与中断同步" style="zoom:67%;"></p><h3 id="xSemaphoreCreateBinary-API函数"><a href="#xSemaphoreCreateBinary-API函数" class="headerlink" title="xSemaphoreCreateBinary() API函数"></a>xSemaphoreCreateBinary() API函数</h3><p>FreeRTOS V9.0.0 还包括 <code>xSemaphoreCreateBinaryStatic()</code> 函数，该函数在编译时静态地分配创建二进制信号量所需的内存 : 所有各种类型的 FreeRTOS 信号量的句柄都存储在 <code>SemaphoreHandle_t</code> 类型的变量中。</p><p>在使用信号量之前，必须先创建它。要创建一个二进制信号量，请使用 <code>xSemaphoreCreateBinary()</code> API 函数 [1]。</p><blockquote><p>[1] : 一些信号量 API 函数实际上是宏，而不是函数。为简单起见，在本书中，它们都被称为函数。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">SemaphoreHandle_t xSemaphoreCreateBinary( void );</code></pre><p>清单 89. <code>xSemaphoreCreateBinary()</code> API 函数原型</p><p>表 33. <code>xSemaphoreCreateBinary()</code> 的返回值</p><div class="table-container"><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>如果返回的是 <code>NULL</code>，则无法创建信号量，因为没有足够的堆内存可供FreeRTOS分配给信号量数据结构。<br>如果返回的值不是<code>NULL</code>，则表明该信号已被成功创建。返回值应存储为创建的信号量的句柄。</td></tr></tbody></table></div><h3 id="xSemaphoreTake-API函数"><a href="#xSemaphoreTake-API函数" class="headerlink" title="xSemaphoreTake() API函数"></a>xSemaphoreTake() API函数</h3><p> <code>"Taking (获取)"</code> 信号量意味着 <code>"obtain (获得)"</code> 或 <code>receive (接收)</code> 信号量。仅当信号量可用时才可以获取该信号量。</p><p>所有不同类型的 FreeRTOS 信号量，除了递归互斥锁，都可以使用 <code>xSemaphoreTake()</code> 函数。</p><p><code>xSemaphoreTake()</code> 不能从一个中断服务例程中使用。</p><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );</code></pre><p>清单 90. <code>xSemaphoreTake()</code> 的 API 函数原型</p><p>表 34. <code>xSemaphoreTake()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>被 <code>"taking (获取)"</code> 的信号量。<br>信号量由 <code>SemaphoreHandle_t</code> 类型的变量引用。必须先显式创建它，然后才能使用它。</td></tr><tr><td><code>xTicksToWait</code></td><td>如果信号量尚不可用，任务应保持在阻塞状态以等待信号量的最长时间。<br>如果<code>xTicksToWait</code> 为 0，那么如果信号量不可用，<code>xSemaphoreTake()</code> 将立即返回。<br>阻塞时间是以滴答周期指定的，因此它表示的绝对时间取决于滴答频率。宏pdMS_TO_TICKS() 可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。<br>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>INCLUDE_vTaskSuspend</code> 设置为 1，则将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致任务无限期等待 ( 没有超时期限 )。</td></tr><tr><td>返回值</td><td>有两个可能的返回值：<br>1. <code>pdPASS</code><br>仅当调用 <code>xSemaphoreTake()</code> 成功获取信号量时才返回 <code>pdPASS</code>。<br>如果指定了阻塞时间（<code>xTicksToWait</code> 不是 0 ），则调用任务可能被置于阻塞状态以等待信号量 (如果信号量不是立即可用)，但信号量在阻止时间到期之前变为可用。<br>2. <code>pdFALSE</code><br>信号量不可用。<br>如果指定了阻塞时间（<code>xTicksToWait</code> 不是0），则调用任务将被置于阻塞状态以等待信号量变为可用，但阻塞时间在此之前已过期。&lt;/p&gt;</td></tr></tbody></table></div><h3 id="xSemaphoreGiveFromISR-API函数"><a href="#xSemaphoreGiveFromISR-API函数" class="headerlink" title="xSemaphoreGiveFromISR() API函数"></a>xSemaphoreGiveFromISR() API函数</h3><p>可以使用<code>xSemaphoreGiveFromISR()</code>函数 <code>"giving (给出)"</code> 二进制和计数信号量。</p><blockquote><p>计数信号量将在本书后面的章节中介绍。</p></blockquote><p><code>xSemaphoreGiveFromISR()</code> 是 <code>xSemaphoreGive()</code> 的中断安全版本，所以具有 <code>pxHigherPriorityTaskWoken</code> 参数，这在本章开始时已经描述过。</p><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore,                                  BaseType_t *pxHigherPriorityTaskWoken );</code></pre><p>清单91. <code>xSemaphoreGiveFromISR()</code> API 函数原型</p><p>表35. <code>xSemaphoreGiveFromISR()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>将要被 <code>"给出"</code> 的信号量。<br>一个信号量是由一个类型为 <code>SemaphoreHandle_t</code> 的变量来引用的，并且必须在使用前显式创建。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td>单个信号量可能会阻塞一个或多个任务，等待信号量可用。调用 <code>xSemaphoreGiveFromISR()</code> 可以使信号量可用，从而使等待信号量的任务离开阻塞状态。如果调用 <code>xSemaphoreGiveFromISR()</code> 导致一个任务离开阻塞状态，并且未阻塞任务的优先级高于当前正在执行的任务 (被中断的任务)，那么，在内部，<code>xSemaphoreGiveFromISR()</code> 将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。<br>如果 <code>xSemaphoreGiveFromISR()</code> 把这个值设置为  <code>pdTRUE</code>。则通常应在退出中断之前执行上下文切换。这将确保中断直接返回到最高优先级就绪状态任务。</td></tr><tr><td>返回值</td><td>有两个可能的返回值：<br>1. <code>pdPASS</code><br>只有当对 <code>xSemaphoreGiveFromISR()</code> 的调用成功时，才会返回 <code>pdPASS</code>。<br>2. <code>pdFAIL</code><br>如果信号量已经可用，则不能被 <code>"给出"</code>，并且 <code>xSemaphoreGiveFromISR()</code> 将返回 <code>pdFAIL</code>。&lt;/p&gt;</td></tr></tbody></table></div><h3 id="示例-16-使用二进制信号量使一个任务与中断同步"><a href="#示例-16-使用二进制信号量使一个任务与中断同步" class="headerlink" title="示例 16. 使用二进制信号量使一个任务与中断同步"></a>示例 16. 使用二进制信号量使一个任务与中断同步</h3><p>此示例使用二进制信号量从中断服务例程中取消阻阻塞任务 —- 有效地将任务与中断同步。</p><p>一个简单的周期性任务被用来每 500 毫秒产生一次软件中断。一个软件中断是为了方便而使用的，由于在某些目标环境中挂钩到真实中断的复杂性，因此使用软件中断是为了方便。清单 92 显示了周期性任务的实现。请注意，该任务在生成中断之前和之后都打印出一个字符串。这允许在执行示例时产生的输出中观察执行顺序。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 本例中使用的软件中断的编号。显示的代码来自 Windows 工程，其中数字0到2是由 FreeRTOS Windows 移植本身使用的，所以 3 是应用程序可用的第一个数字。*/#define mainINTERRUPT_NUMBER 3static void vPeriodicTask( void *pvParameters ){    const TickType_t xDelay500ms = pdMS_TO_TICKS(500UL);         /* 和大多数任务一样，这个任务是在一个无限循环中实现的。*/         for( ;; )         {             /* 阻塞直到再次产生软件中断。*/              vTaskDelay( xDelay500ms );             /* 生成中断，在中断产生前后打印信息。这样就可以从输出中看出执行的顺序。             用于生成软件中断的语法取决于所使用的 FreeRTOS 移植。下面使用的语法只能用于             FreeRTOS Windows 移植，在该移植中，这种中断只是模拟的。*/              vPrintString( "Periodic task - About to generate an interrupt.\r\n" );              vPortGenerateSimulatedInterrupt( mainINTERRUPT_NUMBER );              vPrintString( "Periodic task - Interrupt generated.\r\n\r\n\r\n" );         } }</code></pre><p>清单 92. 示例 16 中周期性生成软件中断的任务的实现</p><p>清单 93 显示了中断处理被延迟到的任务的实现 —— 通过使用二进制信号量与软件中断同步的任务。同样，在任务的每次迭代中都会打印出一个字符串，因此从执行示例时产生的输出中可以明显看出任务和中断执行的顺序。</p><p>需要注意的是，虽然清单 93 中所示的代码足够满足由软件生成中断的示例 16 ，但它不足以满足由硬件外设生成中断的场景。</p><pre class=" language-lang-c"><code class="language-lang-c">static void vHandlerTask( void *pvParameters ){    /* 和大多数任务一样，这个任务是在一个无限循环中实现的。 */    for (;;)    {        /* 使用信号量来等待事件。信号量是在调度程序启动之前创建的，        因此在此任务第一次运行之前。任务无限期地阻塞，        这意味着这个函数调用只会在成功获得信号量后返回——        所以不需要检查 xSemaphoreTake() 返回的值。*/        xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);        /* 要到达这里，这个事件必须已经发生。处理该事件 (在本例中，只是打印出一条信息)。 */        vPrintString("Handler task - Processing event.\r\n");    }}</code></pre><p>清单 93. 示例 16 中延迟中断处理的任务 (与中断同步的任务) 的实现。</p><p>清单 94 显示了 ISR 。除了 <code>"给出"</code> 信号量以取消阻塞中断处理被延迟到的任务之外，几乎没有什么作用。</p><p>注意 <code>xHigherPriorityTaskWoken</code> 变量是如何被使用的。在调用 <code>xSemaphoreGiveFromISR()</code> 之前，它被设置为 <code>pdFALSE</code> ，然后在调用 <code>portYIELD_FROM_ISR()</code> 时作为参数使用。如果 <code>xHigherPriorityTaskWoken</code> 等于 <code>pdTRUE</code>，则将在 <code>portYIELD_FROM_ISR()</code> 宏请求上下文切换。</p><p>ISR 的原型和用于强制上下文切换的宏，对于FreeRTOS Windows 移植都是正确的，对于其他 FreeRTOS 移植可能有所不同。请参阅 www.example.com 网站上的移植特定文档页面，以及 FreeRTOS 下载中提供的示例，以查找您正在使用的移植所需的语法。</p><p>与运行 FreeRTOS 的大多数架构不同，FreeRTOS 的 Windows 移植需要一个 ISR 来返回一个值。与 Windows 移植一起提供的 <code>portYIELD_FROM_ISR()</code> 宏的实现包括 return 语句，因此清单 94 没有显示显式返回的值。</p><pre class=" language-lang-c"><code class="language-lang-c">static uint32_t ulExampleInterruptHandler(void){    BaseType_t xHigherPriorityTaskWoken;    /* xHigherPriorityTaskWoken参数必须被初始化为pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为 pdTRUE。 */    xHigherPriorityTaskWoken = pdFALSE;    /* “给出” semaphore以解除对任务的阻塞，将 xHigherPriorityTaskWoken     的地址作为中断安全API函数的参数 pxHigherPriorityTaskWoken 传入。 */    xSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken);  /* 将 xHigherPriorityTaskWoken 的值传给 portYIELD_FROM_ISR()。  如果 xHigherPriorityTaskWoken 在 xSemaphoreGiveFromISR() 中被设置为 pdTRUE，  那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。  如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，  那么调用 portYIELD_FROM_ISR() 将没有任何影响。  与大多数 FreeRTOS 移植不同， Windows 移植要求 ISR 返回一个值 ——  return 语句在 Windows 版本的 portYIELD_FROM_ISR() 中。*/    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);}</code></pre><p>清单 94. 示例 16 中使用的软件中断的 ISR</p><p><code>main()</code> 函数创建二进制信号量，创建任务，安装中断处理 ( interrupt handler ) 程序。并启动调度程序。实现如清单 95 所示。</p><p>为安装中断处理程序而调用的函数的语法特定于 FreeRTOS Windows 移植，对于其他 FreeRTOS 移植可能有所不同。请参考 FreeRTOS.org 网站上的特定移植文档页面，以及 FreeRTOS 下载中提供的示例，以找到你正在使用的移植所需的语法。</p><pre class=" language-lang-c"><code class="language-lang-c">int main(void){    /* 在使用 semaphore 之前，必须显示地创建它。在这个例子中，我们创建了一个 binary semaphore。 */    xBinarySemaphore = xSemaphoreCreateBinary();    /* 检查 semaphore 是否成功创建。*/    if (xBinarySemaphore != NULL)    {        /* 创建 "处理(handler)"任务，该任务是中断处理被延迟到的任务。        这是将与中断同步的任务。处理任务是以高优先级创建的，        以确保它在中断退出后立即运行。        在这种情况下，我们选择了优先级 3 。 */        xTaskCreate(vHandlerTask, "Handler", 1000, NULL, 3, NULL);        /* 创建将定期生成软件中断的任务。这个任务的优先级低于处理任务，        以确保每次处理任务退出阻塞状态时它将被抢占。 */        xTaskCreate(vPeriodicTask, "Periodic", 1000, NULL, 1, NULL);        /* 安装软件中断的处理程序。这样做所需的语法取决于正在使用的FreeRTOS移植。        这里显示的语法只能用于 FreeRTOS windows 移植，在那里这种中断只是模拟的。 */        vPortSetInterruptHandler(mainINTERRUPT_NUMBER, ulExampleInterruptHandler);        /* 启动调度器，使创建的任务开始执行。 */        vTaskStartScheduler();    }    /* 正常情况下，绝对不能达到下面这一行。 */    for (;;);}</code></pre><p>清单 95. 示例 16 中 <code>main()</code> 的实现</p><p>示例 16 产生的输出如图 51 所示。正如预期的那样，<code>vHandlerTask()</code> 在中断产生后立即进入了运行状态，因此任务的输出会拆分周期性任务产生的输出。在图52中提供了进一步的解释。</p><p><img src="image-20240408200251795.png" alt="图 51. 执行示例 16 时产生的输出"></p><p><img src="image-20240408200543993.png" alt="图 52. 执行例 16 时的执行顺序"></p><h3 id="改进示例16中使用的任务的实现"><a href="#改进示例16中使用的任务的实现" class="headerlink" title="改进示例16中使用的任务的实现"></a>改进示例16中使用的任务的实现</h3><p>示例 16 使用一个二进制信号量来同步一个任务和一个中断。其执行顺序如下：</p><ol><li>中断发生了。</li><li>ISR 执行并 <code>"给出"</code> 信号量以解除对任务的阻塞。</li><li>任务在 ISR 之后立即执行，并 <code>"获取"</code> 了信号量。</li><li>任务处理了该事件，然后试图再次 <code>"获取"</code> 信号量——进入阻塞状态，因为信号量还不可用（另一个中断还没有发生）。</li></ol><p>示例 16 中使用的任务的结构仅在中断以相对低的频率发生时是适当的。要理解其中的原因，我们可以考虑一下，如果在任务完成对第一个中断的处理之前，又发生了第二个、第三个中断，会发生什么：</p><ul><li>当第二个 ISR 执行时，信号量将为空，所以 ISR 将 <code>"给出"</code> 信号量，并且任务将在完成处理第一个事件之后立即处理第二个事件。该场景如图 53 所示。</li><li>当第三个 ISR 执行时，信号量已经可用，防止ISR再次给出信号量，所以任务不会知道第三个事件已经发生。这种情况在图54中显示。</li></ul><p><img src="Chapter 6 中断管理/image-20240408204641581.png" alt="图 53. 在任务处理完第一个事件之前发生一个中断时的情景" style="zoom:67%;"></p><p><img src="Chapter 6 中断管理/image-20240408205305113.png" alt="图 54. 在任务处理完第一个事件之前发生两个中断时的情景" style="zoom:67%;"></p><p>示例 16 中使用的延迟中断处理任务（如清单 93 所示）被构建为在每次调用 <code>xSemaphoreTake()</code> 之间仅处理一个事件。这对于示例 16 来说已经足够了，因为生成事件的中断是由软件触发的，并且发生在可预测的时间。在实际应用中，中断是由硬件产生的，并且发生的时间是不可预测的。因此，为了最大限度地减少错过中断的机会，必须构建延迟中断处理任务，以便它处理每次调用 <code>xSemaphoreTake()</code> 之间已经可用的所有事件 [1]。清单 96 对此进行了演示，其中展示了如何构建 UART 的延迟中断处理程序。在清单 96 中，假设 UART 在每次接收到字符时生成接收中断，并且 UART 将接收到的字符放入硬件 FIFO ( 硬件缓冲区 ) 中。</p><blockquote><p> [1] 事件：或者，也可以使用计数信号量或直接到任务的通知来对事件进行计数。计数信号量将在下一节中描述。第 9 章 “任务通知” 中描述了直接到任务的通知。直接到任务的通知是首选方法，因为它们在运行时间和 RAM 使用方面都是最有效率的。</p></blockquote><p>示例 16 中使用的延迟中断处理任务还有一个弱点；它在调用 <code>xSemaphoreTake()</code> 时没有使用超时。相反，该任务将 <code>portMAX_DELAY</code> 作为 <code>xSemaphoreTake()</code> 的 <code>xTicksToWait</code> 参数传递，这会导致任务无限期地等待 ( 没有超时期限 ) 信号量可用。无限期超时经常被用在示例代码中，因为它们的使用简化了示例的结构，从而使示例更易于理解。然而，在实际应用中，无限期超时通常是不好的做法，因为它们使得从错误中恢复变得困难。例如，考虑这样的场景：任务正在等待中断以提供信号量，但硬件中的错误状态阻止中断产生 ：</p><ul><li>如果任务在没有超时的情况下等待，它将不知道错误状态，并将永远等待。</li><li>如果任务在等待时有超时，则 <code>xSemaphoreTake()</code>  将在超时到期时返回 <code>pdFAIL</code> ，然后任务可以在下次执行时检测并清除错误。清单 96 也演示了这个场景。</li></ul><pre class=" language-lang-c"><code class="language-lang-c">static void vUARTReceiveHandlerTask(void *pvParameters){    /* xMaxExpectedBlockTime 保存两个中断之间预期的最大时间。 */    const TickType_t xMaxExpectedBlockTime = pdMS_TO_TICKS(500);    /* 和大多数任务一样，这个任务是在一个无限循环中实现的。 */    for (;;)    {        /* semaphore 由 UART 的接收(Rx)中断 "给出"。        等待下一个中断的时间最多为 xMaxExpectedBlockTime 个滴答。*/        if (xSemaphoreTake(xBinarySemaphore, xMaxExpectedBlockTime) == pdPASS)        {            /* 获得了 semaphore 。在再次调用 xSemaphoreTake() 之前，            处理所有挂起的 Rx 事件。每个 Rx 事件都会在UART 的接收FIFO中放置一个字符，            并且假定 UART_RxCount() 返回 FIFO 中的字符数。*/            while (UART_RxCount() > 0)            {                /* 假设 UART_ProcessNextRxEvent() 处理一个Rx字符，                将 FIFO 中的字符数减少 1 。 */                UART_ProcessNextRxEvent();            }            /* 没有更多挂起的 Rx 事件(FIFO 中没有更多的字符)，            所以循环返回并调用 xSemaphoreTake() 以等待下一个中断。            在代码的这一点与调用 xSemaphoreTake() 之间发生的任何中断            都将被锁在 semaphore 中，所以不会丢失。 */        }        else        {            /* 在预期时间内未收到事件。检查并在必要时清除 UART 中            可能阻止 UART 生成更多中断的任何错误条件。 */            UART_ClearErrors();        }    }}</code></pre><p>清单 96. 推荐的延迟中断处理任务的构建，以 UART 接收处理程序为例</p><h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p>正如二进制信号量可以被认为是长度为 1 的队列一样，计数信号量可以被认为是长度大于 1 的队列。任务对存储在队列中的数据不感兴趣，只对队列中的项目数量感兴趣。<code>FreeRTOSConfig.h</code> 中的 <code>configUSE_COUNTING_SEMAPHORES</code>必须设置为 1 ，以使计数信号量可用 。</p><p>每次 <code>"给出"</code> 计数信号量时，都会使用其队列中的另一个空间。队列中的项目数是信号量的 <code>"计数(count)"</code> 值。</p><ol><li><p>计数事件 [1]</p><p>在这种情况下，事件处理程序将在每次事件发生时 <code>"给出"</code> 一个信号量，从而导致信号量的计数值在每次 <code>"给出"</code> 时递增。任务每次处理事件时都会 <code>"获取"</code> 一个信号量，从而导致信号量的计数值在每次  <code>"获取"</code>  时递减。计数值是已发生的事件数与已处理的事件数之间的差值。该机制如图 55 所示。</p><p>创建用于对事件进行计数的计数信号量时，其初始计数值为 0 。</p></li></ol><blockquote><p>[1] 使用直接到任务的通知来计数事件比使用计数信号量更有效。 直到第 9 章才介绍直接到任务的通知。</p></blockquote><ol><li><p>资源管理</p><p>在这种情况下，计数值指示可用资源的数量。为了获得对资源的控制，任务必须首先获得信号量——减少信号量的计数值。当计数值达到 0 时，表示没有空闲资源。当任务完成资源使用时，它会归还信号量——增加信号量的计数值。</p><p>创建用于管理资源的计数信号量，使其初始计数值等于可用资源的数量。第 7 章介绍了如何使用信号量管理资源。</p></li></ol><p><img src="Chapter 6 中断管理/image-20240409011504838.png" alt="图 55. 使用一个计数信号量来 '计数' 事件" style="zoom:67%;"></p><h3 id="xSemaphoreCreateCounting-API函数"><a href="#xSemaphoreCreateCounting-API函数" class="headerlink" title="xSemaphoreCreateCounting() API函数"></a>xSemaphoreCreateCounting() API函数</h3><p>FreeRTOS V9.0.0还包括 <code>xSemaphoreCreateCountingStatic()</code> 函数，该函数在编译时静态地分配创建计数信号量所需的内存 : 所有不同类型的 FreeRTOS 信号量的句柄都存储在 <code>SemaphoreHandle_t</code> 类型的变量中。</p><p>在使用信号量之前，必须先创建它。要创建一个计数信号量，请使用 <code>xSemaphoreCreateCounting()</code> API 函数。</p><pre class=" language-lang-c"><code class="language-lang-c">SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount,                                            UBaseType_t uxInitialCount );</code></pre><p>清单97. <code>xSemaphoreCreateCounting()</code> API 函数原型</p><p>表36. <code>xSemaphoreCreateCounting()</code> 的参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>uxMaxCount</code></td><td>信号量将计数到的最大值。继续用队列来比喻，<code>uxMaxCount</code> 值实际上就是队列的长度。<br>当信号量用于计数或锁存事件时，<code>uxMaxCount</code> 是可以锁存的最大事件数。<br>当信号量用于管理对资源集合的访问时，<code>uxMaxCount</code> 应设置为可用资源的总数。</td></tr><tr><td><code>uxInitialCount</code></td><td>信号量创建后的初始计数值。<br>当信号量用于计数或锁存事件时，<code>uxInitialCount</code>应设置为 0 ——因为据推测，当创建信号量时，还没有事件发生。<br>当信号量用于管理对资源集合的访问时，<code>uxInitialCount</code> 应设置为等于 <code>uxMaxCount</code> ，因为据推测，当创建信号量时，所有的资源都是可用的。</td></tr><tr><td>返回值</td><td>如果返回 <code>NULL</code> ，则无法创建信号量，因为没有足够的堆内存可供 FreeRTOS 分配信号量的数据结构。第 2 章提供了更多关于堆内存管理的信息。<br>返回非 <code>NULL</code> 值表示已经成功创建了信号量。返回值应存储为创建的信号量的句柄。</td></tr></tbody></table></div><h3 id="例-17-使用计数信号量将任务与中断同步"><a href="#例-17-使用计数信号量将任务与中断同步" class="headerlink" title="例 17. 使用计数信号量将任务与中断同步"></a>例 17. 使用计数信号量将任务与中断同步</h3><p>示例 17 通过使用计数信号量代替二进制信号量来改进示例 16 的实现。<code>main()</code> 被修改为包含一个对 <code>xSemaphoreCreateCounting()</code> 的调用，以代替对 <code>xSemaphoreCreateBinary()</code> 的调用。新的 API 调用如清单 98 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 在使用semaphore之前，必须显式创建它。在这个例子中，一个 counting semaphore 被创建。创建的 semaphore 的最大计数值为 10，初始计数值为0。 */xCountingSemaphore = xSemaphoreCreateCounting(10, 0);</code></pre><p>清单 98. 示例 17 中用于创建计数信号量的 <code>xSemaphoreCreateCounting()</code> 调用</p><p>为了模拟高频率发生的多个事件，中断服务例程被改变为在每个中断中 <code>"给出"</code> 信号量不止一次。每个事件都被锁存在信号量的计数值中。修改后的中断服务例程如清单 99 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static uint32_t ulExampleInterruptHandler(void){    BaseType_t xHigherPriorityTaskWoken;    /* xHigherPriorityTaskWoken 参数必须被初始化为 pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为pdTRUE。 */    xHigherPriorityTaskWoken = pdFALSE;    /* 多次 "给出" semaphore 。第一次将解除对延迟的中断处理任务的阻塞，    接下来的 "给出 "是为了证明 semaphore 锁存事件，    以允许中断延迟到的任务依次处理它们，而不会丢失事件。    这模拟了处理器接收到的多个中断，即使在这种情况下，事件是在单个中断发生内模拟的。 */    xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);    xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);    xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);    /* 将 xHigherPriorityTaskWoken 的值传给portYIELD_FROM_ISR()。    如果 xHigherPriorityTaskWoken 在 xSemaphoreGiveFromISR() 中被设置为pdTRUE，    那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE ，    那么调用 portYIELD_FROM_ISR() 将没有任何影响。    与大多数 FreeRTOS 移植不同， Windows 移植要求 ISR 返回一个值——    return 语句在 Windows 版本的 portYIELD_FROM_ISR() 中。 */    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);}</code></pre><p>清单 99. 示例 17 所使用的中断服务例程的实现</p><p>所有其他的函数与示例 16 中使用的函数相比都没有修改。</p><p>示例 17 执行时产生的输出如图 56 所示。可以看出，在每次产生中断时，中断处理被推迟到的任务会处理所有三个 [模拟] 事件。这些事件被锁存在信号的计数值中，允许任务依次处理它们。</p><p><img src="image-20240409130405568.png" alt="图 56. 执行示例 17 时产生的输出"></p><h2 id="延迟工作到-RTOS-守护进程任务"><a href="#延迟工作到-RTOS-守护进程任务" class="headerlink" title="延迟工作到 RTOS 守护进程任务"></a>延迟工作到 RTOS 守护进程任务</h2><p>到目前为止，所介绍的延迟中断处理的示例都要求应用程序编写者为每个使用延迟处理技术的中断创建一个任务。还可以使用 <code>xTimerPendFunctionCallFromISR()</code> [1] API 函数将中断处理延迟到 RTOS 守护进程任务 (daemon task) 中 —— 无需为每个中断创建一个单独的任务。将中断处理延迟到守护任务被称为 <code>"集中延迟中断处理"</code> 。</p><blockquote><p>[1] xTimerPendFunctionCallFromISR()：在第 5 章中指出，守护进程任务最初被称为定时器服务任务，因为它最初只用来执行软件定时器回调函数。因此，<code>xTimerPendFunctionCall()</code> 是在 <code>timers.c</code> 中实现的，并且根据以实现函数的文件的名称为前缀的惯例，函数的名称以 <code>"Timer"</code> 为前缀。</p></blockquote><p>第 5 章描述了与软件定时器相关的 FreeRTOS API 函数如何将命令发送到定时器命令队列上的守护进程任务。 <code>xTimerPendFunctionCall()</code>  和 <code>xTimerPendFunctionCallFromISR()</code> API 函数使用相同的定时器命令队列向守护进程任务发送 <code>"execute function (执行函数) "</code>命令。然后，发送到守护进程任务的函数在守护进程任务的上下文中被执行。</p><p>集中延迟中断处理的优点包括 ：</p><ul><li><p>较低的资源使用量</p><p>它消除了为每个延迟中断创建一个单独任务的需要。</p></li><li><p>简化的用户模型</p><p>延迟中断处理函数是标准 C 函数。</p></li></ul><p>集中式延时中断处理的缺点包括：</p><ul><li><p>灵活性较低</p><p>不可能单独设置每个延迟中断处理任务的优先级。每个延迟中断处理函数以守护进程任务的优先级执行。如第5章所述，守护进程任务的优先级由 <code>FreeRTOSConfig.h</code> 中的 <code>configTIMER_TASK_PRIORITY</code> 编译时配置常量设置。</p></li><li><p>较低的确定性</p><blockquote><p>英语原文是 Less determinism ，determinism —— 决定论（认为一切事物具有不以人的意志为转移的必然性）。结合下文， Less determinism 的意思应该是 : 当我们使用守护进程任务来延迟中断处理时，守护进程任务可能还同时用于处理软件定时器命令，这会导致中断处理的时间的确定性下降 ( 我猜的 )</p></blockquote><p><code>xTimerPendFunctionCallFromISR()</code> 将一个命令发送到定时器命令队列的尾部。在 <code>xTimerPendFunctionCallFromISR()</code> 将 <code>"execute function (执行函数)"</code> 命令发送到队列之前，守护进程任务将处理定时器命令队列中已有的命令。</p></li></ul><p>不同的中断有不同的时序约束，因此通常在同一应用程序中使用两种延迟中断处理的方法。</p><h3 id="xTimerPendFunctionCallFromISR-API-函数"><a href="#xTimerPendFunctionCallFromISR-API-函数" class="headerlink" title="xTimerPendFunctionCallFromISR() API 函数"></a>xTimerPendFunctionCallFromISR() API 函数</h3><p><code>xTimerPendFunctionCallFromISR()</code> 是 <code>xTimerPendFunctionCall()</code> 的中断安全版本。这两个 API 函数都允许由应用程序编写者提供的函数由 RTOS 守护进程任务执行，因此在 RTOS 守护进程任务的上下文中执行。要执行的函数以及函数输入参数的值都被发送到计时器命令队列上的守护进程任务。因此，该函数实际执行的时间取决于守护程序任务相对于应用程序中其他任务的优先级。</p><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xTimerPendFunctionCallFromISR(     PendedFunction_t xFunctionToPend,                                            void *pvParameter1,                                             uint32_t ulParameter2,                                            BaseType_t *pxHigherPriorityTaskWoken );</code></pre><p>清单 100.  <code>xTimerPendFunctionCallFromISR()</code> API 函数原型</p><pre class=" language-lang-c"><code class="language-lang-c">void vPendableFunction( void *pvParameter1, uint32_t ulParameter2 );</code></pre><p>清单101. <code>xTimerPendFunctionCallFromISR()</code> 的 <code>xFunctionToPend</code> 参数中传递的函数必须符合的原型。</p><p>表37.  <code>xTimerPendFunctionCallFromISR()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xFunctionToPend</code></td><td>指向将在守护进程任务中执行的函数的指针 (实际上，就是函数名称 ) 。函数的原型必须与清单 101所示的相同。</td></tr><tr><td><code>pvParameter1</code></td><td>将被传递到由守护任务执行的函数中的值，作为该函数的 <code>pvParameter1</code> 参数。参数具有 void <em> 类型，以允许它用于传递任何数据类型。例如，整数类型可以直接转换为 void </em>，或者，void *可以用来指向一个结构。</td></tr><tr><td><code>ulParameter2</code></td><td>将被传递到由守护任务执行的函数中的值，作为该函数的 <code>ulParameter2</code> 参数。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td><code>xTimerPendFunctionCallFromISR()</code> 写入定时器命令队列。如果 RTOS 守护进程任务处于阻塞状态以等待定时器命令队列上的数据可用，那么写入定时器命令队列将使守护进程任务离开阻塞状态。如果守护进程任务的优先级高于当前正在执行的任务 ( 被中断的任务 ) 的优先级，那么在内部，<code>xTimerPendFunctionCallFromISR()</code> 将把 <code>*pxHigherPriorityTaskWoken</code> 设为 <code>pdTRUE</code>。<br>如果 <code>xTimerPendFunctionCallFromISR()</code> 将此值设置为 <code>pdTRUE</code>，那么在退出中断之前必须进行上下文切换。这将确保中断直接返回到守护进程任务，因为守护进程任务将是最高优先级的就绪状态任务。</td></tr><tr><td>返回值</td><td><p>有两个可能的返回值：<br>1. `pdPASS`<br>如果 `"execute function"` 命令被写入定时器命令队列，则将返回 `pdPASS`。<br>2. `pdFAIL`<br>如果由于定时器命令队列已满而无法将 `"execute function"` 命令写入定时器命令队列，则将返回 `pdFAIL`。第 5 章介绍了如何设置定时器命令队列的长度。</p></td></tr></tbody></table></div><h3 id="示例-18-集中的延迟中断处理"><a href="#示例-18-集中的延迟中断处理" class="headerlink" title="示例 18. 集中的延迟中断处理"></a>示例 18. 集中的延迟中断处理</h3><p>示例 18 提供了与示例 16 类似的功能，但没有使用信号量，并且不创建专门用于执行中断所必需的处理的任务。相反，该处理由 RTOS 守护进程任务执行。</p><p>示例 18 所使用的中断服务例程如清单 102 所示。它调用 <code>xTimerPendFunctionCallFromISR()</code>，将一个指向名为<code>vDeferredHandlingFunction()</code> 的函数的指针传递给守护进程任务。延迟的中断处理由 <code>vDeferredHandlingFunction()</code> 函数执行。</p><p>中断服务程序每次执行时都会增加一个名为 <code>ulParameterValue</code> 的变量。<code>ulParameterValue</code> 在对 <code>xTimerPendFunctionCallFromISR()</code> 的调用中被用作 <code>ulParameter2</code> 的值，因此当守护程序任务执行 <code>vDeferredHandlingFunction()</code> 时，也将在对 <code>vDeferredHandlingFunction()</code> 的调用中用作 <code>ulParameter2</code> 的值。在这个例子中没有使用。本例中未使用函数的另一个参数 <code>pvParameter1</code>。</p><pre class=" language-lang-c"><code class="language-lang-c">static uint32_t ulExampleInterruptHandler(void){    static uint32_t ulParameterValue = 0;    BaseType_t xHigherPriorityTaskWoken;    /* xHigherPriorityTaskWoken 参数必须被初始化为 pdFALSE，    因为如果需要进行上下文切换，它将在中断安全 API 函数中被设置为 pdTRUE。 */    xHigherPriorityTaskWoken = pdFALSE;    /* 将指向中断的延迟处理函数的指针发送到守护进程任务。    不使用延迟处理函数的 pvParameter1 参数，因此只需设置为 NULL。    延迟处理函数的ulParameter2参数用于传递一个数字，    这个数字在每次执行这个中断处理程序时都会递增 1 。 */    xTimerPendFunctionCallFromISR(vDeferredHandlingFunction, /* 要执行的函数。 */                                  NULL,                      /* 未使用。 */                                  ulParameterValue,          /* 递增值。 */                                  &xHigherPriorityTaskWoken);    ulParameterValue++;    /* 将xHigherPriorityTaskWoken 的值传给 portYIELD_FROM_ISR()。    如果 xHigherPriorityTaskWoken 在 xTimerPendFunctionCallFromISR() 中被设置为 pdTRUE，     那么调用 portYELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，     那么调用 portYIELD_FROM_ISR() 将没有任何影响。    与大多数 FreeRTOS 移植不同，Windows 移植要求 ISR 返回一个值——    返回语句在 Windows 版本的 portYIELD_FROM_ISR() 中。 */    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);}</code></pre><p>清单102. 示例18中使用的软件中断处理程序</p><p><code>vDeferredHandlingFunction()</code> 的实现在清单 103 中显示。它打印出一个固定的字符串及其 <code>ulParameter2</code> 的参数值。</p><p><code>vDeferredHandlingFunction()</code> 必须具有清单 101 中所示的原型，尽管在这个例子中，实际上只使用了它的一个参数。</p><pre class=" language-lang-c"><code class="language-lang-c">static void vDeferredHandlingFunction(void *pvParameter1, uint32_t ulParameter2){    /* 处理事件————在本例中只是打印出一条信息和 ulParameter2 的值。    pvParameter1 在本例中没有使用。 */    vPrintStringAndNumber("Handler function - Processing event ", ulParameter2);}</code></pre><p>清单103. 执行示例18中中断所需的处理的函数</p><p>示例 18 使用的 <code>main()</code> 函数在 清单 104 中显示。它比示例 16 使用的 <code>main()</code> 函数更简单，因为它既不创建信号量，也不创建任务来执行延迟中断处理。</p><p><code>vPeriodicTask()</code> 是周期性产生软件中断的任务。它的创建优先级低于守护进程任务的优先级，以确保守护进程任务一离开阻塞状态，它就会被守护进程任务抢占。</p><pre class=" language-lang-c"><code class="language-lang-c">int main(void){    /* 以低于守护进程任务的优先级创建生成软件中断的任务。    守护进程任务的优先级由 FreeRTOSConfig.h 中的    configTIMER_TASK_PRIORITY 编译时配置常量设置。 */    const UBaseType_t ulPeriodicTaskPriority = configTIMER_TASK_PRIORITY - 1;    /* 创建将周期性生成软件中断的任务。 */    xTaskCreate(vPeriodicTask, "Periodic", 1000, NULL, ulPeriodicTaskPriority, NULL);    /* 安装软件中断的处理程序。执行此操作所需的语法取决于所使用的 FreeRTOS 移植。    这里显示的语法只能用于 FreeRTOS 的 windows 移植，在那里这种中断只是模拟的。 */    vPortSetInterruptHandler(mainINTERRUPT_NUMBER, ulExampleInterruptHandler);    /* 启动调度器，使创建的任务开始执行。 */    vTaskStartScheduler();    /* 正常情况下，不应到达以下行。 */    for (;;)        ;}</code></pre><p>清单104. 示例18中 <code>main()</code> 的实现</p><p>示例 18 产生的输出如图 57 所示。守护进程任务的优先级高于生成软件中断的任务的优先级，因此一旦生成中断，守护进程任务就会执行 <code>vDeferredHandlingFunction()</code>。这导致 <code>vDeferredHandlingFunction()</code> 输出的消息出现在周期性任务输出的两个消息之间，就像使用信号量取消阻塞专用延迟中断处理任务时一样。在图 58 中提供了进一步的解释。</p><p><img src="image-20240410001119808.png" alt="图 57. 执行示例 18 时产生的输出"></p><p><img src="image-20240410001514315.png" alt="图 58. 执行示例 18 时的执行顺序"></p><h2 id="在中断服务程序中使用队列"><a href="#在中断服务程序中使用队列" class="headerlink" title="在中断服务程序中使用队列"></a>在中断服务程序中使用队列</h2><p>二进制和计数信号量用于传递事件。队列用于传递事件和传输数据。</p><p><code>xQueueSendToFrontFromISR()</code> 是 <code>xQueueSendToFront()</code> 在中断服务例程中使用安全的版本； <code>xQueueSendToBackFromISR()</code> 是 <code>xQueueSendToBack()</code> 在中断服务例程中使用安全的版本； <code>xQueueReceiveFromISR()</code> 是 <code>xQueueReceive()</code> 在中断服务例程中使用安全的版本。</p><h3 id="xQueueSendToFrontFromISR-和xQueueSendToBackFromISR-API-函数"><a href="#xQueueSendToFrontFromISR-和xQueueSendToBackFromISR-API-函数" class="headerlink" title="xQueueSendToFrontFromISR() 和xQueueSendToBackFromISR() API 函数"></a>xQueueSendToFrontFromISR() 和xQueueSendToBackFromISR() API 函数</h3><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueSendToFrontFromISR(QueueHandle_t xQueue,                                    void *pvItemToQueue                                    BaseType_t *pxHigherPriorityTaskWoken                                    );</code></pre><p>清单 105. <code>xQueueSendToFrontFromISR()</code> API 函数原型</p><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueSendToBackFromISR(QueueHandle_t xQueue,                                   void *pvItemToQueue,                                   BaseType_t *pxHigherPriorityTaskWoken                                  );</code></pre><p>清单 106. <code>xQueueSendToBackFromISR()</code> API 函数原型</p><p><code>xQueueSendFromISR()</code> 和 <code>xQueueSendToBackFromISR()</code> 在功能上是等效的。</p><p>表38. <code>xQueueSendToFrontFromISR()</code> 和 <code>xQueueSendToBackFromISR()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>要向其发送 (写入) 数据的队列的句柄。该队列句柄将从用于创建队列的 <code>xQueueCreate()</code> 调用中返回。</td></tr><tr><td><code>pvItemToQueue</code></td><td>指向将复制到队列中的数据的指针。<br>队列所能容纳的每个项目的大小是在创建队列时设置的，因此这许多字节将从 <code>pvItemToQueue</code> 复制到队列存储区域。</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td>单个队列上有可能会有一个或多个任务被阻塞，等待数据变为可用。调用 <code>xQueueSendToFrontFromISR()</code> 或 <code>xQueueSendToBackFromISR()</code> 可以使数据可用，从而导致这样一个任务离开阻塞状态。如果调用 API 函数导致一个任务离开阻塞状态，并且解除阻塞的任务的优先级高于当前执行的任务（被中断的任务），则 API 函数在内部会将 <code>*pxHigherPriorityTaskWoken</code> 设置为 <code>pdTRUE</code>。<br>如果 <code>xQueueSendToFrontFromISR()</code> 或 <code>xQueueSendToBackFromISR()</code> 将此值设置为 <code>pdTRUE</code>，那么在中断退出之前应该进行上下文切换。这将确保中断直接返回到最高优先级的就绪状态任务。</td></tr><tr><td>返回值</td><td><p>有两个可能的返回值:<br>1. `pdPASS`<br>`pdPASS` 仅在数据被成功发送到队列时返回。<br>2. `errQUEUE_FULL`<br>如果由于队列已满而无法将数据发送到队列，则返回 `errQUEUE_FULL`。</p></td></tr></tbody></table></div><h3 id="从-ISR-中使用队列时的考虑因素"><a href="#从-ISR-中使用队列时的考虑因素" class="headerlink" title="从 ISR 中使用队列时的考虑因素"></a>从 ISR 中使用队列时的考虑因素</h3><p>队列提供了一种将数据从中断传递到任务的简单便捷的方法，但如果数据到达频率较高，则使用队列效率不高。</p><p>FreeRTOS 下载中的许多演示程序都包含一个简单的 UART 驱动程序，该驱动程序使用队列将字符从 UART 的接收 ISR 中传递出来。在这些演示程序中，使用队列有两个原因：演示从 ISR 使用的队列，以及故意加载系统以测试 FreeRTOS 移植。以这种方式使用队列的 ISR 绝对不是为了代表高效的设计，除非数据到达速度放慢，否则建议生产代码不要复制该技术。适用于生产环境代码的更高效的技术包括 :</p><ul><li><p>使用直接内存访问（DMA）硬件来接收和缓冲字符。这种方法实际上没有软件开销。然后可以使用直接到任务的通知 [1] 来解除对仅在检测到传输中断后才处理缓冲区的任务的阻塞。</p><blockquote><p>[1] 直接到任务的通知提供了从 ISR 取消阻塞任务的最有效方法。第9章 任务通知 中介绍了直接到任务的通知。</p></blockquote></li><li><p>将收到的每个字符复制到线程安全的 RAM 缓冲区 [2]。同样，直接任务通知可用于在收到完整消息后或在检测到传输中断后解除对将要处理缓冲区的任务的阻塞。</p><blockquote><p>[2] 作为 FreeRTOS + TCP (<a href="http://www.FreeRTOS.org/tcp">http://www.FreeRTOS.org/tcp</a>) 的一部分提供的 “Stream Buffer ( 流缓冲区 )” 可以用于此目的。</p></blockquote></li><li><p>直接在 ISR 中处理收到的字符，然后使用队列将数据处理的结果 ( 而不是原始数据 ) 发送到一个任务。图 34 先前已对此进行了演示。</p></li></ul><h3 id="示例-19-在一个队列中从一个中断中发送和接收信息"><a href="#示例-19-在一个队列中从一个中断中发送和接收信息" class="headerlink" title="示例 19. 在一个队列中从一个中断中发送和接收信息"></a>示例 19. 在一个队列中从一个中断中发送和接收信息</h3><p>此示例演示在同一中断中使用的 <code>xQueueSendToBackFromISR()</code> 和 <code>xQueueReceiveFromISR()</code>  。如前所述，为方便起见，中断由软件产生。</p><p>创建一个周期性任务，每200毫秒向一个队列发送五个数字。只有在所有五个数字都已发送后，它才会产生一个软件中断。任务实现如清单 107 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static void vIntegerGenerator(void *pvParameters){    TickType_t xLastExecutionTime;    uint32_t ulValueToSend = 0;    int i;    /* 初始化调用 vTaskDelayUntil() 所使用的变量。 */    xLastExecutionTime = xTaskGetTickCount();    for (;;)    {        /* 这是一个周期性任务。阻塞直到它再次运行的时间。任务将每 200ms 执行一次。 */        vTaskDelayUntil(&xLastExecutionTime, pdMS_TO_TICKS(200));        /* 向队列发送五个数字，每个数字比前一个数字高一。这些数字由中断服务例程从队列中读取。        中断服务例程总是清空队列，所以这个任务保证能够写入所有五个值，而不需要指定阻塞时间。 */        for (i = 0; i < 5; i++)        {            xQueueSendToBack(xIntegerQueue, &ulValueToSend, 0);            ulValueToSend++;        }        /* 生成中断，以便中断服务例程可以从队列中读取数值。        用于生成软件中断的语法取决于正在使用的 FreeRTOS 移植。        下面使用的语法只能用于 FreeRTOS Windows 移植，        在该移植中，这种中断只是模拟的。*/        vPrintString("Generator task - About to generate an interrupt.\r\n");        vPortGenerateSimulatedInterrupt(mainINTERRUPT_NUMBER);        vPrintString("Generator task - Interrupt generated.\r\n\r\n\r\n");    }}</code></pre><p>清单 107. 示例 19 中写入队列的任务的实现</p><p>中断服务例程重复调用 <code>xQueueReceiveFromISR()</code> ，直到周期性任务写入队列的所有值都被读出，并且队列为空。每个收到的值的最后两位被用作一个字符串数组的索引。然后通过调用 <code>xQueueSendFromISR()</code> ，将指向相应索引位置处的字符串的指针发送到不同的队列。中断服务例程的实现如清单 108 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static uint32_t ulExampleInterruptHandler(void){    BaseType_t xHigherPriorityTaskWoken;    uint32_t ulReceivedNumber;    /* 字符串被声明为静态常量，以确保它们不被分配到中断服务例程的堆栈上，    因此即使在中断服务例程不执行时也存在。 */    static const char *pcStrings[] =        {            "String 0\r\n",            "String 1\r\n",            "String 2\r\n",            "String 3\r\n"};    /* 与往常一样，xHigherPriorityTaskWoken 被初始化为 pdFALSE，    以便能够检测到它在中断安全 API 函数中被设置为 pdTRUE。请注意，    由于中断安全API函数只能将 xHigherPriorityTaskWoken 设置为 pdTRUE，    因此在对 xQueueReceiveFromISR() 的调用和对 QueueSendToBackFromISR()     的调用中使用同一个 xHigherPriorityTaskWoken 变量是安全的。 */    xHigherPriorityTaskWoken = pdFALSE;    /* 从队列中读取，直到队列为空。 */    while (xQueueReceiveFromISR(xIntegerQueue,                                &ulReceivedNumber,                                &xHigherPriorityTaskWoken) != errQUEUE_EMPTY)    {        /* 将接收到的值截断到最后两位 (包括值 0 到 3 )，        然后用截断的值作为 pcStrings[] 数组的索引，        选择一个字符串 (char *) 发送到另一个队列上。 */        ulReceivedNumber &= 0x03;        xQueueSendToBackFromISR(xStringQueue,                                &pcStrings[ulReceivedNumber],                                &xHigherPriorityTaskWoken);    }    /* 如果从 xIntegerQueue 接收导致任务离开阻塞状态，    并且如果离开阻塞状态的任务的优先级高于处于运行状态的任务的优先级，    那么 xHigherPriorityTaskWoken 将在 xQueueReceiveFromISR() 中被设置为 pdTRUE。    如果向 xStringQueue 发送导致任务离开阻塞状态，    并且如果离开阻塞状态的任务的优先级高于处于运行状态的任务的优先级，    那么 xHigherPriorityTaskWoken 将在 xQueueSendToBackFromISR() 中被设置为 pdTRUE。    xHigherPriorityTaskWoken 被用作 portYIELD_FROM_ISR() 的参数。    如果 xHigherPriorityTaskWoken 等于 pdTRUE，    那么调用 portYIELD_FROM_ISR() 将请求进行上下文切换。    如果 xHigherPriorityTaskWoken 仍然是 pdFALSE，    那么调用 portYIELD_FROM_ISR() 将没有任何作用。    Windows 移植使用的 portYIELD_FROM_ISR() 的实现包括一个 return 语句，    这就是为什么这个函数没有显式返回值的原因。 */    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);}</code></pre><p>清单 108. 示例 19 所使用的中断服务例程的实现</p><p>从中断服务例程接收字符指针的任务在队列上阻塞，直到有消息到达，，并在接收到每个字符串时打印出来。它的实现如清单 109 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static void vStringPrinter( void *pvParameters ){    char *pcString;    for( ;; )    {        /* 在队列上阻塞以等待数据到达 */        xQueueReceive( xStringQueue, &pcString, portMAX_DELAY );        /* 打印出接收到的字符串。*/        vPrintString( pcString );    } }</code></pre><p>清单 109. 示例 19 中打印从中断服务例程接收到的字符串的任务</p><p>像往常一样，<code>main()</code> 在启动调度程序之前创建所需的队列和任务。它的实现如清单 110 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">int main( void ){ /* 在使用队列之前，必须首先创建队列。创建本例所使用的两个队列。 一个队列可以保存 uint32_t 类型的变量，另一个队列可以保存 char * 类型的变量。 两个队列最多可以容纳10个项目。真实的应用程序应该检查返回值以确保队列已被成功创建。 */ xIntegerQueue = xQueueCreate( 10, sizeof( uint32_t ) ); xStringQueue = xQueueCreate( 10, sizeof( char * ) ); /* 创建使用队列将整数传递给中断服务例程的任务。任务以优先级 1 创建。 */ xTaskCreate( vIntegerGenerator, "IntGen", 1000, NULL, 1, NULL ); /* 创建打印出中断服务例程发送给它的字符串的任务。此任务以较高的优先级 2 创建。 */ xTaskCreate( vStringPrinter, "String", 1000, NULL, 2, NULL ); /* 安装软件中断的处理程序。这样做所需的语法取决于正在使用的 FreeRTOS 移植。 这里显示的语法只能用于 FreeRTOS Windows 移植，在那里这种中断只是模拟的。 */ vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulExampleInterruptHandler ); /* 启动调度程序，使创建的任务开始执行。 */ vTaskStartScheduler(); /* 如果一切顺利，那么main()将永远不会到达这里，因为调度程序现在将运行任务 如果 main() 确实到达这里，那么很可能是没有足够的堆内存可用于创建空闲任务。 第 2 章提供了有关堆内存管理的更多信息。 */ for( ;; );}</code></pre><p>清单 110. 示例 19 的 <code>main()</code> 函数</p><p>执行示例 19 时产生的输出如图 59 所示。可以看出，中断接收了所有五个整数，并产生了五个字符串作为响应。图 60 中给出了更多的解释。</p><p><img src="image-20240411070715950.png" alt="图 59. 执行示例 19 时产生的输出"></p><p><img src="image-20240411071042631.png" alt="图 60. 示例 19 产生的执行顺序"></p><h2 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h2><p>在任务优先级和中断优先级之间出现混淆是很常见的。本节讨论中断优先级，本节讨论中断优先级，即中断服务例程 ( ISR ) 相对于彼此执行的优先级。分配给任务的优先级与分配给中断的优先级没有任何关系。硬件决定 ISR 何时执行，而软件决定任务何时执行。响应硬件中断而执行的 ISR 将中断任务，但任务不能抢占 ISR。</p><p>支持中断嵌套的移植需要在 <code>FreeRTOSConfig.h</code> 中定义表 39 中详述的一个或两个常量。 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 和 <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code> 都定义相同的属性。较旧的 FreeRTOS 移植使用 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>，较新的 FreeRTOS 移植使用 <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code>。</p><p>表 39. 控制中断嵌套的常量</p><div class="table-container"><table><thead><tr><th>恒定</th><th>描述</th></tr></thead><tbody><tr><td><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> or <code>configMAX_API_CALL_INTERRUPT_PRIORITY</code></td><td>设置可以调用中断安全 FreeRTOS API 函数的最高中断优先级。</td></tr><tr><td><code>configKERNEL_INTERRUPT_PRIORITY</code></td><td>设置滴答 ( tick ) 中断使用的中断优先级，并且必须始终设置为尽可能低的中断优先级。<br>如果使用的FreeRTOS移植没有同时使用<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 常量，那么任何使用中断安全的FreeRTOS API 函数的中断也必须以 <code>configKERNEL_INTERRUPT_PRIORITY</code> 定义的优先级执行。</td></tr></tbody></table></div><p>每个中断源都有一个数字优先级和一个逻辑优先级 : </p><ul><li><p>数字优先级</p><p>数字优先级只是分配给中断优先级的数字。例如，如果一个中断被分配的优先级为7，那么它的数字优先级就是 7。 同样，如果一个中断被分配的优先级为 200，那么它的数字优先级就是 200。</p></li><li><p>逻辑优先级</p><p>一个中断的逻辑优先级描述了该中断相对于其他中断的优先级。</p><p>如果两个不同优先级的中断同时发生，则处理器将先执行两个中断中逻辑优先级较高的一个中断，然后再执行两个中断中逻辑优先级较低的一个中断。</p><p>一个中断可以中断 ( 嵌套 ) 任何具有较低逻辑优先级的中断，但一个中断不能中断 ( 嵌套 ) 任何具有相同或更高逻辑优先级的中断。</p></li></ul><p>中断的数字优先级和逻辑优先级之间的关系取决于处理器架构；在某些处理器上，分配给一个中断的数字优先级越高，该中断的逻辑优先级就越高，而在其他处理器架构上，分配给一个中断的数字优先级越高，该中断的逻辑优先级就越低。</p><p>通过将 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 设置为比 <code>configKERNEL_INTERRUPT_PRIORITY</code> 更高的逻辑中断优先级可以创建一个完整的中断嵌套模型。图 61 对此进行了演示，其中显示了以下场景：</p><ul><li>处理器具有 7 个唯一的中断优先级。</li><li>分配数字优先级 7 的中断比分配数字优先级 1 的中断具有更高的逻辑优先级。</li><li><code>configKERNEL_INTERRUPT_PRIORITY</code> 被设置为 1 。</li><li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 被设置为 3 。</li></ul><p><img src="image-20240411085426838.png" alt="图 61. 影响中断嵌套行为的常量"></p><p>参考图 61：</p><ul><li>当内核或应用程序位于临界段时，使用优先级 1 到 3 ( 含 ) 的中断将被阻止执行。以这些优先级运行的 ISR 可以使用中断安全的 FreeRTOS API 函数。临界段的描述见第 7 章。</li><li>使用优先级 4 或更高优先级的中断不受临界段的影响，因此调度程序所做的任何操作都不会阻止这些中断立即执行——在硬件本身的限制范围内。以这些优先级执行的 ISR 无法使用任何 FreeRTOS API 函数。</li><li>通常，需要非常严格的时间精度的功能 ( 例如电机控制 ) 会使用高于 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 的优先级，以确保调度器不会在中断响应时间中引入抖动。</li></ul><h3 id="对ARM-Cortex-M-和ARM-GIC用户的说明"><a href="#对ARM-Cortex-M-和ARM-GIC用户的说明" class="headerlink" title="对ARM Cortex-M 和ARM GIC用户的说明"></a>对ARM Cortex-M 和ARM GIC用户的说明</h3><p><code>Cortex-M</code> 处理器上的中断配置很混乱，并且容易出错。为了协助您的开发，<code>FreeRTOS Cortex-M</code> 移植会自动检查中断配置，但前提是定义了 <code>configASSERT()</code> 。<code>configASSERT()</code> 在 11.2 节中描述。</p><blockquote><p>Cortex-M：本节仅部分适用于 <code>Cortex-M0</code> 和 <code>Cortex-M0+</code> 内核。</p></blockquote><p>ARM Cortex 内核和 ARM 通用中断控制器 (GIC —- Generic Interrupt Controller ) 使用数字上的低优先级数字来表示逻辑上的高优先级中断。这似乎违反直觉，并且很容易忘记。如果您希望为中断分配逻辑上较低的优先级，则必须为其分配较高的数字值。如果您希望为中断分配逻辑上较高的优先级，则必须为其分配较低的数字值。</p><p><code>Cortex-M</code> 中断控制器允许使用最多 8 位来指定每个中断优先级，使 255 成为可能的最低优先级。0 是最高优先级。然而，<code>Cortex-M</code> 微控制器通常仅实现 8 个可能位的子集。实际实现的位数取决于微控制器系列。</p><p>当仅实现了 8 个可能位的子集时，只能使用字节的最高有效位，而最低有效位则未实现。未实现的位可以取任何值，但通常将它们设置为  1 。 图 62 对此进行了演示，该图显示了二进制 101 的优先级如何存储在一个实现了 4 个优先位的<code>Cortex-M</code>微控制器中。</p><p><img src="image-20240411174725336.png" alt="图 62. 实现 4 个优先级位的 Cortex-M 微控制器如何存储二进制 101 的优先级"></p><p>在图 62 中，二进制值 101 已移至最高有效四位，因为未实现最低有效四位。 未实现的位已设置为 1。</p><p>某些库函数期望在将优先级值向上移至已实现的 ( 最高有效 ) 位之后指定优先级值。在使用这样的函数时，可以将图 62 所示的优先级指定为十进制 95 ( 0101 1111 ) 。十进制 95 将二进制 101 上移 4 以生成二进制 101nnnn ( 其中 ‘ n ‘ 是一个未实现的位 )，将未实现的位设置为 1 以生成二进制 1011111 。</p><p>某些库函数期望在将优先级值向上移至已实现的 ( 最高有效 ) 位之前指定优先级值。使用此类函数时，图 62 中所示的优先级必须指定为十进制 5。十进制 5 是没有任何移位的二进制 101。</p><blockquote><p>也就是说在使用函数写入优先级寄存器时，要设置的优先级通常作为函数参数传入，有些函数要求你传入的参数要提前将优先级移至对应的有效位，函数直接将参数写入寄存器；有些函数可以直接将要设置的优先级作为参数传入，函数会帮你在内部将参数做好移位后再写入寄存器。</p></blockquote><p><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 和 <code>configKERNEL_INTERRUPT_PRIORITY</code> 必须以允许它们直接写入 <code>Cortex-M</code> 寄存器的方式来指定，所以在优先级值被上移到实现的位后。</p><p><code>configKERNEL_INTERRUPT_PRIORITY</code> 必须始终设置为可能的最低中断优先级。 未实现的优先级位可以设置为1，因此无论实际实现了多少优先级位，该常量始终可以设置为 255。</p><p><code>Cortex-M</code>中断的默认优先级为 0 —— 可能的最高优先级。<code>Cortex-M</code> 硬件的实现不允许 <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> 被设置为 0 ，所以使用 FreeRTOS API 的中断的优先级绝不能保留为其默认值。</p>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 5 软件定时器管理</title>
      <link href="/Blogs/2024/06/15/chapter-5-ruan-jian-ding-shi-qi-guan-li/"/>
      <url>/Blogs/2024/06/15/chapter-5-ruan-jian-ding-shi-qi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-5-软件定时器管理"><a href="#Chapter-5-软件定时器管理" class="headerlink" title="Chapter 5 软件定时器管理"></a>Chapter 5 软件定时器管理</h1><h2 id="章节介绍和范围"><a href="#章节介绍和范围" class="headerlink" title="章节介绍和范围"></a>章节介绍和范围</h2><p>软件定时器用于安排函数在设定的未来时间点执行，或者以固定频率定期执行。 软件定时器执行的函数称为软件定时器的回调函数。</p><p>软件定时器由 FreeRTOS 内核实现，并受 FreeRTOS内核 的控制。它们不需要硬件支持，也与硬件定时器或硬件计数器无关。</p><p>请注意，根据 FreeRTOS 使用创新设计以确保最高效率的理念，软件定时器不会使用任何处理时间，除非实际执行软件定时器回调函数。</p><p>软件定时器功能是可选的。要包含软件定时器功能，请执行以下操作:</p><ol><li>将FreeRTOS源文件 <code>FreeRTOS/Source/timers.c</code> 构建为项目的一部分 </li><li>在 <code>FreeRTOSConfig.h</code> 中将<code>configUSE_TIMERS</code>设置为1。</li></ol><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h3><p>本章旨在让读者更好地了解以下内容：</p><ul><li>软件定时器的特性与任务特性的比较。</li><li>RTOS 守护进程任务。</li><li>定时器命令队列。</li><li>一次性软件定时器和周期性软件定时器之间的区别。</li><li>如何创建、启动、重置和更改软件定时器的周期。</li></ul><h2 id="软件定时器回调函数"><a href="#软件定时器回调函数" class="headerlink" title="软件定时器回调函数"></a>软件定时器回调函数</h2><p>软件定时器回调函数被实现为 C 函数。它们唯一的特别之处是它们的原型，它必须返回void，并将软件定时器的句柄作为其唯一的参数。清单 72 演示了回调函数原型。</p><pre class=" language-lang-c"><code class="language-lang-c">void ATimerCallback( TimerHandle_t xTimer );</code></pre><p>清单 72. 软件定时器回调函数原型</p><p>软件定时器回调函数自始至终执行，并以正常方式退出。它们应该保持简短，并且不能进入阻塞状态。</p><blockquote><p>注意：正如将看到的，软件定时器回调函数在启动 FreeRTOS 调度程序时自动创建的任务的上下文中执行。 因此，软件定时器回调函数决不能调用会导致调用任务进入阻塞状态的FreeRTOS API 函数，这一点至关重要。 可以调用 xQueueReceive() 之类的函数，但前提是该函数的 xTicksToWait 参数(指定函数的阻塞时间)设置为 0。 调用 vTaskDelay() 之类的函数是不对的，因为调用vTaskDelay()会始终将调用任务置于阻塞状态。</p></blockquote><h2 id="软件定时器的属性和状态"><a href="#软件定时器的属性和状态" class="headerlink" title="软件定时器的属性和状态"></a>软件定时器的属性和状态</h2><h3 id="软件定时器的周期"><a href="#软件定时器的周期" class="headerlink" title="软件定时器的周期"></a><strong>软件定时器的周期</strong></h3><p>软件定时器的 <code>‘周期’(period)</code> 是软件定时器启动和软件定时器的回调函数执行之间的时间</p><h3 id="一次性定时器和自动重载定时器"><a href="#一次性定时器和自动重载定时器" class="headerlink" title="一次性定时器和自动重载定时器"></a><strong>一次性定时器和自动重载定时器</strong></h3><p>有两种类型的软件定时器：</p><ol><li><p>一次性定时器 一旦启动</p><p>一旦启动，一次性定时器将仅执行一次其回调函数。一次性定时器可以手动重新启动，但不会自行重新启动。</p></li><li><p>自动重载定时器 </p><p>一旦启动，自动重载定时器将在每次到期时重新启动，从而定期执行其回调函数。</p></li></ol><p>图38显示了一次性定时器和自动重载定时器之间的行为差异。虚线垂直线标记滴答中断发生的时间。</p><p><img src="image-20240330161114285.png" alt="图38一次性软件定时器和自动重载软件定时器之间的行为差异"></p><p>参考图38：</p><ul><li><p>定时器 1 </p><p>定时器 1 是具有 6 个滴答长的周期的一次性定时器。它在 t1 时刻启动，因此它的回调函数在6个滴答之后，即 t7 时刻执行。由于定时器 1是一次性定时器，其回调函数不会再次执行。</p></li><li><p>定时器 2 </p><p>定时器 2 是具有 5 个滴答长的周期的自动重载定时器。它在 t1 时刻启动，因此它的回调函数在 t1 时刻之后每5 滴答执行一次。在图38中，这是 t6 、 t11 和 t16 时刻。</p></li></ul><h3 id="软件定时器状态"><a href="#软件定时器状态" class="headerlink" title="软件定时器状态"></a><strong>软件定时器状态</strong></h3><p>软件定时器可以处于以下两种状态之一：</p><ul><li><p>休眠</p><p>休眠的软件定时器存在，并且可以通过其句柄引用，但未运行，因此其回调函数将不会执行。</p></li><li><p>运行</p><p>正在运行的软件定时器将在从软件定时器进入运行状态起或者从软件定时器最后被重置起经过等于其周期的时间之后执行其回调函数。</p></li></ul><p>图39和图40分别显示了自动重载定时器和一次性定时器在休眠状态和运行状态之间的可能的转换。这两个图的关键区别在于定时器到期后进入的状态；自动重载定时器执行其回调函数，然后重新进入运行状态，一次性定时器执行其回调函数，然后进入休眠状态。</p><p>xTimerDelete() API 函数的作用是：删除一个定时器。可以随时删除定时器。</p><p><img src="image-20240615012641295.png" alt="图 39 自动重载软件定时器状态和转换"></p><p><img src="image-20240330163007600.png" alt="图 40 一次性软件定时器状态和转换"></p><h2 id="软件定时器的上下文"><a href="#软件定时器的上下文" class="headerlink" title="软件定时器的上下文"></a>软件定时器的上下文</h2><h3 id="RTOS守护进程-定时器服务-任务"><a href="#RTOS守护进程-定时器服务-任务" class="headerlink" title="RTOS守护进程(定时器服务)任务"></a><strong>RTOS守护进程(定时器服务)任务</strong></h3><p>所有软件定时器回调函数都在同一 RTOS <code>守护进程任务-daemon task</code> (或 <code>“定时器服务任务-timer service task”</code> ) 的上下文中执行[1]。</p><blockquote><p>[1] 该任务过去被称为 “定时器服务任务” ，因为最初它只用于执行软件定时器回调函数。现在同一任务也用于其他目的，因此它被称为 “RTOS守护进程任务” 的更一般的名称。</p><p>daemon : 计算机中的概念，多翻译为守护进程，守护进程是运行在后台的一种特殊进程，它周期性地执行某种任务或循环等待处理某些事件的发生，在不需要时处于休眠状态。</p></blockquote><p>守护进程任务，是在启动调度程序时，自动创建的标准的 FreeRTOS 任务。其优先级和堆栈大小分别由 <code>configTIMER_TASK_PRIORITY</code> 和 <code>configTIMER_TASK_STACK_DEPTH</code> 编译时配置常量设置。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p><p>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API 函数，因为这样做将导致守护进程任务进入阻塞状态。</p><h3 id="定时器命令队列"><a href="#定时器命令队列" class="headerlink" title="定时器命令队列"></a><strong>定时器命令队列</strong></h3><p>软件定时器 API 函数将命令从调用任务发送到称为 “定时器命令队列” 的队列上的守护进程任务。这如图 41 所示。命令的示例包括 <code>"start a timer (启动定时器)"</code> 、<code>stop a timer (停止定时器)</code> 和 <code>reset a timer (重置定时器)</code> 。</p><p>定时器命令队列是在启动调度程序时自动创建的标准 FreeRTOS 队列。定时器命令队列的长度由 <code>FreeRTOSConfig.h</code> 中的 <code>configTIMER_QUEUE_LENGTH</code> 编译时配置常量设置。</p><p><img src="image-20240330165153654.png" alt="图 41 软件定时器API函数使用定时器命令队列与RTOS守护进程任务通信"></p><h3 id="守护进程任务调度"><a href="#守护进程任务调度" class="headerlink" title="守护进程任务调度"></a><strong>守护进程任务调度</strong></h3><p>守护进程任务与任何其他 FreeRTOS 任务一样进行调度；当守护进程任务是能够运行的最高优先级任务时，它只会处理命令或执行定时器回调函数。图 42 和图 43 演示了 <code>configTIMER_TASK_PRIORITY</code> 设置如何影响执行模式</p><p>图 42 显示了当守护进程任务的优先级低于调用 <code>xTimerStart()</code> API 函数的任务的优先级时的执行模式</p><p><img src="image-20240330170229111.png" alt="图 42 调用xTimerStart()的任务的优先级高于守护进程任务的优先级时的执行模式"></p><p>参照图 42 ，其中任务1 的优先级高于守护进程任务的优先级，并且守护进程任务的优先级高于空闲任务的优先级：</p><ol><li><p>t1 时刻 </p><p>任务1 处于运行状态，守护进程任务处于阻塞状态。</p><p>如果有命令发送到定时器命令队列，守护进程任务将离开阻塞状态，在这种情况下，它将处理该命令，或者如果软件定时器到期，在这种情况下，它将执行软件定时器的回调函数。</p></li><li><p>t2 时刻：</p><p>任务1 调用 <code>xTimerStart()</code> 。</p><p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。 任务1 的优先级高于守护进程任务的优先级，因此守护进程任务不会抢占任务1 。 </p><p>任务1 仍处于运行状态，守护进程任务已离开阻塞状态，进入就绪状态。</p></li><li><p>t3 时刻：</p><p>任务1 完成 <code>xTimerStart()</code> API 函数的执行。</p><p>任务1 从头到尾执行完 <code>xTimerStart()</code> ，而不离开运行状态。</p></li><li><p>t4 时刻：</p><p>任务1 调用导致其进入阻塞状态的 API 函数。守护进程任务现在是处于就绪状态的最高优先级任务，因此调度程序选择守护进程任务作为进入运行状态的任务。然后，守护进程任务开始处理任务1 发送到定时器命令队列的命令。 </p><p><em>注意：正在启动的软件定时器将到期的时间是从向定时器命令队列发送 “启动定时器” 命令开始计算的，而不是从守护进程任务从定时器命令队列接收到 “启动定时器” 命令的时间计算的。</em></p></li><li><p>t5 时刻：</p><p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。定时器命令队列为空，因此守护进程任务重新进入阻塞状态。如果将命令发送到定时器命令队列，或者如果软件定时器到期，则守护进程任务将再次离开阻塞状态。</p><p>空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p></li></ol><p>图 43 显示了类似于图 42 所示的场景，但是这一次守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级。</p><p><img src="image-20240331001216768.png" alt="图 43 当调用xTimerStart()的任务的优先级低于守护进程任务的优先级时的执行模式"></p><p>参照图 43 ，其中守护进程任务的优先级高于任务1 的优先级，任务1 的优先级高于空闲任务的优先级：</p><ol><li><p>t1 时刻 </p><p>和之前一样，任务1 处于运行状态，守护进程任务处在阻塞状态。 </p></li><li><p>t2 时刻 </p><p>任务1调用 <code>xTimerStart()</code> 。</p><p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。守护进程任务的优先级高于任务1 的优先级，因此调度器选择守护进程任务作为进入运行状态的任务。</p><p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，现在处于就绪状态。守护进程任务开始处理任务1 发送到定时器命令队列的命令。</p></li><li><p>t3 时刻 </p><p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。 定时器命令队列为空，因此守护进程任务重新进入阻塞状态。</p><p>任务1 现在是处于就绪状态的最高优先级任务，因此调度程序选择任务1 作为要进入运行状态的任务。</p></li><li><p>t4 时刻 </p><p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，并且只有在重新进入运行状态后才退出 <code>xTimerStart()</code> (从<code>xTimerStart()</code> return)。</p></li><li><p>t5 时刻 </p><p>任务1 调用导致其进入阻塞状态的 API 函数。空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p></li></ol><p>在图 42 所示的场景中，任务1 向定时器命令队列发送命令与守护进程任务接收和处理命令之间经过了一段时间。在图 43 所示的场景中，在 任务1 从发送命令的函数返回之前，守护进程任务已经接收并处理了任务1 发送给它的命令。</p><p>发送到定时器命令队列的命令包含时间戳。时间戳用于计算应用程序任务发送的命令与守护进程任务处理同一命令之间经过的任何时间。例如，如果发送 “启动定时器” 命令来启动周期为 10 个滴答的定时器，则时间戳用于确保正在启动的定时器是在命令发送后 10 个滴答到期，而不是在命令被守护进程任务处理之后 10 个滴答超时。</p><h2 id="创建和开始一个软件定时器"><a href="#创建和开始一个软件定时器" class="headerlink" title="创建和开始一个软件定时器"></a>创建和开始一个软件定时器</h2><h3 id="xTimerCreate-API函数"><a href="#xTimerCreate-API函数" class="headerlink" title="xTimerCreate()API函数"></a>xTimerCreate()API函数</h3><p>FreeRTOS V9.0.0还包含 <code>xTimerCreateStatic()</code> 函数，该函数在编译时静态分配创建定时器所需的内存: 软件定时器必须先显式创建，然后才能使用。</p><p>软件定时器由 <code>TimerHandle_t</code> 类型的变量引用。<code>xTimerCreate()</code> 用于创建软件定时器，并返回 <code>TimerHandle_t</code> 以引用其创建的软件定时器。软件定时器是在休眠状态下创建的。</p><p>可以在调度器运行之前创建软件定时器，也可以在调度器启动后从任务创建软件定时器。第 0 节介绍了使用的数据类型和命名约定。</p><pre class=" language-lang-c"><code class="language-lang-c">TimerHandle_t xTimerCreate( const char * const pcTimerName,                                 TickType_t xTimerPeriodInTicks,                                 UBaseType_t uxAutoReload,                                 void * pvTimerID,                                 TimerCallbackFunction_t pxCallbackFunction );</code></pre><p>清单 73 . xTimerCreate()API函数原型</p><p>表 27 . xTimerCreate()参数和返回值</p><div class="table-container"><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>pcTimerName</td><td>计时器的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。使用人类可读的名称标识计时器比尝试通过其句柄标识要简单得多。</td></tr><tr><td>xTimerPeriodInTicks</td><td>以滴答为单位指定的计时器周期。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td></tr><tr><td>uxAutoReload</td><td>将 <code>uxAutoReload</code> 设置为 <code>pdTRUE</code> 以创建自动重载计时器。将 <code>uxAutoReload</code> 设置为 <code>pdFALSE</code> 以创建一次性计时器</td></tr><tr><td>pvTimerID</td><td>每个软件定时器都有一个 ID 值。ID 是一个 <code>void</code> 指针，应用程序编写者可以将其用于任何目的。当多个软件计时器使用相同的回调函数时，ID 特别有用，因为它可用于提供特定于时器的存储。本章中的一个示例演示了定时器 ID 的使用。<br><code>pvTimerID</code> 设置正在创建的任务的ID的初始值。</td></tr><tr><td>pxCallbackFunction</td><td>软件计时器回调函数仅仅是符合清单72中所示原型的C函数。<code>pxCallbackFunction</code> 参数是指向要用作正在创建的软件定时器的回调函数的函数指针 (实际上就是函数名) 。</td></tr><tr><td>返回值</td><td>如果返回 NULL ，则无法创建软件定时器，因为 FreeRTOS 没有足够的堆内存来分配必要的数据结构。<br>返回的非 NULL 值表示软件定时器已成功创建。返回值是创建的计时器的句柄。<br> 第2章提供了有关堆内存管理的更多信息。</td></tr></tbody></table></div><h3 id="xTimerStart-API函数"><a href="#xTimerStart-API函数" class="headerlink" title="xTimerStart()API函数"></a>xTimerStart()API函数</h3><p><code>xTimerStart()</code> 用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。<code>xTimerStop()</code> 用于停止处于运行状态的软件定时器。停止软件定时器等同于与将定时器转换到休眠状态。</p><p>可以在调度程序启动之前调用 <code>xTimerStart()</code> ，但是当这样做时，软件定时器直到调度程序启动时才会实际启动。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerStart()</code> 。应该使用中断安全版本 <code>xTimerStartFromISR()</code> 来代替它。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );</code></pre><p>清单 74 . xTimerStart()API函数原型</p><p>表 28 . xTimerStart()参数和返回值</p><div class="table-container"><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>正在启动或重置的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerStart()</code> 使用定时器命令队列向守护程序任务发送 “启动计时器” 命令。<br><code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerStart()</code> 将立即返回。<br>阻塞时间以滴答周期指定，因此它表示的绝对时间取决于滴答频率。宏 <code>pdMS_TO_TICKS()</code> 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在调度程序启动之前调用 <code>xTimerStart()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerStart()</code>的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td></tr><tr><td>返回值</td><td>有两个可能的返回值<br>1.  <code>pdPASS</code><br>只有当 “启动定时器” 命令成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级，那么调度程序将确保在 <code>xTimerStart()</code> 返回之前处理启动命令。这是因为一旦定时器命令队列中有数据，守护进程任务就会抢占调用 <code>TimerStart()</code>的任务。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br>2. <code>pdFALSE</code><br>如果由于队列已满而无法将 “启动定时器” 命令写入定时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在定时器命令队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table></div><h3 id="示例-13-创建一次性和自动重载计时器"><a href="#示例-13-创建一次性和自动重载计时器" class="headerlink" title="示例 13. 创建一次性和自动重载计时器"></a>示例 13. 创建一次性和自动重载计时器</h3><p>此示例创建并启动一个一次性定时器和一个自动重载定时器 - 如清单 75 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 分配给一次性和自动重载定时器的周期分别为3.333秒和半秒。 */ #define mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )#define mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 ) int main( void ) { TimerHandle_t xAutoReloadTimer, xOneShotTimer; BaseType_t xTimer1Started, xTimer2Started;    /* 创建一次性定时器，将创建的定时器的句柄存储在 xOneShotTimer 中。*/      xOneShotTimer = xTimerCreate(     /* 软件定时器的文本名称-未由 FreeRTOS 使用。*/    "OneShot",    /*软件定时器的周期(以滴答为单位)。*/    mainONE_SHOT_TIMER_PERIOD,    /* 将 uxAutoRealod 设置为 pdFALSE 将创建一次性软件定时器。*/    pdFALSE,    /* 此示例不使用定时器 ID。*/    0,    /* 要由正在创建的软件定时器使用的回调函数。*/    prvOneShotTimerCallback );    /* 创建自动重载定时器，将创建的定时器的句柄存储在 xAutoReloadTimer 中。*/     xAutoReloadTimer = xTimerCreate(     /* 软件定时器的文本名称-未由 FreeRTOS 使用。 */    "AutoReload",    /* 软件定时器的周期(以滴答为单位)。*/    mainAUTO_RELOAD_TIMER_PERIOD,    /* 将 uxAutoRealod 设置为 pdTRUE 将创建自动重载定时器。*/    pdTRUE,     /* 此示例不使用定时器 ID。 */    0,    /* 要由正在创建的软件定时器使用的回调函数。*/    prvAutoReloadTimerCallback );    /* 检查软件定时器是否已创建。*/    if( ( xOneShotTimer != NULL ) && (xAutoReloadTimer != NULL ) )     {    /* 阻塞时间设为 0 (无阻塞时间) 启动软件定时器。调度程序尚未启动，因此此处指定的任何阻塞时间都将被忽略。 */    xTimer1Started = xTimerStart( xOneShotTimer, 0 );    xTimer2Started = xTimerStart( xAutoReloadTimer, 0);    /* xTimerStart() 的实现使用定时器命令队列，如果定时器命令队列已满，xTimerStart() 将失败。守护进程任务在调度程序启动之前不会创建，因此发送到命令队列的所有命令都将保留在队列中，直到调度程序启动之后。检查传递的两个 xTimerStart() 调用。*/    if( ( xTimer1Started == pdPASS ) && (xTimer2Started == pdPASS ) )     { /* Start the scheduler. */    vTaskStartScheduler();     }  }     /*一如既往，这条线不应该达到。 */     for( ;; );}</code></pre><p>清单 75.  创建并启动示例 13 中使用的定时器</p><p>定时器的回调函数在每次被调用时只打印一条消息。清单 76 中显示了一次性定时器回调函数的实现。自动重载定时器回调函数的实现如清单 77 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static void prvOneShotTimerCallback( TimerHandle_t xTimer ){    TickType_t xTimeNow;    /* 获取当前的滴答计数。 */    xTimeNow = xTaskGetTickCount();    /* 输出一个字符串以显示执行回调的时间*/    vPrintStringAndNumber( "One-shot timer callback executing", xTimeNow );    /* 文件作用域变量。(全局变量) */    ulCallCount++; }</code></pre><p>清单 76.  示例 13 中的一次性定时器使用的回调函数</p><pre class=" language-lang-c"><code class="language-lang-c">static void prvAutoReloadTimerCallback( TimerHandle_t xTimer ){TickType_t xTimeNow;    /* 获取当前的滴答计数。 */    xTimeNow = uxTaskGetTickCount();     /* 输出一个字符串以显示执行回调的时间*/   vPrintStringAndNumber( "Auto-reload timer callback executing", xTimeNow );  ulCallCount++; }</code></pre><p>清单 77.  示例 13 中的自动重载定时器使用的回调函数</p><p>执行此示例将生成如图 44 所示的输出。图 44 显示了自动重载定时器的回调函数以500个滴答的固定周期执行 (清单 75 中的 <code>mainAUTO_RELOAD_TIMER_PERIOD</code> 设置为 500 )，当滴答计数为 3333 时，一次性定时器的回调函数只执行一次 (清单 75 中的 <code>mainOne_Shot_Timer_Period</code> 设置为 3333 )。</p><p><img src="image-20240331225428946.png" alt="图 44 执行示例 13 时产生的输出"></p><h2 id="定时器-ID"><a href="#定时器-ID" class="headerlink" title="定时器 ID"></a>定时器 ID</h2><p>每个软件定时器都有一个 ID，它是应用程序编写者可以出于任何目的使用的标记值。ID 存储在空指针 <code>(void*)</code> 中，因此可以直接存储整数值、指向任何其他对象或用作函数指针。</p><p>创建软件定时器时会为ID分配初始值 —- 之后可以使用 <code>vTimerSetTimerID()</code> API函数更新 ID，并使用 <code>pvTimerGetTimerID()</code> API函数进行查询。</p><p>与其他软件定时器 API 函数不同，<code>vTimerSetTimerID()</code> 和 <code>pvTimerGetTimerID()</code> 直接访问软件定时器 —- 它们不向定时器命令队列发送命令。</p><h3 id="vTimerSetTimerID-API函数"><a href="#vTimerSetTimerID-API函数" class="headerlink" title="vTimerSetTimerID()API函数"></a><strong>vTimerSetTimerID()API函数</strong></h3><pre class=" language-lang-c"><code class="language-lang-c">void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID );</code></pre><p>清单 78.  vTimerSetTimerID() API 函数原型</p><p><strong>表 29. vTimerSetTimerID() 参数</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">参数/返回值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">xTimer</td><td style="text-align:left">使用新 ID 值更新的软件定时器的句柄。 句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td style="text-align:left">pvNewID</td><td style="text-align:left">软件定时器 ID 将被设为的值。</td></tr></tbody></table></div><h3 id="pvTimerGetTimerID-API-函数"><a href="#pvTimerGetTimerID-API-函数" class="headerlink" title="pvTimerGetTimerID() API 函数"></a>pvTimerGetTimerID() API 函数</h3><pre class=" language-lang-c"><code class="language-lang-c">void *pvTimerGetTimerID( TimerHandle_t xTimer );</code></pre><p>清单 79. pvTimerGetTimerID() API 函数原型</p><p>表 30.  pvTimerGetTimerID() 参数和返回值</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数/返回值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">xTimer</td><td style="text-align:left">查询的软件定时器的句柄。句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td style="text-align:left">返回值</td><td style="text-align:left">查询的软件定时器的 ID。</td></tr></tbody></table></div><h3 id="示例-14-使用回调函数参数和软件定时器ID"><a href="#示例-14-使用回调函数参数和软件定时器ID" class="headerlink" title="示例 14. 使用回调函数参数和软件定时器ID"></a>示例 14. 使用回调函数参数和软件定时器ID</h3><p>可以将相同的回调函数分配给多个软件定时器。完成后，回调函数参数用于确定哪个软件定时器已到期。</p><p>示例 13 使用了两个单独的回调函数；一个回调函数由一次性定时器使用，另一个回调函数由自动重载定时器使用。示例 14 创建与示例 13 创建的功能类似的功能，但将单个回调函数分配给两个软件定时器。</p><p>示例 14 使用的 main() 函数与示例 13 使用的 main() 函数几乎相同，唯一的区别是创建软件定时器的位置。清单 80 显示了这种差异，其中 <code>prvTimerCallback()</code> 用作两个定时器的回调函数。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 创建一次定时器软件定时器，将句柄存储在 xOneShotTimer 中。*/xOneShotTimer = xTimerCreate( "OneShot",                                          mainONE_SHOT_TIMER_PERIOD,                                          pdFALSE,                                          /* 定时器ID初始化为0*/                                          0,                                         /* 两个定时器都使用 prvTimerCallback()。*/                                         prvTimerCallback );/* 创建自动重载软件定时器，将句柄存储在 xAutoReloadTimer 中*/xAutoReloadTimer = xTimerCreate( "AutoReload",                                               mainAUTO_RELOAD_TIMER_PERIOD,                                               pdTRUE,                                               /* 定时器的ID初始化为0。 */                                               0,                                               /* 两个定时器都使用 prvTimerCallback()。*/                                               prvTimerCallback );</code></pre><p>清单 80. 创建示例 14 中使用的定时器</p><p><code>prvTimerCallback()</code> 将在任一定时器到期时执行。<code>prvTimerCallback()</code> 的实现使用函数的参数来确定调用它是因为一次性定时器已到期，还是因为自动重载定时器已到期。</p><p><code>prvTimerCallback()</code> 还演示了如何将软件定时器 ID 用作特定于定时器的存储；每个软件定时器在其自己的 ID 中保存其到期次数的计数，并且自动重载定时器在第五次执行时使用该计数停止自身。</p><p><code>prvTimerCallback()</code> 的实现如清单79所示</p><pre class=" language-lang-c"><code class="language-lang-c">static void prvTimerCallback( TimerHandle_t xTimer ){TickType_t xTimeNow;uint32_t ulExecutionCount;        /* 此软件定时器到期次数的计数存储在定时器的 ID 中。获取 ID，将其递增，        然后将其另存为新的 ID 值。该 ID 是一个 void 指针，因此被强制转换为 uint32_t。*/        ulExecutionCount = ( uint32_t ) pvTimerGetTimerID( xTimer );        ulExecutionCount++;        vTimerSetTimerID( xTimer, ( void * ) ulExecutionCount );        /*获取当前的计时次数。*/        xTimeNow = xTaskGetTickCount();        /*创建定时器时，一次性定时器的句柄存储在 xOneShotTimer 中。将传入此函数的句柄与        xOneShotTimer 进行比较，以确定是一次性定时器还是自动重载定时器到期，然后输出一个        字符串以显示执行回调的时间。*/        if( xTimer == xOneShotTimer )        {            vPrintStringAndNumber( "One-shot timer callback executing", xTimeNow );        }        else        {            /*xTimer不等于 xOneShotTimer，所以一定是自动重载定时器到期，调用了回掉函数。*/            vPrintStringAndNumber( "Auto-reload timer callback executing", xTimeNow );            if( ulExecutionCount == 5 )            {                /*自动重载定时器执行 5 次后停止。此回调函数在 RTOS 守护进程任务的上下文中执行，                因此不能调用任何可能将守护进程任务置于阻塞状态的函数。因此，使用阻塞时间 0。*/                xTimerStop( xTimer, 0 );             }        } }</code></pre><p>清单 81. 示例 14 中使用的定时器回调函数</p><p>示例 14 产生的输出如图 45 所示。可以看到，自动重载定时器只执行了五次。</p><p><img src="image-20240401025314788.png" alt="图 45 执行示例 14 时产生的输出"></p><h2 id="更改定时器的周期"><a href="#更改定时器的周期" class="headerlink" title="更改定时器的周期"></a>更改定时器的周期</h2><p>每个官方 FreeRTOS 移植都提供了一个或多个示例工程。大多数示例项目都是在运行中不断自检，LED用于提供项目状态的可视反馈；如果自检总是通过，则LED缓慢闪烁，如果自检失败，则LED快速闪烁。</p><p>一些示例工程在任务中执行自检，并使用 <code>vTaskDelay()</code> 函数控制LED的翻转速率。其他示例工程在软件定时器回调函数中执行自检，并使用定时器的周期来控制LED的翻转速率。</p><h3 id="xTimerChangePeriod-API函数"><a href="#xTimerChangePeriod-API函数" class="headerlink" title="xTimerChangePeriod()API函数"></a>xTimerChangePeriod()API函数</h3><p>使用 <code>xTimerChangePeriod()</code> 函数更改软件定时器的周期。</p><p>如果 <code>xTimerChangePeriod()</code> 用于更改已在运行的定时器的周期，则该定时器将使用新的周期值重新计算其到期时间。重新计算的到期时间是相对于调用 <code>xTimerChangePeriod()</code> 的时间，而不是相对于定时器最初启动的时间。</p><p>如果使用 <code>xTimerChangePeriod()</code> 来更改处于休眠状态的定时器(未运行的定时器)的周期，则定时器将计算到期时间，并转换到运行状态(定时器将开始运行)。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerChangePeriod()</code>。应该使用中断安全版本 <code>xTimerChangePerodFromISR()</code> 来代替它。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xTimerChangePeriod( TimerHandle_t xTimer,                                 TickType_t xNewTimerPeriodInTicks,                                TickType_t xTicksToWait );</code></pre><p>清单 82.  xTimerChangePeriod() API 函数原型</p><p>表 31 xTimerChangePeriod() 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTimerPeriodInTicks</td><td>软件定时器的新的周期，以滴答为单位指定。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerChangePeriod()</code> 使用定时器命令队列向守护进程任务发送 <code>"change Period"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerChangePeriod()</code> 将立即返回。<br><code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在启动调度程序之前调用了 <code>xTimerChangePeriod()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerChangePeriod()</code> 的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td></tr><tr><td>返回值</td><td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"Change Period"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table></div><p>清单 83 展示了包含自检的 FreeRTOS 例程是怎么在软件定时器的回调函数中使用 <code>xTimerChangePeriod()</code> 在自检失败时提高LED闪烁速度的。执行自检的软件定时器被称为 “检查定时器 —- check timer”。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 检查定时器的创建周期为3000毫秒，导致LED每3秒切换一次。如果自检功能检测到意外状态，则检查定时器的周期将更改为仅200毫秒，从而导致更快的翻转速率。*/ const TickType_t xHealthyTimerPeriod = pdMS_TO_TICKS( 3000 ); const TickType_t xErrorTimerPeriod = pdMS_TO_TICKS( 200 ); /* 检查定时器使用的回调函数。 */ static void prvCheckTimerCallbackFunction( TimerHandle_t xTimer ) { static BaseType_t xErrorDetected = pdFALSE;     if( xErrorDetected == pdFALSE )     {         /* 尚未检测到任何错误。再次运行自检功能。该函数要求示例创建的每个任务        报告自己的状态，并检查所有任务是否实际上仍在运行(因此能够正确报告其状态)。*/         if( CheckTasksAreRunningWithoutError() == pdFAIL )         {             /*一个或多个任务报告意外状态，可能发生了错误。            减少检查定时器的周期以提高此回调函数的执行速率，这样做还可以提高 LED 的切换速率。            此回调函数在 RTOS 守护进程任务的上下文中执行，因此使用阻塞时间 0 来确保守护进程任务永            远不会进入阻塞状态。*/             xTimerChangePeriod( xTimer,            /* 正要更新的定时器。*/                                 xErrorTimerPeriod, /* 定时器的新周期*/                                 0 );               /* 发送此命令时不要阻塞。 */         }         /* 锁定已检测到错误。 */         xErrorDetected = pdTRUE;     }     /* 切换 LED。LED 翻转的速率取决于调用此函数的频率，    该频率由检查定时器的周期确定。如果    CheckTasksAreRunningWithoutError() 曾经返回 pdFAIL，    则定时器的周期将从 3000ms 减少到 200ms。*/     ToggleLED(); }</code></pre><p>清单 83. 使用 xTimerChangePeriod()</p><h2 id="重置一个定时器"><a href="#重置一个定时器" class="headerlink" title="重置一个定时器"></a>重置一个定时器</h2><p>重置软件定时器意味着重新启动定时器；计时器的到期时间将根据重置计时器的时间重新计算，而不是相对于计时器最初启动的时间。图 46 演示了这一点，它显示了一个以 6 为周期启动的定时器，然后重置两次，最后到期并执行其回调函数。</p><p><img src="image-20240401041311370.png" alt="图 46. 启动和重置周期为 6 个滴答的软件定时器"></p><p>参考图 46：</p><ul><li>定时器 1 在 t1 时刻启动。它的周期为 6，因此它执行回调函数的时间最初计算为 t7，即启动后的 6 个滴答。</li><li>定时器1在到达 t7 时刻之前重置，也就是在它到期并执行其回调函数之前被重置。定时器 1 在 t5 时刻 被重置，因此它将执行其回调函数的时间被重新计算为 t11，即它被重置后的6个滴答。</li><li>定时器 1 在 t11 时刻之前再次重置，因此在其到期并执行其回调函数之前再次复位。定时器1在 t9 时刻被重置，因此它将执行其回调函数的时间被重新计算为 t15，这是它上次被重置后的6个滴答。</li><li>定时器1 不会再次重置，因此它在 t15 时刻到期，并且相应地执行其回调函数。</li></ul><h3 id="xTimerReset-API函数"><a href="#xTimerReset-API函数" class="headerlink" title="xTimerReset() API函数"></a>xTimerReset() API函数</h3><p>使用 <code>xTimerReset()</code> API函数重置定时器。</p><p><code>xTimerReset()</code> 还可用于启动处于休眠状态的定时器。</p><blockquote><p>注意：切勿从中断服务例程调用 <code>xTimerReset()</code>。应该使用中断安全版本 <code>xTimerResetFromISR()</code> 来代替它。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );</code></pre><p>清单 84. xTimerReset() API 函数原型</p><p>表 32. xTimerReset()参数和返回值</p><div class="table-container"><table><thead><tr><th>参数/返回值</th><th>描述</th></tr></thead><tbody><tr><td>xTimer</td><td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td></tr><tr><td>xTicksToWait</td><td><code>xTimerReset()</code> 使用定时器命令队列向守护进程任务发送 <code>"reset"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerReset()</code> 将立即返回。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有期限)，以等待定时器命令队列中的空间变得可用。</td></tr><tr><td>返回值</td><td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"reset"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td></tr></tbody></table></div><h3 id="示例-15-重置软件定时器"><a href="#示例-15-重置软件定时器" class="headerlink" title="示例 15. 重置软件定时器"></a>示例 15. 重置软件定时器</h3><p>此示例模拟手机上的背光行为。背光：</p><ul><li>按下某个按键时打开。</li><li>如果在一定时间段内按下按键，则保持开启。</li><li>如果在一定时间段内没有按下按键，则自动关闭。</li></ul><p>使用一次性软件定时器来实现此行为：</p><ul><li>按下按键时打开 [模拟] 背光，在软件定时器的回调函数中关闭 [模拟] 背光。</li><li>每次按键按下，软件定时器重置。</li><li>因此，需要按下按键防止背光熄灭的时间段等于软件定时器的周期；如果在定时器到期之前没有通过按键重置软件定时器，则执行定时器的回调功能，关闭背光。</li></ul><p><code>xSimulatedBacklightOn</code> 变量保存背光状态。<code>xSimulatedBacklightOn</code> 设置为pdTRUE表示背光打开，设置为 <code>pdFALSE</code> 表示背光关闭。</p><p>软件定时器回调函数如清单85所示。</p><pre class=" language-lang-c"><code class="language-lang-c">static void prvBacklightTimerCallback( TimerHandle_t xTimer ){     TickType_t xTimeNow = xTaskGetTickCount();         /* 背光定时器超时，关闭背光。*/        xSimulatedBacklightOn = pdFALSE;         /*打印背光关闭的时间。*/         vPrintStringAndNumber( "Timer expired, turning backlight OFF at time\t\t", xTimeNow); }</code></pre><p>清单 85. 示例 15 中使用的一次性定时器的回调函数</p><p>示例 15 创建一个任务来轮询键盘[1]。清单 86 显示了该任务，但是由于下一段中描述的原因，清单 86 并不是最佳设计的代表。</p><p><em>[1].打印到 Windows 控制台和从 Windows 控制台读取按键都会导致执行 Windows 系统调用。Windows 系统调用 ( 包括使用 Windows 控制台、磁盘或 TCP/IP 堆栈 )，可能会对 FreeRTOS Windows 移植的行为产生不利影响，因此通常应避免使用。</em></p><p>使用FreeRTOS允许您的应用程序是事件驱动的。事件驱动设计非常有效地使用处理时间，因为处理时间仅在事件已发生时使用，并且处理时间不会浪费在轮询尚未发生的事件上。示例 15 不能由事件驱动，因为在使用 FreeRTOS Windows 移植时处理键盘中断是不切实际的，因此必须使用效率低得多的轮询技术。如果清单 86 是一个中断服务例程，那么将使用 <code>xTimerResetFromISR()</code> 代替 <code>xTimerReset()</code>。</p><pre class=" language-lang-c"><code class="language-lang-c">static void vKeyHitTask( void *pvParameters ) { const TickType_t xShortDelay = pdMS_TO_TICKS( 50 );TickType_t xTimeNow;    vPrintString( "Press a key to turn the backlight on.\r\n" );     /* 理想情况下，应用程序应该是事件驱动的，并使用中断来处理按键。    在使用 FreeRTOS Windows 移植时使用键盘中断是不切实际的，    因此此任务用于轮询按键。*/    for( ;; )    {        /* 按键被按下了吗?*/         if( _kbhit() != 0 )         {            /* 已按下一个按键。记录时间。 */             xTimeNow = xTaskGetTickCount();            if( xSimulatedBacklightOn == pdFALSE )            {                /* 背光已关闭，因此将其打开并打印其打开的时间。 */                 xSimulatedBacklightOn = pdTRUE; vPrintStringAndNumber(                                            "Key pressed, turning backlight ON at time\t\t", xTimeNow );            }            else            {                 /* 背光已打开，因此打印一条消息，说明定时器即将重置以及重置的时间。*/                vPrintStringAndNumber(                                    "Key pressed, resetting software timer at time\t\t", xTimeNow );              }              /* 重置软件定时器。如果之前关闭了背光，则此调用将启动定时器。             如果背光先前处于打开状态，则此调用将重新启动定时器。             真实的应用程序可以读取中断中的按键。如果此函数是中断服务例程，             则必须使用xTimerResetFromISR()而不是xTimerReset()。*/             xTimerReset( xBacklightTimer, xShortDelay );              /* 读取并丢弃按下的按键 --- 这在这个简单的示例中不是必需的。*/              ( void ) _getch();            }      }}</code></pre><p>清单 86. 示例15中用于重置软件定时器的任务</p><p>执行示例 15 时产生的输出如图 47 所示。参考图 47 ：</p><ul><li>在滴答计数为 812 的时候发生第一次按键。此时，打开背光，并启动一次性定时器。</li><li>当滴答计数为 1813、3114、4015 和 5016 时，发生了进一步的按键。所有这些按键都会导致定时器在到期之前被重置。</li><li>定时器在滴答计数为 10016 时到期。此时，关闭背光。</li></ul><p><img src="image-20240401055137191.png" alt="图 47 执行示例 15 时产生的输出"></p><p>在图 47 中可以看到，定时器有 5000 个滴答的周期；最后一次按下按键后，背光恰好在 5000 次滴答后关闭，所以在最后一次重置定时器之后有 5000 个滴答。</p>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 3 任务管理</title>
      <link href="/Blogs/2024/06/15/chapter-3-ren-wu-guan-li/"/>
      <url>/Blogs/2024/06/15/chapter-3-ren-wu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-3-任务管理"><a href="#Chapter-3-任务管理" class="headerlink" title="Chapter 3 任务管理"></a>Chapter 3 任务管理</h1><h2 id="3-1-章节介绍和范围"><a href="#3-1-章节介绍和范围" class="headerlink" title="3.1 章节介绍和范围"></a>3.1 章节介绍和范围</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章旨在让读者更好地理解 : </p><ul><li>FreeRTOS 如何为应用程序中的每个任务分配处理时间。</li><li>FreeRTOS 如何选择在任何给定时间应该执行哪个任务。</li><li>每个任务的相对优先级如何影响系统行为。 </li><li>任务可以存在的状态。</li></ul><p>读者还应该充分了解 : </p><ul><li>如何实现任务。</li><li>如何创建任务的一个或多个实例 ( instance ) 。</li><li>如何使用任务参数。</li><li>如何更改已创建任务的优先级。</li><li>如何删除任务。</li><li>如何使用任务实现周期性处理 ( 软件定时器将在后面的章节中讨论 ) 。</li><li>空闲任务何时执行以及如何使用。</li></ul><p>本章介绍的概念对于理解如何使用 FreeRTOS 以及 FreeRTOS 应用程序的行为至关重要。因此，这是书中最详细的一章。</p><h2 id="3-2-任务函数"><a href="#3-2-任务函数" class="headerlink" title="3.2 任务函数"></a>3.2 任务函数</h2><p>任务被实现为 C 函数。 它们唯一的特殊之处是它们的原型，它必须返回 <code>void</code> 并接受一个 <code>void</code> 指针参数。 清单 11 展示了原型。</p><pre class=" language-lang-c"><code class="language-lang-c">void ATaskFunction( void *pvParameters );</code></pre><p>清单 11. 任务函数原型</p><p>每个任务本身都是一个小程序。 它有一个入口点，通常会在无限循环内永远运行，并且不会退出。典型任务的结构如清单 12 所示。</p><p>不得允许 FreeRTOS 任务以任何方式从其实现函数返回 —— 它们不得包含 <code>return</code> 语句，并且不得允许执行到函数末尾之后。如果不再需要某个任务，则应将其显式删除。清单 12 也演示了这一点。</p><p>单个任务函数定义可用于创建任意数量的任务 —— 每个创建的任务都是一个单独的执行实例 ( instance )，具有自己的堆栈和在任务本身内定义的任何自动 ( 堆栈 ) 变量的副本。</p><pre class=" language-lang-c"><code class="language-lang-c">void ATaskFunction( void *pvParameters ){/* 变量可以像普通函数一样声明。使用此示例函数创建的任务的每个实例都将拥有自己的 lVariableExample 变量副本。如果变量被声明为静态，则情况并非如此——在这种情况下，只会存在该变量的一个副本，并且该副本将由每个创建的任务实例共享。 ( 添加到变量名称的前缀在第 1.5 节“数据类型和编码风格指南”中描述。 )*/int32_t lVariableExample = 0;    /* 任务通常会以无限循环的形式实现。 */    for( ;; )    {        /* 实现任务功能的代码将放在这里。 */    }    /* 如果任务实现突破上述循环，则必须在到达其实现功能结束之前删除该任务。 传递给 vTaskDelete()     API 函数的 NULL 参数指示要删除的任务是调用（当前）任务。 用于命名 API 函数的约定在第 0 节中    描述，使用早于 V9.0.0 的 FreeRTOS 版本的项目必须构建一个 heap_n.c 文件。 从     FreeRTOS V9.0.0 开始，只有在 FreeRTOSConfig.h 中将 configSUPPORT_DYNAMIC_ALLOCATION    设置为 1 或者未定义 configSUPPORT_DYNAMIC_ALLOCATION 时才需要 heap_n.c 文件。 有关更多    信息，请参阅第 2 章堆内存管理。 数据类型和编码风格指南。    如果任务实现从上述循环中突破，则必须在到达其实现函数末尾之前删除该任务。    传递给 vTaskDelete() API 函数的 NULL 参数指示要删除的任务是调用 (此) 任务。    用于命名 API 函数的约定在第 0 节中进行了描述，使用早于 V9.0.0 的 FreeRTOS     版本的项目必须构建 heap_n.c 文件之一。从 FreeRTOS V9.0.0 开始，    仅当 FreeRTOSConfig.h 中的 configSUPPORT_DYNAMIC_ALLOCATION 设置为 1     或 configSUPPORT_DYNAMIC_ALLOCATION 未定义时才需要 heap_n.c 文件。    有关详细信息，请参阅第 2 章“堆内存管理”。      数据类型和编码风格指南。*/    vTaskDelete( NULL );}</code></pre><p>清单 12.  一个典型的任务函数的结构</p><h2 id="3-3-顶层任务状态"><a href="#3-3-顶层任务状态" class="headerlink" title="3.3 顶层任务状态"></a>3.3 顶层任务状态</h2><p>应用程序可以包含许多任务。 如果运行应用程序的处理器是单核的，那么在任何给定时间只能执行一个任务。 这意味着任务可以存在两种状态：运行和未运行。 首先考虑这种简单化的模型，但请记住，这是一种过度简化。 在本章的后面，显示 “未运行” 状态实际上包含许多子状态。</p><p>一个应用程序可以包含许多任务。如果运行应用程序的处理器是单核的，则在任何给定时间只能执行一个任务。这意味着任务可以存在于两种状态之一：<code>运行 ( Running )</code> 和 <code>非运行 ( No Running )</code> 。首先考虑这种简单化的模型，但请记住，它过于简单化了。本章后面显示 <code>"非运行 ( No Running )"</code> 状态实际上包含许多子状态。</p><p>当任务处于运行状态时，处理器正在执行任务的代码。当任务处于 <code>"非运行 ( No Running )"</code> 状态时，该任务处于休眠状态，其状态已被保存，以便下次调度程序决定它应该进入 <code>"运行 ( Running ) "</code> 状态时恢复执行。   当任务恢复执行时，它会从上次离开 <code>"运行 ( Running )"</code> 状态之前即将执行的指令开始执行。</p><p><img src="image-20240526132629539.png" alt="图 9. 顶层任务状态和转换"></p><p>从 “未运行” 状态转换为 “运行” 状态的任务被称为 “切入” 或 “换入”。 相反，从 “运行” 状态转换到 “未运行” 状态的任务据说已被 “切出” 或 “换出”。 FreeRTOS 的调度程序是唯一可以切换任务的实体。</p><p>从非运行状态转换到运行状态的任务被称为 <code>"切换入 ( switched in ) "</code> 或 <code>"交换入 ( swapped in )"</code>。相反，从运行状态转换到非运行状态的任务被称为 <code>"切换出 ( switched out )"</code> 或 <code>"交换出 ( swapped out )"</code>。FreeRTOS 调度程序是唯一可以切换入和切换出任务的实体。</p><h2 id="3-4-创建任务"><a href="#3-4-创建任务" class="headerlink" title="3.4 创建任务"></a>3.4 创建任务</h2><h3 id="xTaskCreate-API-函数"><a href="#xTaskCreate-API-函数" class="headerlink" title="xTaskCreate() API 函数"></a>xTaskCreate() API 函数</h3><p>FreeRTOS V9.0.0 还包括 <code>xTaskCreateStatic()</code> 函数，该函数在编译时静态地分配创建任务所需的内存: 使用 FreeRTOS <code>xTaskCreate()</code> API 函数创建任务。这可能是所有 API 函数中最复杂的，因此很不幸，它是第一个遇到的函数，但是必须首先掌握任务，因为它们是多任务系统中最基本的组件。本书附带的所有示例都使用了 <code>xTaskCreate()</code> 函数，因此有大量示例可供参考。</p><p>第 1.5 节 “数据类型和编程样式指南” 描述了所使用的数据类型和命名约定。</p><pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,                         const char* const pcName,                         uint16_t usStackDepth,                         void *pvParameters,                         UBaseType_t uxPriority,                         TaskHandle_t *pxCreatedTask );</code></pre><p>清单 13. <code>xTaskCreate()</code> API 函数原型</p><p>表 8. <code>xTaskCreate()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pvTaskCode</code></td><td>任务只是永不退出的 C 函数，因此通常作为无限循环实现。 <code>pvTaskCode</code> 参数只是一个指向实现任务的函数的指针（实际上，只是函数的名称）。</td></tr><tr><td><code>pcName</code></td><td>任务的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。通过人类可读的名称来识别任务要比尝试通过其句柄来识别任务简单得多。<br><br>应用程序定义的常量 <code>configMAX_TASK_NAME_LEN</code> 定义了任务名称可以采用的最大长度 — 包括空终止符。提供长度超过此最大值的字符串将导致字符串被自动截断。&lt;/p&gt;</td></tr><tr><td><code>usStackDepth</code></td><td>每个任务都有自己的唯一堆栈，该堆栈在任务创建时由内核分配给任务。 <code>usStackDepth</code> 值告诉内核堆栈的大小。<br>该值指定堆栈可以容纳的字数，而不是字节数。 例如，如果堆栈是 32 位宽并且 <code>usStackDepth</code> 作为 100 传入，则将分配 400 字节的堆栈空间（100 * 4 字节）。 堆栈深度乘以堆栈宽度不得超过 <code>uint16_t</code> 类型的变量中可包含的最大值。<br>空闲任务使用的堆栈大小由应用程序定义的常量 <code>configMINIMAL_STACK_SIZE</code> [1] 定义。在 FreeRTOS 演示应用程序中为所使用的处理器架构分配给该常量的值是建议用于任何任务的最小值。如果您的任务使用了大量堆栈的空间，则必须分配一个更大的值。<br>没有简单的方法可以确定任务所需的堆栈空间。   可以计算，但大多数用户会简单地分配一个他们认为合理的值，然后使用FreeRTOS提供的功能来确保分配的空间确实足够，并且RAM不会被不必要地浪费。第 12.3 节 “堆栈溢出” 包含有关如何查询任务实际已使用的最大堆栈空间的信息。</td></tr><tr><td><code>pvParameters</code></td><td>任务函数接受指向 <code>void ( void* )</code> 的指针类型的参数。分配给 <code>pvParameters</code> 的值是传递到任务中的值。   本书中的一些示例演示了如何使用该参数。</td></tr><tr><td><code>uxPriority</code></td><td>定义任务执行的优先级。优先级可以从 0（最低优先级）到 ( <code>configMAX_PRIORITIES</code> – 1)（最高优先级）进行分配。 <code>configMAX_PRIORITIES</code> 是一个用户定义的常量，在 3.5 节中描述。<br>传递高于 ( <code>configMAX_PRIORITIES</code> - 1 ) 的 <code>uxPriority</code> 值将导致分配给任务的优先级被静默地限制为最大合法值。</td></tr><tr><td><code>pxCreatedTask</code></td><td><code>pxCreatedTask</code> 可用于传递正在创建的任务的句柄。然后，该句柄可用于在 API 调用中引用任务，例如更改任务优先级或删除任务<br>如果您的应用程序不需要任务句柄，则可以将 <code>pxCreatedTask</code> 设置为 <code>NULL</code>。</td></tr><tr><td>返回值</td><td>有两种可能的返回值：<br><code>pdPASS</code>：<br>这表明任务已成功创建。<br><code>pdFAIL</code>：<br>这表明任务尚未创建，因为没有足够的堆内存可供FreeRTOS分配足够的RAM来容纳任务数据结构和堆栈。<br>第 2 章提供了有关堆内存管理的更多信息。</td></tr></tbody></table></div><blockquote><p>[1] : 这是 FreeRTOS 源代码使用 <code>configMINIMAL_STACK_SIZE</code> 设置的唯一方式，尽管该常量也在演示应用程序内部使用，以帮助演示在多个处理器架构之间移植。</p></blockquote><h3 id="示例-1-创建任务"><a href="#示例-1-创建任务" class="headerlink" title="示例 1. 创建任务"></a>示例 1. 创建任务</h3><p>此示例演示了创建两个简单任务，然后启动任务执行所需的步骤。这些任务只是周期性地打印出一个字符串，使用一个粗略的空循环来创建周期延迟。这两个任务都是以相同的优先级创建的，除了它们打印出来的字符串之外，它们都是相同的 —— 它们各自的实现见清单14和清单15。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTask1( void *pvParameters ){const char *pcTaskName = "Task 1 is running\r\n";volatile uint32_t ul; /* volatile 以确保 ul 不会被优化掉。 */    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 延迟一段时间。 */        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )        {            /* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */        }    }}</code></pre><p>清单 14. 示例 1 中使用的第一个任务的实现</p><pre class=" language-lang-c"><code class="language-lang-c">void vTask2( void *pvParameters ){const char *pcTaskName = "Task 2 is running\r\n";volatile uint32_t ul; /* volatile 以确保 ul 不会被优化掉。 */    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 延迟一段时间。 */        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )        {            /* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。*/        }    }}</code></pre><p>清单 15. 示例 1 中使用的第二个任务的实现</p><p><code>main()</code> 函数在启动调度程序之前创建任务，有关其实现请参见清单 16。</p><pre class=" language-lang-c"><code class="language-lang-c">int main( void ){    /* 创建两个任务之一。请注意，真正的应用程序应该检查 xTaskCreate()     调用的返回值，以确保任务创建成功。 */    xTaskCreate(    vTask1,  /* 指向实现任务的函数的指针。 */                    "Task 1",/* 任务的文本名称。这只是为了方便调试。 */                    1000,    /* 堆栈深度，小型微控制器将使用比这少得多的堆栈。 */                    NULL,    /* 此示例不使用任务参数。 */                    1,       /* 此任务将以优先级 1 运行。 */                    NULL );  /* 此示例不使用任务句柄。 */    /* 以完全相同的方式，以相同的优先级创建另一个任务。 */    xTaskCreate(vTask2, "Task 2", 1000, NULL, 1, NULL );    /* 启动调度程序，以便任务开始执行。 */    vTaskStartScheduler();        /* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了    关于堆内存管理的更多信息。 */    for( ;; );}</code></pre><p>清单 16. 启动示例 1 任务</p><p>执行该示例将产生图 10 中所示的输出。</p><p><img src="image-20240526181455382.png" alt="图 10. 执行示例 1 时产生的输出"></p><blockquote><p>屏幕截图显示每个任务在下一个任务执行之前打印一次其消息。   这是使用 FreeRTOS Windows 模拟器产生的人为场景。 Windows 模拟器并不是真正的实时。此外，写入 Windows 控制台需要相对较长的时间，并会导致一系列 Windows 系统调用。在具有快速且非阻塞打印功能的真正嵌入式目标上执行相同的代码可能会导致每个任务在切换出去以允许其他任务运行之前多次打印其字符串。</p></blockquote><p>图 10 显示了两个任务似乎同时执行；然而，由于两个任务都在同一处理器核心上执行，因此情况并非如此。实际上，这两个任务都在快速进入和退出运行状态。两个任务都以相同的优先级运行，因此在同一处理器核心上共享时间。它们的实际执行模式如图 11 所示。</p><p>图11底部的箭头显示了从时间 t1 开始的时间流逝。彩色线显示每个时间点正在执行哪个任务 —— 例如，任务 1 在时间 t1 和时间 t2 之间执行。</p><p>任何时候只有一个任务可以处于运行状态。 因此，当一个任务进入 <code>"运行 ( Running ) "</code>  状态 ( 任务被切入 ) 时，另一个任务进入 <code>"非运行 ( No Running ) "</code> 状态（任务被切出）。 </p><p>任一时刻只能有一个任务处于运行状态。因此，当一个任务进入“正在运行”状态（任务被切换入）时，另一个任务进入“未运行”状态（任务被切换出）。</p><p><img src="image-20240526182954329.png" alt="图 11. 两个示例 1 任务的实际执行模式"></p><p>示例 1 在启动调度程序之前从 <code>main()</code> 中创建了两个任务。也可以从另一个任务中创建一个任务。例如，可以从任务 1 中创建任务 2，如清单 17 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTask1( void *pvParameters ){const char *pcTaskName = "Task 1 is running\r\n";volatile uint32_t ul; /* volatile 以确保 ul 不会被优化掉。 */    /* 如果正在执行此任务代码，则调度程序必须已经启动。    在进入无限循环之前创建另一个任务。 */    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 延迟一段时间。 */        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )        {            /* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */        }    }}</code></pre><p>清单 17. 调度程序启动后从另一个任务中创建一个任务</p><h3 id="示例-2-使用任务参数"><a href="#示例-2-使用任务参数" class="headerlink" title="示例 2. 使用任务参数"></a>示例 2. 使用任务参数</h3><p>在示例 1 中创建的两个任务是字面上的，它们之间的唯一区别是它们打印出来的文本字符串。 相反，可以通过创建单个任务实现的两个实例来消除这种重复。 然后可以使用任务参数将其应打印的字符串传递给每个任务。</p><p>清单 18 包含示例 2 使用的单任务函数（ <code>vTaskFunction</code> ）的代码。此单个函数替换了示例 1 中使用的两个任务函数（ <code>vTask1</code> 和  <code>vTask2</code> ）。请注意如何将任务参数转换为 <code>char *</code> 以获得任务应该打印出来的字符串。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskFunction( void *pvParameters ){char *pcTaskName;volatile uint32_t ul; /* volatile 以确保 ul 不被优化掉。 */    /* 要打印出来的字符串是通过参数传入的。将其强制转换为字符指针。 */    pcTaskName = ( char * ) pvParameters;    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 延迟一段时间。 */        for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )        {            /* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */        }    }}</code></pre><p>清单 18. 用于在示例 2 中创建两个任务的单个任务函数</p><p>即使现在只有一个任务实现（<code>vTaskFunction</code>），也可以创建多个已定义任务的实例。每个创建的实例将在 FreeRTOS 调度程序的控制下独立执行。</p><p>清单 19 演示了如何使用 <code>xTaskCreate()</code> 函数的 <code>pvParameters</code> 参数将文本字符串传递给任务。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 定义将作为任务参数传入的字符串。它们被定义为 const 并且不在堆栈上，以确保它们在任务执行时保持有效。 */static const char *pcTextForTask1 = "Task 1 is running\r\n";static const char *pcTextForTask2 = "Task 2 is running\r\n";int main( void ){    /* 创建两个任务之一。 */    xTaskCreate(    vTaskFunction,         /* 指向实现任务的函数的指针。 */                    "Task 1",              /* 任务的文本名称。这只是为了方便调试。 */                    1000,                  /* 堆栈深度 - 小型微控制器将使用比这少得多的堆栈。 */                    (void*)pcTextForTask1, /* 使用任务参数将要打印的文本传递到任务中。 */                    1,                     /* 这个任务将以优先级 1 运行。 */                    NULL );                /* 本例中没有使用任务句柄。 */    /* 用完全相同的方法创建另一个任务。注意，这一次将从同一个任务实现 (vTaskFunction)     创建多个任务。只有参数中传递的值不同。正在创建同一任务的两个实例。 */    xTaskCreate( vTaskFunction, "Task 2", 1000, (void*)pcTextForTask2, 1, NULL );    /* 启动调度程序，使任务开始执行。 */    vTaskStartScheduler();        /* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆    内存管理的更多信息。 */    for( ;; );}</code></pre><p>清单 19. 示例 2 所使用的 <code>main()</code> 函数</p><p>示例 2 的输出与图 10 中示例 1 所示的输出完全相同。</p><h2 id="3-5-任务优先级"><a href="#3-5-任务优先级" class="headerlink" title="3.5 任务优先级"></a>3.5 任务优先级</h2><p><code>xTaskCreate()</code> API 函数的 <code>uxPriority</code> 参数为正在创建的任务分配初始优先级。调度程序启动后，可以使用 <code>vTaskPrioritySet()</code> API 函数更改优先级。</p><p>可用优先级的最大数量由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configMAX_PRIORITIES</code> 编译时配置常量设置。低数字优先级值表示低优先级任务，优先级 0 是可能的最低优先级。因此，可用优先级的范围是 0 到 ( <code>configMAX_PRIORITIES</code> – 1)。   任意数量的任务可以共享相同的优先级 —— 确保最大的设计灵活性。</p><p>FreeRTOS 调度程序可以使用两种方法之一来决定哪个任务将处于运行状态。 <code>configMAX_PRIORITIES</code> 可以设置的最大值取决于所使用的方法：</p><ol><li><p>通用方法：通用方法在 C 中实现，可以与所有 FreeRTOS 架构移植一起使用。</p><p>使用通用方法时，FreeRTOS 不会限制 <code>configMAX_PRIORITIES</code> 可以设置的最大值。 但是，始终建议将 <code>configMAX_PRIORITIES</code> 值保持在必要的最小值，因为该值越高，消耗的 RAM 就越多，并且最坏情况下的执行时间也就越长。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 0，或者如果 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 未定义，或者通用方法是为正在使用的 FreeRTOS 移植提供的唯一方法，则将使用通用方法。</p></li><li><p>架构优化方法：</p><p>体系结构优化方法使用少量汇编代码，并且比通用方法更快。 <code>configMAX_PRIORITIES</code> 置不会影响最坏情况下的执行时间。</p><p>如果使用架构优化方法，则 <code>configMAX_PRIORITIES</code> 不能大于 32。与通用方法一样，建议将 <code>configMAX_PRIORITIES</code> 保持在必要的最小值，因为其值越高，消耗的 RAM 就越多。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 1，则将使用架构优化方法。并非所有 FreeRTOS 移植都提供架构优化方法。</p></li></ol><p>FreeRTOS 调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务。 当多个具有相同优先级的任务能够运行时，调度程序将依次将每个任务转入和转出运行状态。</p><h2 id="3-6-时间测量和嘀嗒中断"><a href="#3-6-时间测量和嘀嗒中断" class="headerlink" title="3.6 时间测量和嘀嗒中断"></a>3.6 时间测量和嘀嗒中断</h2><p>第 3.12 节 “调度算法” 描述了一个名为 “时间切片 ( time slicing )” 的可选功能。 到目前为止所提供的示例中使用了时间切片，并且是在它们生成的输出中观察到的行为。在示例中，两个任务都是以相同的优先级创建的，并且两个任务始终能够运行。 因此，每个任务执行一个 <code>"时间片 ( time slice )"</code>，在时间片开始时进入运行状态，在时间片结束时退出运行状态。在图 11 中，t1 和 t2 之间的时间等于单个时间片。</p><p>为了能够选择下一个要运行的任务，调度程序本身必须在每个时间片 <strong>[1]</strong> 的末尾执行。称为 <code>"嘀嗒中断 ( tick interrupt )"</code> 的周期性中断用于此目的。时间片的长度由嘀嗒中断频率有效地设置，该频率由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100 (Hz)，则时间片将为 10 毫秒。两次嘀嗒中断之间的时间称为 <code>"嘀嗒周期 (tick period)"</code>。   一个时间片等于一个嘀嗒周期。</p><blockquote><p>[1] : 需要注意的是，时间片的末尾并不是调度程序可以选择运行新任务的唯一位置；正如本书将演示的那样，在当前正在执行的任务进入阻塞状态后，或者当中断将更高优先级的任务移至就绪状态时，调度程序还将选择一个新任务立即运行。</p></blockquote><p>为了能够选择要运行的下一个任务，调度程序本身必须在每个时间片的末尾执行。 称为 “嘀嗒中断” 的周期性中断用于此目的。 时间片的长度由嘀嗒中断频率有效设置，嘀嗒中断频率由应用程序在 <code>FreeRTOSConfig.h</code> 中定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。 例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100（Hz），则时间片将为 10 毫秒。 两次嘀嗒中断之间的时间称为 “嘀嗒期”。 一个时间片等于一个嘀嗒时间段。</p><p>图 11 可以展开来显示调度程序本身在执行序列中的执行情况。如图 12 所示，其中顶部行显示调度程序何时执行，细箭头显示从任务到嘀嗒中断，然后从嘀嗒中断返回到不同任务的执行顺序。</p><p><code>configTICK_RATE_HZ</code> 的最佳值取决于正在开发的应用程序，但其值通常为 100。</p><p><img src="image-20240527235850366.png" alt="图 12. 执行序列展开以显示嘀嗒中断执行"></p><p>FreeRTOS API 调用始终以嘀嗒周期的倍数指定时间，这通常被简单地称为嘀嗒。<code>pdMS_TO_TICKS()</code> 宏将以毫秒为单位的时间转换为以嘀嗒为单位的时间。可用的分辨率取决于定义的嘀嗒频率，如果嘀嗒频率高于 1 KHz (<code>configTICK RATE HZ</code> 大于 1000)，则不能使用 <code>pdMS_TO_TICKS()</code>。则无法使用 <code>pdMS_TO_TICKS()</code>。清单 20 显示了如何使用 <code>pdMS_TO_TICKS()</code> 将指定为 200 毫秒的时间转换为以嘀嗒为单位指定的等效时间。</p><pre class=" language-lang-c"><code class="language-lang-c">/* pdMS_TO_TICKS() 将以毫秒为单位的时间作为其唯一参数，并计算为以嘀嗒周期为单位的等效时间。 此示例显示 xTimeInTicks 设置为等于 200 毫秒的嘀嗒周期数。 */TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );</code></pre><p>清单 20. 使用 <code>pdMS_TO_TICKS()</code> 宏将 200 毫秒转换为嘀嗒周期中的等效时间</p><blockquote><p>注意 : 不建议在应用程序中直接以嘀嗒为单位指定时间，而是使用 <code>pdMS_TO_TICKS()</code> 宏来指定以毫秒为单位的时间，这样做可以确保如果嘀嗒频率发生变化，应用程序中指定的时间不会发生变化。</p></blockquote><p><code>"嘀嗒计数 ( tick count )"</code> 值是自调度器启动以来发生的嘀嗒中断的总数，假设嘀嗒计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为时间一致性由 FreeRTOS 内部管理。</p><p>第 3.12 节 “调度算法” 描述了影响调度程序何时选择要运行的新任务以及何时执行嘀嗒中断的配置常量。</p><h3 id="示例-3-使用优先级进行实验"><a href="#示例-3-使用优先级进行实验" class="headerlink" title="示例 3. 使用优先级进行实验"></a>示例 3. 使用优先级进行实验</h3><p>调度程序将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。 到目前为止，在我们的示例中，已经以相同的优先级创建了两个任务，因此它们是依次进入和退出运行状态的。 此示例研究当示例 2 中创建的两个任务之一的优先级发生更改时会发生什么情况。 这次，第一个任务将以优先级 1 创建，第二个任务将以优先级 2 创建。创建任务的代码如清单 21 所示。实现这两个任务的单个函数没有改变；它仍然只是定期打印出一个字符串，使用空循环来创建延迟。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 定义将作为任务参数传入的字符串。它们被定义为 const 并且不在堆栈上，以确保它们在任务执行时保持有效。 */static const char *pcTextForTask1 = "Task 1 is running\r\n";static const char *pcTextForTask2 = "Task 2 is running\r\n";int main( void ){    /* 以优先级 1 创建第一个任务。优先级是倒数第二个参数。 */    xTaskCreate( vTaskFunction, "Task 1", 1000, (void*)pcTextForTask1, 1, NULL );    /* 以优先级 2 创建第二个任务，该任务高于优先级 1。优先级是倒数第二个参数。。 */    xTaskCreate( vTaskFunction, "Task 2", 1000, (void*)pcTextForTask2, 2, NULL );    /* 启动调度程序以便任务开始执行。 */    vTaskStartScheduler();        /* 不会到达这里。 */    return 0;}</code></pre><p>清单 21. 创建两个不同优先级的任务</p><p>示例 3 生成的输出如图 13 所示。</p><p>调度程序将始终选择能够运行的最高优先级任务。 任务 2 的优先级高于任务 1，并且始终能够运行；因此，任务 2 是唯一进入运行状态的任务。 由于任务 1 永远不会进入运行状态，因此它永远不会打印出其字符串。则称任务1被任务2 “ 剥夺 “ 了处理时间。( Task 1 is said to be ‘starved’ of processing time by Task 2.  )</p><p><img src="image-20240529001654557.png" alt="图 13. 以不同优先级运行两个任务"></p><p>任务2总是能够运行，因为它永远不需要等待任何东西  —— 它要么是在一个空循环中循环，要么打印到终端。</p><p>图 14 显示了示例 3 的执行顺序。</p><p><img src="image-20240529001913254.png" alt="图 14. 当一个任务的优先级高于另一个任务时的执行模式"></p><h2 id="3-7-展开说明-“-非运行-“-状态"><a href="#3-7-展开说明-“-非运行-“-状态" class="headerlink" title="3.7 展开说明 “ 非运行 “ 状态"></a>3.7 展开说明 “ 非运行 “ 状态</h2><p>到目前为止，创建的任务总是有处理要执行，并且不需要等待任何事情 —— 因为它们不需要等待任何事情，所以它们总是能够进入运行状态。这种类型的 “ 连续处理 ( continuous processing ) “ 任务的用途有限，因为它们只能以最低优先级创建。如果它们以任何其他优先级运行，它们将完全阻止优先级较低的任务运行。</p><p>为了使任务有用，必须重写它们以使其成为事件驱动的。 事件驱动的任务只有在触发它的事件发生后才能执行工作 ( 处理 )，并且在该事件发生之前无法进入运行状态。 调度程序始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度程序无法选择它们，而必须选择能够运行的较低优先级任务。 因此，使用事件驱动的任务意味着可以以不同的优先级创建任务，而最高优先级的任务不会耗尽所有较低优先级的任务的处理时间。</p><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>正在等待事件的任务被认为处于 <code>"阻塞 ( Blocked ) "</code> 状态，这是 <code>"非运行 ( No Running ) "</code> 状态的子状态。</p><p>任务可以进入阻止状态以等待两种不同类型的事件:</p><ol><li>时间 ( 与时间相关 time-related ) 事件 Temporal events —— 该事件要么是延迟期到期，要么是达到绝对时间。例如，任务可能会进入阻塞状态，等待 10 毫秒过去。</li><li>同步事件 Synchronization events —— 事件源自另一个任务或中断。例如，任务可能会进入阻塞状态以等待数据到达队列。   同步事件涵盖了广泛的事件类型。</li></ol><p>FreeRTOS 的队列，二进制信号量，计数信号量，互斥量，递归互斥量，事件组和直接到任务通知都可用于创建同步事件。 所有这些功能都将在本书的后续章节中介绍。</p><p>任务可以在具有超时的同步事件上阻塞，从而有效地同时阻塞两种类型的事件。例如，任务可以选择等待最多 10 毫秒以便数据到达队列。如果 10 毫秒内有数据到达，或者 10 毫秒后没有数据到达，任务将离开阻塞状态。</p><h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p><code>" 暂停 ( Suspended ) "</code> 也是 <code>"非运行 ( No Running ) "</code> 状态的子状态。 处于暂停状态的任务对调度程序是不可用的。 进入暂停状态的唯一方法是通过调用 <code>vTaskSuspend()</code> API 函数，退出暂停状态的唯一方法是通过调用 <code>vTaskResume()</code> 或 <code>xTaskResumeFromISR()</code> API 函数。大多数应用程序不使用暂停状态。</p><h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><p>处于 “未运行” 状态但未被阻塞或挂起的任务被称为处于 “就绪” 状态。 它们能够运行，因此 “准备好” 运行，但当前不处于 “运行” 状态。</p><p>处于 <code>"非运行 ( No Running )"</code> 状态但未被 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 的任务被称为 <code>"就绪 ( Ready ) "</code> 状态。它们能够运行，因此 “准备 ( ready ) “ 运行，但目前不处于 <code>"运行 ( Running ) "</code> 状态。</p><h3 id="完成状态转换图"><a href="#完成状态转换图" class="headerlink" title="完成状态转换图"></a>完成状态转换图</h3><p>图 15 扩展了之前过于简化的状态图，以包含本节中描述的所有<code>"非运行 ( No Running )"</code>子状态。到目前为止，示例中创建的任务尚未使用 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 状态；它们仅在  <code>"就绪 ( Ready ) "</code> 状态和 <code>"运行 ( Running ) "</code> 状态之间转换 —— 在图 15 中用粗线突出显示。</p><p><img src="image-20240529231955847.png" alt="图 15. 完整任务状态机" style="zoom:67%;"></p><h3 id="示例-4-使用阻塞状态创建延迟"><a href="#示例-4-使用阻塞状态创建延迟" class="headerlink" title="示例 4. 使用阻塞状态创建延迟"></a>示例 4. 使用阻塞状态创建延迟</h3><p>到目前为止，示例中创建的所有任务都是 “周期性的”——它们会延迟一段时间并打印出字符串，然后再延迟一次，依此类推。延迟是使用空循环非常粗略地生成的 —— 任务有效地轮询一个递增的循环计数器，直到它达到固定值。示例 3 清楚地展示了这种方法的缺点。优先级较高的任务在执行空循环时始终保持运行状态，” 剥夺 ( starving ) “ 了优先级较低的任务的任何处理时间。</p><p>任何形式的轮询都存在其他一些缺点，其中最主要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最长的处理时间，因此浪费了处理器周期。示例 4 通过将轮询空循环替换为对 <code>vTaskDelay()</code> API 函数的调用来纠正此行为，该函数的原型如清单 22 所示。新任务定义如清单 23 所示。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelay</code> 设置为 1 时，<code>vTaskDelay()</code> API 函数才可用。</p><p><code>vTaskDelay()</code> 将调用任务置于阻塞状态，并持续固定数量的嘀嗒中断。任务处于阻塞状态时不使用任何处理时间，因此任务仅在实际有工作要做时才使用处理时间。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskDelay( TickType_txTicksToDelay );</code></pre><p>清单 22. <code>vTaskDelay()</code> 的函数原型</p><p>表 9. <code>vTaskDelay()</code> 参数 </p><div class="table-container"><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>xTicksToDelay</code></td><td>调用任务在转换回就绪状态之前将保持在阻塞状态的嘀嗒中断数。<br>例如，调用 <code>vTaskDelay(pdMS_TO_TICKS(100))</code> 将导致调用任务保持阻塞状态 100 毫秒。&lt;/p&gt;例如，如果一个任务在嘀嗒 ( tick ) 计数为 <code>10,000</code> 时调用 <code>vTaskDelay( 100 )</code>，那么它将立即进入阻塞状态，并保持阻塞状态，直到嘀嗒 ( tick ) 计数达到 <code>10,100</code>。</td></tr></tbody></table></div><pre class=" language-lang-c"><code class="language-lang-c">void vTaskFunction( void *pvParameters ) { char *pcTaskName; const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );    /* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */    pcTaskName = ( char * ) pvParameters;    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 延迟一段时间。这次调用 vTaskDelay()，将任务置于阻塞状态，直到延迟时间到期。        该参数采用以 "ticks" 为单位指定的时间，并使用 pdMS_TO_TICKS() 宏         ( 其中声明了 xDelay250ms 常量 ) 将 250 毫秒转换为以 ticks 为单位的等效时间。*/        vTaskDelay( xDelay250ms );    }}</code></pre><p>清单 23. 空循环延迟已被 <code>vTaskDelay()</code> 调用替换后的示例任务的源代码</p><p>尽管这两个任务仍以不同的优先级创建，但现在它们都将运行。示例 4 的输出（如图 16 所示）证实了预期的行为。</p><p><img src="image-20240605201928489.png" alt="图 16. 执行示例 4 时产生的输出"></p><p>图 17 所示的执行序列解释了为什么两个任务都会运行，即使它们是以不同的优先级创建的。为简单起见，这里省略了调度程序本身的执行。</p><p>空闲任务在调度程序启动时自动创建，以确保始终至少有一个任务可以运行 ( 至少有一个任务处于就绪状态 ) 。第 3.8 节 空闲任务和空闲任务钩子 更详细地描述了空闲任务。</p><p><img src="image-20240605202818532.png" alt="图 17. 任务使用 vTaskDelay() 代替空循环时的执行顺序"></p><p>这两个任务只有实现方式发生了变化，功能没有变化。将图 17 与图 12 进行比较可以清楚地看出，此功能是以更高效的方式实现的。</p><p>图 12 显示了当任务使用空循环来创建延迟时的执行模式——始终运行，因此在任务之间使用百分之百的可用处理器时间。 图 17 显示了任务在整个延迟期间进入阻塞状态时的执行模式，因此只有当它们确实有需要执行的工作时 ( 在本例中只是一条要打印出来的消息 ) 才会使用处理器时间，因此仅使用可用处理时间的一小部分。</p><p>在图 17 的场景中，每次任务离开阻塞状态时，它们都会执行一小段时钟周期，然后重新进入阻塞状态。大多数时候，没有应用程序任务可以运行 ( 没有应用程序任务处于就绪状态 ) ，因此，没有应用程序任务可以选择进入运行状态。在这种情况下，空闲任务将运行。分配给空闲任务的处理时间量是系统中备用处理能力的衡量标准。使用 RTOS 可以显著增加备用处理能力，只需允许应用程序完全由事件驱动即可。</p><p>图 18 中的粗线显示了示例 4 中的任务执行的转换，每个任务现在都经过阻塞状态，然后返回到就绪状态。</p><p><img src="image-20240605235232308.png" alt="图 18. 粗线表示示例 4 中的任务执行的状态转换" style="zoom:67%;"></p><h3 id="vTaskDelayUntil-API-函数"><a href="#vTaskDelayUntil-API-函数" class="headerlink" title="vTaskDelayUntil() API 函数"></a>vTaskDelayUntil() API 函数</h3><p><code>vTaskDelayUntil()</code> 与 <code>vTaskDelay()</code> 类似。正如刚才所演示的，<code>vTaskDelay()</code> 参数指定在调用 <code>vTaskDelay()</code> 的任务和同一任务再次退出阻塞状态之间应发生的嘀嗒 ( tick ) 中断数。任务保持阻塞状态的时间长度由 <code>vTaskDelay()</code> 参数指定，但任务离开阻塞状态的时间与调用 <code>vTaskDelay()</code> 的时间有关。</p><p>相反，<code>vTaskDelayUntil()</code> 的参数指定调用任务应从阻塞状态移至就绪状态的确切嘀嗒 ( tick ) 计数值。<code>vTaskDelayUntil()</code> 是当需要固定执行周期 ( 您希望任务以固定频率定期执行 ) 时应使用的 API 函数，因为调用任务被解除阻塞的时间是绝对的，而不是相对于调用函数的时间 ( 与 <code>vTaskDelay()</code> 的情况一样 ) 。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskDelayUntil( TickType_t* pxPreviousWakeTime, TickType_t xTimeIncrement );</code></pre><p>清单 24. <code>vTaskDelayUntil()</code> API 函数原型</p><p>表 10. <code>vTaskDelayUntil()</code> 的参数</p><div class="table-container"><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>pxPreviousWakeTime</code></td><td>此参数的命名基于以下假设：<code>vTaskDelayUntil()</code> 用于实现定期且以固定频率执行的任务。在这种情况下，<code>pxPreviousWakeTime</code> 保存任务上次离开阻塞状态 ( 被 <code>" 唤醒 ( woken ) "</code> ) 的时间。此时间用作参考点，以计算任务下次离开阻塞状态的时间。<br><code>pxPreviousWakeTime</code> 指向的变量在 <code>vTaskDelayUntil()</code> 函数中自动更新；它通常不会被应用程序代码修改，但在第一次使用之前必须初始化为当前嘀嗒计数。清单 25 演示了如何执行初始化。</td></tr><tr><td><code>xTimeIncrement</code></td><td>此参数的命名也是基于这样的假设：<code>vTaskDelayUntil()</code> 用于实现定期执行且具有固定频率 ( 由 <code>xTimeIncrement</code> 值设置的频率 ) 的任务。</td></tr></tbody></table></div><h3 id="示例-5-将示例任务转换为使用-vTaskDelayUntil"><a href="#示例-5-将示例任务转换为使用-vTaskDelayUntil" class="headerlink" title="示例 5. 将示例任务转换为使用 vTaskDelayUntil()"></a>示例 5. 将示例任务转换为使用 vTaskDelayUntil()</h3><p>示例 4 中创建的两个任务是周期性任务，但是使用 <code>vTaskDelay()</code> 并不保证它们运行的频率是固定的，因为任务离开阻塞状态的时间与它们调用 <code>vTaskDelay()</code> 的时间相关。 将任务转换为使用<code>vTaskDelayUntil()</code> 而不是 <code>vTaskDelay()</code> 可以解决这个潜在的问题。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskFunction( void *pvParameters ){char *pcTaskName;TickType_t xLastWakeTime;    /* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */    pcTaskName = ( char * ) pvParameters;    /* 需要使用当前嘀嗒计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。    此后，xLastWakeTime 将在 vTaskDelayUntil() 中自动更新。 */    xLastWakeTime = xTaskGetTickCount();    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( pcTaskName );        /* 这个任务应该精确地每 250 毫秒执行一次。根据 vTaskDelay() 函数，时间是以嘀嗒为        单位度量的，pdMS_TO_TICKS() 宏用于将毫秒转换为嘀嗒。xLastWakeTime 在         vTaskDelayUntil() 中自动更新，因此任务不会显式地更新 xLastWakeTime。 */        vTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS( 250 ));    }}</code></pre><p>清单 25. 使用 <code>vTaskDelayUntil()</code> 实现示例任务</p><p>示例 5 产生的输出与图 16 中的示例 4 所示的输出完全相同。</p><h3 id="示例-6-组合阻塞和非阻塞任务"><a href="#示例-6-组合阻塞和非阻塞任务" class="headerlink" title="示例 6. 组合阻塞和非阻塞任务"></a>示例 6. 组合阻塞和非阻塞任务</h3><p>前面的示例已经单独检查了轮询和阻塞任务的行为。该示例通过演示两个方案组合时的执行序列来重新实施所述的预期系统行为，如下所述。</p><ol><li><p>创建两个优先级为 1 的任务。它们除了连续打印出一个字符串之外不执行任何操作。</p><p>这些任务从不进行任何可能导致它们进入阻塞状态的 API 函数调用，因此始终处于就绪状态或运行状态。这种性质的任务被称为 <code>" 连续处理 ( continuous processing ) "</code> 任务，因为它们总是有工作要做（尽管在这种情况下是相当琐碎的工作）。清单 26 显示了连续处理任务的源代码。</p></li><li><p>然后创建优先级为 2 的第三个任务，因此优先级高于其他两个任务。第三个任务也只是打印出一个字符串，但这次是定期打印的，所以使用 <code>vTaskDelayUntil()</code> API 函数在每次打印迭代之间将自己置于阻塞状态。</p></li></ol><p>周期性任务的源代码如清单 27 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">void vContinuousProcessingTask( void *pvParameters ){char *pcTaskName;    /* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */    pcTaskName = ( char * ) pvParameters;    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。此任务只是重复执行此操作，不会阻塞或延迟。 */        vPrintString( pcTaskName );    }}</code></pre><p>清单 26. 示例 6 中使用的连续处理任务</p><pre class=" language-lang-c"><code class="language-lang-c">void vPeriodicTask( void *pvParameters ){TickType_t xLastWakeTime;const TickType_t xDelay3ms = pdMS_TO_TICKS( 3 );    /* 需要使用当前滴答计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。    在此之后，xLastWakeTime 由 vTaskDelayUntil() API 函数自动管理。 */    xLastWakeTime = xTaskGetTickCount();    /* 与大多数任务一样，该任务是在一个无限循环中实现的。 */    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( "Periodic task is running\r\n" );        /* 该任务应每 3 毫秒准确执行一次 - 请参阅此函数中 xDelay3ms 的声明。 */        vTaskDelayUntil( &xLastWakeTime, xDelay3ms);    }}</code></pre><p>清单 27. 示例 6 中使用的周期性任务</p><p>图 19 显示了示例 6 产生的输出，并解释了图 20 中显示的执行序列所观察到的行为。</p><p><img src="image-20240609003733891.png" alt="图 19. 执行示例 6 时产生的输出"></p><p><img src="image-20240609004733190.png" alt="图 20. 示例 6 的执行模式"></p><h2 id="3-8-空闲任务和空闲任务钩子"><a href="#3-8-空闲任务和空闲任务钩子" class="headerlink" title="3.8 空闲任务和空闲任务钩子"></a>3.8 空闲任务和空闲任务钩子</h2><p>示例 4 中创建的任务大部分时间处于阻塞状态。处于此状态时，它们无法运行，因此无法被调度程序选中。</p><p>必须始终至少有一个任务可以进入运行状态 [1] 。为确保这种情况，在调用 <code>vTaskStartScheduler()</code> 时，调度程序会自动创建一个空闲任务。空闲任务除了处于循环中之外几乎不执行其他操作 — 因此，与最初第一个示例中的任务一样，它始终能够运行。</p><blockquote><p>[1] : 即使在使用 FreeRTOS 的特殊低功耗功能时也是如此，在这种情况下，如果应用程序创建的任务都无法执行，则执行 FreeRTOS 的微控制器将进入低功耗模式。</p></blockquote><p>空闲任务具有可能的最低优先级 ( 优先级为零 ) ，以确保它永远不会阻止更高优先级的应用程序任务进入运行状态 —— 尽管没有什么可以阻止应用程序设计人员在空闲任务优先级上创建任务，从而共享空闲任务优先级 ( 如果需要 ) ，<code>FreeRTOSConfig.h</code> 中的 <code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于防止空闲任务消耗处理时间，而这些时间可以更有效地分配给应用程序任务。<code>configIDLE_SHOULD_YIELD</code> 在第 3.12 节 “ 调度算法 “ 中进行了描述。</p><p>以最低优先级运行可确保只要优先级较高的任务进入就绪状态，空闲任务就会从运行状态转移出来。 这可以在图 17 中的时间点看到，其中空闲任务被立即换出以允许任务 2 在任务 2 离开被阻止状态的瞬间执行。 据说任务 2 已经抢占了空闲任务。 抢先自动发生，并且不知道任务被抢占。</p><p>以最低优先级运行可确保空闲任务在更高优先级任务进入就绪状态时立即退出运行状态。这可以在图 17 中的时间 tn 处看到，其中空闲任务立即被换出，以允许任务 2 在任务 2 离开阻塞状态的瞬间执行。则称任务 2 已抢占 ( pre-empted ) 空闲任务。抢占是自动发生的，被抢占的任务对此并不知情。Pre-emption occurs automatically, and without the knowledge of the task being pre-empted.</p><p>如果应用程序使用 <code>vTaskDelete()</code> API 函数，那么空闲任务就不会浪费处理时间。这是因为空闲任务负责在删除任务之后清理内核资源。</p><blockquote><p>注意 : 注意：如果应用程序使用 vTaskDelete() API 函数，则空闲任务不能缺少处理时间，这一点至关重要。这是因为空闲任务负责在删除任务后清理内核资源。</p></blockquote><h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>可以通过使用空闲钩子 idle hook ( 或空闲回调 idle callback ) 函数将特定于应用程序的功能直接添加到空闲任务中 —— 该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。</p><p>空闲任务钩子的常见用途包括：</p><ul><li><p>执行低优先级、后台或连续处理功能。</p></li><li><p>测量备用处理能力的数量。（当所有优先级较高的应用程序任务无法执行时，空闲任务将会运行；因此，测量分配给空闲任务的处理时间量可清楚地指示多少处理时间。）</p><p>测量空闲处理能力的数量。( 只有当所有优先级较高的应用程序任务都没有工作要执行时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地表明有多少空闲处理时间。)</p></li><li><p>将处理器置于低功耗模式，提供一种在没有应用程序处理需要执行时节省电量的简单而自动的方法 ( 尽管使用此方法可以实现的电量节省效果不如使用第 10 章 “ 低功耗支持 “ 中描述的无滴答空闲模式  tick-less idle mode 可以实现的电量节省效果 ) 。</p></li></ul><h3 id="对空闲任务钩子函数实现的限制"><a href="#对空闲任务钩子函数实现的限制" class="headerlink" title="对空闲任务钩子函数实现的限制"></a>对空闲任务钩子函数实现的限制</h3><p>空闲任务钩子函数必须遵守以下规则。</p><ol><li><p>空闲任务钩子函数绝不能尝试阻塞或暂停。</p><blockquote><p>注意 : 以任何方式阻塞空闲任务都可能导致没有可用任务进入运行状态的情况。</p></blockquote></li><li><p>如果应用程序使用了 <code>vTaskDelete()</code> API函数，则空闲任务钩子必须始终在合理的时间段内返回其调用者。这是因为空闲任务负责在任务被删除后清理内核资源。如果空闲任务永久地保持在空闲钩子函数中，则无法进行清理。</p></li></ol><p>空闲任务钩子函数必须具有清单 28 所示的名称和原型。</p><pre class=" language-lang-c"><code class="language-lang-c">void vApplicationIdleHook( void );</code></pre><p>清单 28. 空闲任务钩子函数名称和原型</p><h3 id="示例-7-定义一个空闲任务钩子函数"><a href="#示例-7-定义一个空闲任务钩子函数" class="headerlink" title="示例 7. 定义一个空闲任务钩子函数"></a>示例 7. 定义一个空闲任务钩子函数</h3><p>示例 4 中使用阻塞 vTaskDelay() API 调用会产生大量空闲时间 — 因为两个应用程序任务都处于阻塞状态，所以空闲任务正在执行的时间。示例 7 通过添加空闲钩子函数来利用此空闲时间，其源代码如清单 29 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 声明一个将由钩子函数递增的变量。 */volatile uint32_tulIdleCycleCount = 0UL;/* 空闲钩子函数必须命名为 vApplicationIdleHook()，不带参数，并且返回 void。 */void vApplicationIdleHook( void ){    /* 这个钩子函数除了递增计数器外什么都不做。 */    ulIdleCycleCount++;}</code></pre><p>清单 29. 一个非常简单的空闲钩子函数</p><p>必须在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_IDLE_HOOK</code> 设置为 1，才能调用空闲挂钩函数。</p><p>对实现创建任务的函数稍加修改，以打印出 <code>ulIdleCycleCount</code> 值，如清单 30 所示。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskFunction( void *pvParameters ){char *pcTaskName;const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 );    /* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */    pcTaskName = ( char * ) pvParameters;    /* 与大多数任务一样，此任务在无限循环中实现。 */    for( ;; )    {        /* 打印出此任务的名称和 ulIdleCycleCount 已增加的次数。 */        vPrintStringAndNumber( pcTaskName, ulIdleCycleCount);        /* 延迟 250 毫秒。 */        vTaskDelay( xDelay250ms);    }}</code></pre><p>清单 30. 示例任务的源代码现在打印出 <code>ulIdleCycleCount</code> 值</p><p>示例 7 产生的输出如图 21 所示。 因此，在应用任务的每次迭代之间，空闲任务钩子函数被调用大约 400 万次（迭代次数取决于演示执行的硬件的速度）。</p><p>示例 7 产生的输出如图 21 所示。它表明空闲任务钩子函数在应用程序任务的每次迭代之间被调用大约 400 万次 ( 迭代次数取决于执行演示的硬件的速度 ) 。</p><p><img src="image-20240609143325610.png" alt="图 21. 执行示例 7 时产生的输出"></p><h2 id="3-9-更改任务的优先级"><a href="#3-9-更改任务的优先级" class="headerlink" title="3.9 更改任务的优先级"></a>3.9 更改任务的优先级</h2><h3 id="vTaskPrioritySet-API-函数"><a href="#vTaskPrioritySet-API-函数" class="headerlink" title="vTaskPrioritySet() API 函数"></a>vTaskPrioritySet() API 函数</h3><p><code>vTaskPrioritySet()</code> API 函数可用于在调度程序启动后更改任何任务的优先级。请注意，当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数是可用的。</p><p>启动调度程序后，可以使用 <code>vTaskPrioritySet()</code> API 函数来更改任何任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数才可用。</p><pre class=" language-lang-c"><code class="language-lang-c">void vTaskPrioritySet( TaskHandle_t pxTask, UBaseType_t uxNewPriority );</code></pre><p>清单 31. <code>vTaskPrioritySet()</code> API 函数原型</p><p>表 11. <code>vTaskPrioritySet()</code> 参数</p><div class="table-container"><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTask</code></td><td>正在修改其优先级的任务 ( 主题任务 the subject task ) 的句柄—— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来更改自己的优先级。</td></tr><tr><td><code>uxNewPriority</code></td><td>主题任务要设置的优先级。该优先级自动限制在最大可用优先级 ( <code>configMAX_PRIORITIES - 1</code> ) 内，其中 <code>configMAX_PRIORITIES</code> 是 <code>FreeRTOSConfig.h</code> 头文件中设置的编译时常量。</td></tr></tbody></table></div><h3 id="uxTaskPriorityGet-API-函数"><a href="#uxTaskPriorityGet-API-函数" class="headerlink" title="uxTaskPriorityGet() API 函数"></a>uxTaskPriorityGet() API 函数</h3><p><code>uxTaskPriorityGet()</code> API 函数可用于查询任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_uxTaskPriorityGet</code> 设置为 1 时，<code>uxTaskPriorityGet()</code> API 函数才可用。</p><pre class=" language-lang-c"><code class="language-lang-c">UBaseType_t uxTaskPriorityGet( TaskHandle_t pxTask );</code></pre><p>清单 32. <code>uxTaskPriorityGet()</code> API 函数原型</p><p>表 12. <code>uxTaskPriorityGet()</code> 参数和返回值</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTask</code></td><td>正在查询其优先级的任务 ( 主题任务 ) 的句柄 —— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来查询自己的优先级。</td></tr><tr><td>返回值</td><td>当前分配给正在查询的任务的优先级。</td></tr></tbody></table></div><h3 id="示例-8-更改任务优先级"><a href="#示例-8-更改任务优先级" class="headerlink" title="示例 8. 更改任务优先级"></a>示例 8. 更改任务优先级</h3><p>调度程序将始终选择最高 ( 优先级 ) 就绪状态的任务作为进入运行状态的任务。示例 8 通过使用 <code>vTaskPrioritySet()</code> API 函数更改两个任务相对于彼此的优先级来演示这一点。</p><p>示例 8 创建了两个优先级不同的任务。两个任务均未进行任何可能导致其进入阻塞状态的 API 函数调用，因此它们始终处于就绪状态或运行状态。因此，具有最高相对优先级的任务将始终是调度程序选择处于运行状态的任务。</p><p>示例 8 的行为如下：</p><ol><li><p>任务 1 ( 清单 33 ) 创建时具有最高优先级，因此保证首先运行。 任务 1 在将任务 2 ( 清单 34 ) 的优先级提高到高于自己的优先级之前打印出几个字符串。</p></li><li><p>任务 2 一旦具有最高相对优先级就开始运行（进入运行状态）。 任何时候只有一个任务可以处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p><p>任务 2 一旦具有最高的相对优先级，就会开始运行 ( 进入运行状态 ) 。任何时刻只能有一个任务处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p></li><li><p>任务 2 在将自己的优先级设置回低于任务 1 的优先级之前打印出一条消息。</p></li><li><p>任务 2 将自己的优先级调低意味着任务 1 再次成为最高优先级任务，因此任务 1 重新进入运行状态，迫使任务 2 回到就绪状态。</p></li></ol><pre class=" language-lang-c"><code class="language-lang-c">void vTask1( void *pvParameters ){UBaseType_t uxPriority;    /* 此任务将始终在任务 2 之前运行，因为它以更高的优先级创建。    任务 1 和任务 2 都不会阻塞，因此两者始终处于正在运行或就绪状态。     查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " 。 */    uxPriority = uxTaskPriorityGet( NULL );    for( ;; )    {        /* 打印出此任务的名称。 */        vPrintString( "Task 1 is running\r\n" );        /* 将任务 2 的优先级设置为高于任务 1 的优先级将导致任务 2 立即开始运行         ( 因为任务 2 的优先级在两个创建的任务中更高 ) 。        请注意在调用 vTaskPrioritySet() 时使用任务 2 的句柄 (xTask2Handle)。        清单 35 显示了如何获取句柄。*/        vPrintString( "About to raise the Task 2 priority\r\n" );        vTaskPrioritySet( xTask2Handle, ( uxPriority + 1 ) );        /* 任务 1 只有在优先级高于任务 2 时才会运行。因此，要使此任务达到此点，        任务 2 必须已经执行，并将其优先级重新设置回低于此任务的优先级。 */    }}</code></pre><p>清单 33. 示例 8 中任务 1 的实现</p><pre class=" language-lang-c"><code class="language-lang-c">void vTask2( void *pvParameters ){UBaseType_t uxPriority;    /* 任务 1 将始终在此任务之前运行，因为任务 1 的创建优先级更高。    任务 1 和任务 2 都不会阻塞，因此将始终处于正在运行或就绪状态。    查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " */    uxPriority = uxTaskPriorityGet( NULL );    for( ;; )    {        /* 要使此任务达到此点，任务 1 必须已经运行，并将此任务的优先级设置为高        于其自身的优先级。         打印出此任务的名称。 */        vPrintString( "Task 2 is running\r\n" );        /* 传入 NULL 作为任务句柄意味着 " 更改调用任务的优先级 "。        将优先级设置为低于任务 1 的优先级将导致任务 1 立即再次开始运行         - 抢占此任务。*/        vPrintString( "About to lower the Task 2 priority\r\n" );        vTaskPrioritySet( NULL, ( uxPriority - 2) );    }}</code></pre><p>清单 34. 示例 8 中任务 2 的实现</p><p>每个任务都可以查询和设置自己的优先级，而无需使用有效的任务句柄，只需使用 <code>NULL</code> 即可。只有当任务希望引用除自身之外的其他任务时，才需要任务句柄，例如当任务 1 更改任务 2 的优先级时。为了允许任务 1 执行此操作，在创建任务 2 时获取并保存任务 2 句柄，如清单 35 中的注释中突出显示的那样。</p><pre class=" language-lang-c"><code class="language-lang-c">/* 声明一个用于保存任务 2 的句柄的变量。 */TaskHandle_t xTask2Handle = NULL;int main( void ){    /* 创建优先级为 2 的第一个任务。任务参数未使用，    设置为 NULL。任务句柄也未使用，因此也设置为 NULL。 */    xTaskCreate( vTask1, "Task 1", 1000, NULL, 2, NULL );    /* 任务以优先级 2 创建 ______________________^. */    /* 创建优先级为 1 的第二个任务 - 该优先级低于赋予任务 1 的优先级。    同样，任务参数未使用因此设置为 NULL - 但这次需要任务句柄，    因此 xTask2Handle 的地址在最后一个参数中传递。*/    xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, &xTask2Handle );    /* 任务句柄是最后一个参数 _______________________^^^^^^^^^^^^^ */    /* 启动调度程序，使任务开始执行。 */    vTaskStartScheduler();        /* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。    如果 main() 确实到达这里，那么很可能没有足够的堆内存可用于创建空闲任务。第 2 章    提供了关于堆内存管理的更多信息。 */    for( ;; );}</code></pre><p>清单 35. 示例 8 的 <code>main()</code> 实现</p><p>图 22 演示了示例 8 任务的执行顺序，其结果输出如图 23 所示。</p><p><img src="image-20240609163053423.png" alt="图 22. 运行示例 8 时的任务执行顺序" style="zoom:67%;"></p><p><img src="image-20240609163343194.png" alt="图 23. 执行示例 8 时产生的输出"></p><h2 id="3-10-删除任务"><a href="#3-10-删除任务" class="headerlink" title="3.10 删除任务"></a>3.10 删除任务</h2><h3 id="vTaskDelete-API-函数"><a href="#vTaskDelete-API-函数" class="headerlink" title="vTaskDelete() API 函数"></a>vTaskDelete() API 函数</h3><p>任务可以使用 <code>vTaskDelete()</code> API 函数删除自身或任何其他任务。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelete</code> 设置为 1 时，<code>vTaskDelete()</code> API 函数才可用。</p><p>删除的任务不再存在，无法再次进入运行状态。</p><p>空闲任务负责释放分配给已删除任务的内存。因此，使用 <code>vTaskDelete()</code> API 函数的应用程序不要完全剥夺 ( starve ) 空闲任务的所有处理时间，这一点很重要。</p><blockquote><p>注意 : 只有内核分配给任务的内存才会在任务被删除时自动释放。任何由任务实现分配的内存或其他资源必须显式释放。</p></blockquote><pre class=" language-lang-c"><code class="language-lang-c">void vTaskDelete( TaskHandle_t pxTaskToDelete );</code></pre><p>清单 36. <code>vTaskDelete()</code> 函数原型</p><p>表 13. <code>vTaskDelete()</code> 参数</p><div class="table-container"><table><thead><tr><th>参数名称/返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>pxTaskToDelete</code></td><td>要删除的任务 ( 主题任务 ) 的句柄——有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 来代替有效的任务句柄来删除自身。</td></tr></tbody></table></div><h3 id="示例9-删除任务"><a href="#示例9-删除任务" class="headerlink" title="示例9. 删除任务"></a>示例9. 删除任务</h3><p>这是一个非常简单的示例，其行为如下。</p><ol><li>任务 1 由 <code>main()</code> 创建，优先级为 1。当它运行时，它会创建优先级为 2 的任务 2。任务 2 现在是最高优先级的任务，因此它会立即开始执行。<code>main()</code> 的源代码如清单 37 所示，任务 1 的源代码如清单 38 所示。</li><li>任务 2 除了删除自己之外，什么也不会做。它可以通过向 <code>vTaskDelete()</code> 传递 <code>NULL</code> 来删除自己，但是出于演示目的，它会使用自己的任务句柄。任务 2  的源代码如清单 39 所示。</li><li>当任务 2 被删除时，任务 1 再次成为优先级最高的任务，所以它将继续执行 —— 此时它会调用 <code>vTaskDelay()</code> 来阻塞一小段时间。</li><li>空空闲任务在任务 1 处于阻塞状态时执行，并释放分配给现已删除的任务 2 的内存。</li><li>当任务 1 离开阻塞状态时，它将再次变为最高优先级的就绪状态任务，从而抢占空闲任务。当进它入运行状态时，它将再次创建任务 2， 以此类推。</li></ol><pre class=" language-lang-c"><code class="language-lang-c">int main( void ){    /* 以优先级 1 创建第一个任务。不使用任务参数，因此将其设置为NULL。     任务句柄也未使用，因此同样设置为 NULL 。 */    xTaskCreate( vTask1, "Task 1", 1000, NULL, 1, NULL );    /* 该任务以优先级 1 创建 ____________________^. */    /* 启动调度程序，以便任务开始执行。 */    vTaskStartScheduler();        /* 由于调度程序已经启动，main() 永远不会到达此处。 */    for( ;; );}</code></pre><p>清单 37. 示例 9 的 main() 的实现</p><pre class=" language-lang-c"><code class="language-lang-c">TaskHandle_t xTask2Handle = NULL;void vTask1( void *pvParameters ){const TickType_txDelay100ms = pdMS_TO_TICKS( 100UL );    for( ;; )    {        /* 打印这个任务的名称 */        vPrintString( "Task 1 is running\r\n" );        /* 创创建优先级更高的任务 2。 同样没有使用任务参数，所以将其设置为 NULL         —— 但是这次需要任务句柄，因此将 xTask2Handle 的地址作为最后一个参数传递。*/        xTaskCreate( vTask2, "Task 2", 1000, NULL, 2, &xTask2Handle );        /* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */        /* 任务 2 具有更高的优先级，因此，任务 1 到达此处时，        任务 2 必须已执行并删除自身。延迟 100 毫秒。 */        vTaskDelay( xDelay100ms );    }}</code></pre><p>清单 38. 示例 9 的任务 1 的实现</p><pre class=" language-lang-c"><code class="language-lang-c">void vTask2( void *pvParameters ){    /* 任务 2 什么也不做，只是删除自身。为此，它可以使用 NULL     作为参数来调用 vTaskDelete()，但出于演示目的，    它调用 vTaskDelete() 并传递自己的任务句柄。 */    vPrintString( "Task 2 is running and about to delete itself\r\n" );    vTaskDelete( xTask2Handle );}</code></pre><p>清单 39. 示例 9 的任务 2 的实现</p><p><img src="image-20240610022134603.png" alt="执行示例 9 时产生的输出"></p><p><img src="Chapter 3 任务管理/image-20240610023224251.png" alt="图 25. 示例 9 的执行顺序"></p><h2 id="3-11-线程本地存储"><a href="#3-11-线程本地存储" class="headerlink" title="3.11 线程本地存储"></a>3.11 线程本地存储</h2><p>待完成。本节将在最终发布之前编写。</p><blockquote><p>译者注 : 原文就是待完成。</p></blockquote><h2 id="3-12-调度算法"><a href="#3-12-调度算法" class="headerlink" title="3.12 调度算法"></a>3.12 调度算法</h2><h3 id="任务状态和事件的回顾"><a href="#任务状态和事件的回顾" class="headerlink" title="任务状态和事件的回顾"></a>任务状态和事件的回顾</h3><p>实际正在运行 ( 使用处理时间 ) 的任务处于运行状态。在单核处理器上，在任何给定时间只能有一个任务处于运行状态。</p><p>未实际运行但未处于阻塞状态或暂停状态的任务处于就绪状态。处于就绪状态的任务可被调度程序选择为进入运行状态的任务。调度程序将始终选择优先级最高的就绪状态任务进入运行状态。</p><p>任务可以在阻塞状态下等待事件，并在事件发生时自动移回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发出异步活动信号，例如数据到达外设。</p><p>任务可以在阻塞状态下等待事件，并在事件发生时自动返回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发信号通知异步活动，例如数据到达外设。</p><h3 id="配置调度算法"><a href="#配置调度算法" class="headerlink" title="配置调度算法"></a>配置调度算法</h3><p>调度算法是决定哪个就绪状态任务转换到运行状态的软件例程。</p><p>到目前为止，所有示例都使用了相同的调度算法，但可以使用 <code>configUSE_PREEMPTION</code> 和 <code>configUSE_TIME_SLICING</code> 配置常量更改算法。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p><p>第三个配置常量 <code>configUSE_TICKLESS_IDLE</code> 也会影响调度算法，因为使用该常量会导致嘀嗒中断在较长时间内完全关闭。<code>configUSE_TICKLESS_IDLE</code> 是一个高级选项，专门用于必须最小化其功耗的应用程序。第 10 章 “ 低功耗支持 “ 中介绍了 <code>configUSE_TICKLESS_IDLE</code> 。本节提供的描述假设 <code>configUSE_TICKLESS_IDLE</code> 设置为 0，如果常量未定义，则这是默认设置。</p><p>在所有可能的配置中，FreeRTOS 调度程序将确保选择具有同等优先级的任务依次进入运行状态。这种 “ 轮流使用 take it in turn” 策略通常称为 <code>" 循环调度 ( Round Robin Scheduling ) "</code> 。循环调度算法不保证在具有同等优先级的任务之间平均分配时间，而只保证具有同等优先级的就绪状态任务将依次进入运行状态。</p><h3 id="带时间片的优先抢占式调度"><a href="#带时间片的优先抢占式调度" class="headerlink" title="带时间片的优先抢占式调度"></a>带时间片的优先抢占式调度</h3><p>表 14 中显示的配置将 FreeRTOS 调度程序设置为使用一种称为 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code> 的调度算法，这是大多数小型 RTOS 应用程序使用的调度算法，也是本书迄今为止介绍的所有示例使用的算法。表 15 提供了算法名称中使用的术语的描述。</p><p>表 14. 将内核配置为使用带时间片的优先抢占式调度的 <code>FreeRTOSConfig.h</code> 设置</p><div class="table-container"><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center"><code>configUSE_PREEMPTION</code></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><code>configUSE_TIME_SLICING</code></td><td style="text-align:center">1</td></tr></tbody></table></div><p>表 15. 用于描述调度策略的术语的解释</p><div class="table-container"><table><thead><tr><th style="text-align:center">术语</th><th>定义</th></tr></thead><tbody><tr><td style="text-align:center">固定优先级<br>( Fixed Priority  )</td><td>被描述为 “ 固定优先级 “ 的调度算法不会更改分配给被调度任务的优先级，但也不会阻止任务本身更改自己的优先级或其他任务的优先级。</td></tr><tr><td style="text-align:center">抢占<br>( Pre-emptive )</td><td>如果优先级高于运行状态任务的任务进入就绪状态，抢占式调度算法将立即 “ 抢占 ( pre-empt ) “ 运行状态任务。被抢占意味着非自愿地 ( 无需显式地让出 yielding 或阻塞 blocking ) 移出运行状态并进入就绪状态，以允许不同的任务进入运行状态。</td></tr><tr><td style="text-align:center">时间片<br>( Time Slicing )</td><td>时间片用于在优先级相同的任务之间共享处理时间，即使任务没有显式地让出 ( yield ) 或进入阻塞 ( blocked) 状态。如果存在其他与运行任务具有相同优先级的就绪状态任务，描述为使用 <code>" 时间片 ( Time Slicing ) "</code> 的调度算法将在每个时间片结束时选择一个新任务进入运行状态。时间片等于两个 RTOS 嘀嗒中断之间的时间。</td></tr></tbody></table></div><p>图 26 和图 27 说明了当使用具有时间分片算法的固定优先级抢占式调度时如何调度任务。 图 26 显示了当应用程序中的所有任务具有唯一优先级时，选择任务以进入“运行”状态的顺序。 图 27 显示了当应用程序中的两个任务共享优先级时，选择任务以进入“运行”状态的顺序。</p><p>图 26 和图 27 演示了使用 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code>  算法时任务的调度方式。图 26 显示了当应用程序中的所有任务都具有唯一的优先级时，选择任务进入运行状态的顺序。图 27 显示了当应用程序中的两个任务共享一个优先级时，选择任务进入运行状态的顺序。</p><p><img src="image-20240610125928163.png" alt="图 26. 执行模式突出显示假设应用程序中的任务优先级和抢占，其中每个任务都被分配了唯一的优先级"></p><p>参考图26 : </p><ol><li><p><strong>空闲任务</strong> ：空闲任务以最低优先级运行，因此每次较高优先级的任务进入就绪状态时，空闲任务都会被抢占 —— 例如在时间 t3、t5 和 t9。</p></li><li><p><strong>任务 3</strong> ：任务 3 是一个事件驱动的任务，它以相对较低的优先级执行，但高于空闲优先级。 它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次事件发生时从阻塞状态转换到就绪状态。 所有 FreeRTOS 任务间通信机制 ( 任务通知，队列，信号量，事件组等 ) 都可用于以这种方式发出事件信号和解除任务阻塞。</p><p>事件发生在时间 t3 和 t5，以及 t9 和 t12 之间的某个时间。发生在时间 t3 和 t5 的事件会立即得到处理，因为在这些时间，任务 3 是能够运行的最高优先级任务。发生在时间 t9 和 t12 之间的某个时间的事件直到 t12 才会得到处理，因为在此之前，优先级较高的任务任务 1 和任务 2 仍在执行。只有在时间 t12 时，任务 1 和任务 2 才处于阻塞状态，从而使任务 3 成为优先级最高的就绪状态任务。</p></li><li><p><strong>任务 2</strong> : 任务 2 是一个周期性任务，其执行优先级高于任务 3 的优先级，但低于任务 1 的优先级。该任务的周期间隔意味着任务 2 想要在时间 t1、t6 和 t9 执行。</p><p>在时间 t6，任务 3 处于运行状态，但任务 2 具有较高的相对优先级，因此抢占任务 3 并立即开始执行。任务 2 完成其处理并在时间 t7 重新进入阻塞状态，此时任务 3 可以重新进入运行状态以完成其处理。任务 3 本身在时间 t8 阻塞。</p></li><li><p><strong>任务 1</strong> : 任务 1 也是一个事件驱动任务。它以最高的优先级执行，因此可以抢占系统中的任何其他任务。图中显示的唯一任务 1 事件发生在时间 t10，此时任务 1 抢占任务 2。只有在任务 1 于时间 t11 重新进入阻塞状态后，任务 2 才能完成其处理。</p></li></ol><p><img src="image-20240610154453687.png" alt="图 27. 执行模式突出显示假设应用程序中的任务优先级和时间片，其中两个任务以相同的优先级运行"></p><p>参考图 27 : </p><ol><li><p><strong>空闲任务与任务 2</strong>：空闲任务和任务 2 都是连续处理 ( continuous processing ) 任务，优先级均为 0 ( 最低优先级 ) 。调度程序仅在没有更高优先级的任务可运行时才将处理时间分配给优先级 0 任务，并通过时间分片共享分配给优先级 0 任务的时间。每次嘀嗒中断都会开始一个新的时间片，在图 27 中，时间片为 t1、t2、t3、t4、t5、t8、t9、t10 和 t11。</p><p>空闲任务和任务 2 依次进入运行状态，这会导致两个任务在同一时间片的部分时间内处于运行状态，就像在时间 t5 和时间 t8 之间发生的情况一样。</p></li><li><p><strong>任务 1</strong>：任务 1 的优先级高于空闲优先级。任务 1 是一个事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次发生事件时，它都会从阻塞状态转换到就绪状态。</p><p>感兴趣的事件发生在时间 t6，因此在 t6 时任务 1 成为能够运行的最高优先级任务，因此任务 1 在时间片中抢占空闲任务。事件处理在时间 t7 时完成，此时任务 1 重新进入阻塞状态。</p></li></ol><p>图 27 显示了空闲任务与应用程序编写者创建的任务共享处理时间。如果应用程序编写者创建的空闲优先级任务有工作要做，而空闲任务没有工作要做，那么为空闲任务分配那么多处理时间可能并不可取。<code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于更改空闲任务的调度方式：</p><ul><li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 0，则空闲任务将在整个时间片内保持运行状态，除非它被更高优先级的任务抢占。</li><li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 1，则如果有其他空闲优先级任务处于就绪状态，则空闲任务将在其循环的每次迭代中让出 yield ( 自愿放弃其分配的时间片的剩余部分 ) 。 </li></ul><p>图 27 中所示的执行模式是当 <code>configIDLE_SHOULD_YIELD</code> 设置为 0 时将观察到的内容。图 28 中所示的执行模式是在 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时在相同场景中观察到的内容。</p><p><img src="image-20240611075853590.png" alt="图 28. 与图 27 所示场景相同的执行模式，但这次将 configIDLE_SHOULD_YIELD 设置为 1"></p><p>图 28 还显示，当 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时，在空闲任务之后被选择进入运行状态的任务不会执行整个时间片，而是执行空闲任务让出的时间片的剩余部分。</p><h3 id="优先级抢占式调度-无时间片"><a href="#优先级抢占式调度-无时间片" class="headerlink" title="优先级抢占式调度 ( 无时间片 )"></a>优先级抢占式调度 ( 无时间片 )</h3><p>没有时间切片的优先抢占式调度保持与上一节中描述的相同的任务选择和抢占算法，但不使用时间切片在具有相同优先级的任务之间共享处理时间。</p><p>表 16 显示了将 FreeRTOS 调度程序配置为使用无时间片的优先级抢占式调度的 <code>FreeRTOSConfig.h</code> 设置。</p><p>表 16.  <code>FreeRTOSConfig.h</code> 设置，用于将内核配置为使用无时间片的优先级抢占式调度 </p><div class="table-container"><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center"><code>configUSE_PREEMPTION</code></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><code>configUSE_TIME_SLICING</code></td><td style="text-align:center">0</td></tr></tbody></table></div><p>如图 27 所示，如果使用时间分片，并且有多个处于最高优先级的就绪状态任务能够运行，那么调度程序将在每个RTOS滴答中断 ( 标记时间片结束的滴答中断 ) 期间选择一个新任务进入运行状态。如果不使用时间分片，则调度程序将仅在以下任一情况下选择新任务进入运行状态 :  &lt;—— here</p><ul><li>更高优先级的任务进入就绪状态。</li><li>处于运行状态的任务进入阻塞状态或者暂停状态。</li></ul><p>不使用时间片时，任务上下文切换次数比使用时间片时少。因此，关闭时间片可减少调度程序的处理开销。但是，关闭时间片也会导致优先级相同的任务收到的处理时间量相差很大，如图 29 所示。因此，不使用时间片运行调度程序被视为一种高级技术，仅应由经验丰富的用户使用。</p><p><img src="image-20240612131241019.png" alt="图 29. 执行模式，演示当不使用时间片时，相同优先级的任务如何获得截然不同的处理时间"></p><p>参考图 29 ，假设 <code>configIDLE_SHOULD_YIELD</code> 设置为 0：</p><ol><li><p><strong>嘀嗒中断</strong>：</p><p>嘀嗒中断发生在时间 t1、t2、t3、t4、t5、t8、t11、t12 和 t13 。</p></li><li><p><strong>任务 1</strong>：</p><p>任务 1 是一个高优先级事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件。每次事件发生时，任务 1 都会从阻塞状态转换为就绪状态 ( 随后，由于它是优先级最高的就绪状态任务，因此会转换为运行状态 ) 。图 29 显示任务 1 在时间 t6 和 t7 之间处理事件，然后在时间 t9 和 t10 之间再次处理事件。</p></li><li><p><strong>空闲任务与任务 2</strong>：</p><p>空闲任务和任务2都是连续处理任务，并且优先级都为 0  ( 空闲优先级 ) 。连续处理任务不进入阻塞状态。</p><p>由于未使用时间片，因此处于运行状态的空闲优先级任务将保持运行状态，直到被更高优先级的任务 1 抢占。</p><p>在图 29 中，空闲任务在时间 t1 开始运行，并保持运行状态，直到在时间 t6 被任务 1 抢占——此时距离其进入运行状态已过去了四个完整的嘀嗒周期以上。 </p><p>任务 2 在时间 t7 开始运行，此时任务 1 重新进入阻塞状态以等待另一个事件。任务 2 一直处于运行状态，直到它也在时间 t9 被任务 1 抢占——此时距离它进入运行状态还不到一个嘀嗒周期。</p><p>在时间 t10，空闲任务重新进入运行状态，尽管其已获得比任务 2 多四倍以上的处理时间。</p></li></ol><h3 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h3><p>本书主要介绍抢占式调度，但 FreeRTOS 也可以使用 <code>协作式调度 ( co-operative scheduling )</code> 。配置 FreeRTOS 调度程序使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置如表 17 所示。</p><p>表 17. 将内核配置为使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置</p><div class="table-container"><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center"><code>configUSE_PREEMPTION</code></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><code>configUSE_TIME_SLICING</code></td><td style="text-align:center">任何值</td></tr></tbody></table></div><p>当使用协作式调度程序时，仅当运行状态任务进入阻塞状态，或运行状态任务通过调用 <code>taskYIELD()</code> 显式地让出 ( 手动请求重新调度 ) 时，才会发生上下文切换。任务永远不会被抢占，因此不能使用时间片。</p><p>图 30 演示了协作式调度程序的行为。图 30 中的水平虚线显示任务何时处于就绪状态。</p><p><img src="image-20240613005719519.png" alt="图 30. 演示协作式调度程序行为的执行模式"></p><p>参考图 30 : </p><ol><li><p><strong>任务 1</strong>：</p><p>任务 1 有最高优先级，它开始于阻塞状态，等待一个信号量。</p><p>在时间 t3 处，一个中断会 <code>给出 ( give )</code> 信号量，导致任务 1 离开阻塞状态并进入就绪状态 ( 第 6 章介绍从中断给出信号量 ) 。</p><p>在时间 t3 时，任务 1 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 1 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 1 保持在就绪状态，直到时间 t4 — 即运行状态任务调用 <code>taskYIELD()</code> 时。</p></li><li><p><strong>任务 2</strong>：</p><p>任务 2 的优先级介于任务 1 和任务 3 之间。它开始于阻塞状态，等待由任务 3 在时间 t2 发送给它的消息。</p><p>在时间 t2 时，任务 2 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 2 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 2 保持在就绪状态，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 。</p><p>运行状态任务在时刻 t4 调用 <code>taskYIELD()</code> ，但此时任务 1 是优先级最高的就绪状态任务，因此直到任务 1 在时刻 t5 重新进入阻塞状态时，任务 2 才真正成为运行状态任务。</p><p>在时间 t6 时，任务 2 重新进入阻塞状态以等待下一条消息，此时任务 3 再次成为最高优先级的就绪状态任务。</p></li></ol><p>在一个多任务应用程序中，应用程序编写者必须注意不要让多个任务同时访问同一个资源，因为同时访问可能会损坏资源。例如，考虑以下场景，其中访问的资源是 UART ( 串行端口 )。两个任务正在将字符串写入 UART；任务 1 正在写入 <code>"abcdefghijklmnop"</code>，任务 2 正在写入 <code>"123456789"</code> ：</p><ol><li>任务 1 处于运行状态并开始写入其字符串。它将 <code>"abcdefg"</code> 写入 UART，但在写入任何其他字符之前离开运行状态。</li><li>任务 2 进入运行状态，并在离开运行状态之前将 <code>"123456789"</code> 写入UART。</li><li>任务 1 重新进入运行状态，并将其字符串的剩余字符写入 UART。</li></ol><p>在这种情况下，实际写入 UART 的是 <code>"abcdefg123456789hijklmnop"</code> 。任务 1 写入的字符串并未按预期以不间断的顺序写入 UART，而是被破坏了，因为任务 2 写入 UART 的字符串出现在其中。</p><p>通常，使用协作调度程序比使用抢占式调度程序更容易避免由同时访问引起的问题 [1]：</p><blockquote><p>[1] : 在任务之间安全共享资源的方法将在本书后面介绍。FreeRTOS 本身提供的资源 ( 如队列和信号量 ) 始终可以在任务之间安全共享。</p></blockquote><ul><li>当使用抢占式调度程序时，运行状态任务可以随时被抢占，包括当它与另一个任务共享的资源处于不一致状态时。正如 UART 示例所展示的那样，让资源处于不一致状态可能会导致数据损坏。</li><li>当使用协作调度程序时，应用程序编写者可以控制何时切换到另一个任务。因此，应用程序编写者可以确保在资源处于不一致状态时不会切换到另一项任务。</li><li>在上面的 UART 示例中，应用程序编写者可以确保任务 1 在其整个字符串写入 UART 之前不会离开运行状态，这样就消除了字符串被另一个任务的操作破坏的可能性。</li></ul><p>如图 30 所示，使用协作调度程序时系统的响应速度比使用抢占式调度程序时要慢：</p><ul><li>当使用抢占式调度器时，一旦某个任务成为最高优先级的就绪状态任务，调度器会立即开始运行该任务。这在必须在规定时间内响应高优先级事件的实时系统中通常是至关重要的。</li><li>当使用协作调度程序时，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 时，才会切换到成为最高优先级的就绪状态任务的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo的使用教程</title>
      <link href="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/"/>
      <url>/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文的内容适用性可能会随着 hexo 和相关程序的更新而改变，请以实际的操作结果为准。</p><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h2><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><p>为了把本地的网页文件上传到github上面去，需要用到工具———Git[下载地址]。Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git非常强大，建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程</p><p><strong>windows：</strong>到git官网上下载.exe文件，<a href="https://git-scm.com/download/win">Download git</a>，对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。安装选项还是全部默认，只不过最后一步添加路径时选择 Use Git from the Windows Command Prompt ，这样我们就可以直接在命令提示符里打开git了。</p><p><strong>linux：</strong>对 <code>linux</code> 来说实在是太简单了，只需要一行代码</p><pre><code>sudo apt-get install git</code></pre><h3 id="2-安装nodejs"><a href="#2-安装nodejs" class="headerlink" title="2. 安装nodejs"></a>2. 安装nodejs</h3><p>Hexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。</p><p><strong>windows：</strong>下载稳定版或者最新版都可以Node.js，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。</p><p><strong>linux：</strong>命令行安装：</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>不过不推荐命令行安装，有时候有问题，建议直接到<a href="http://nodejs.cn/">nodejs官网</a>去下载，如下所示：</p><p><img src="./hexo的使用教程/Nodejs_download.png" alt=""></p><p>安装完后，打开命令行终端，输入：</p><pre><code>node -vnpm -v</code></pre><p>检查一下有没有安装成功，出现版本号就是成功了。</p><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h3><p>前面<code>git</code>和<code>nodejs</code>安装好后，就可以使用 <code>npm</code> 安装<code>hexo</code>了。</p><blockquote><p>npm，全名 node package manger。</p><ul><li>npm 是<code>Node</code>的开放式模块登记和管理系统，是<code>Node.js</code>包的标准发布平台，用于<code>Node.js</code>包的发布、传播、依赖控制，网址：<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/">https://www.npmjs.com/</a></li><li>npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包</li></ul><p><a href="https://zhuanlan.zhihu.com/p/258080852">npm 超详细教程</a></p><p><a href="https://www.runoob.com/nodejs/nodejs-npm.html">npm 使用介绍</a></p></blockquote><p>右键点击<code>Git Bash Here</code>，打开<code>git</code>的控制台窗口，以后我们所有的操作都在<code>git</code>控制台进行，就不用<code>Windows</code>自带的<code>cmd</code>了(要用也能用)。</p><p>输入<code>npm install -g hexo-cli</code>安装 <code>Hexo</code>。可能会有几个报错，无视它就行。</p><pre><code>npm install -g hexo-cli</code></pre><p>安装完后输入 <code>hexo -v</code> 验证是否安装成功。</p><p>至此 <code>hexo</code> 就安装完了。</p><blockquote><p>npm包在全局安装之后，这个包的命令就会被注册到全局，你就可以直接在命令行中执行这个命令了。其实当你全局安装一个npm包之后，这个包被存放在默认全局安装路径中，可通过命令 <code>npm root -g</code> 查看，<code>npm config ls</code> 查看 npm 的基础设置。通过 <code>npm install express -g</code> 进行全局安装，express 是包的名称。</p><p>本地(局部)安装会将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。通过 <code>npm install express</code> 进行局部安装，express 是包的名称。本地安装的包不能在命令行中直接运行包的命令，因为命令行通过环境变量检索可执行的命令，而本地安装的包的路径没有加到环境变量中，可以通过将 node_modules 路径添加到环境变量(不建议)，或者本地安装路径用路径来使用，如：<code>./node_modules/.bin/hexo g</code>  等效于全局安装时的 <code>hexo g</code> 命令，还可以使用 <code>npx hexo g</code> 。</p><p>上面的 hexo-cli 包就是全局安装，全局安装可以一个包多个项目共用，但不同的项目可能对包的版本要求各有不同，容易发生冲突，结合实际情况选择全局安装还是局部安装。</p></blockquote><h3 id="4-初始化-hexo"><a href="#4-初始化-hexo" class="headerlink" title="4. 初始化 hexo"></a>4. 初始化 hexo</h3><p>接下来初始化一下 <code>hexo</code> ，即初始化我们的网站，输入 <code>hexo init</code> 初始化文件夹</p><pre><code>hexo init &lt;folder&gt;</code></pre><p><code>folder</code> 指定一个文件夹(若该文件夹不存在，则创建自动该文件夹)，在该文件夹下新建所需要的文件。如果没有指定这个参数，将直接在当前路径下新建所需文件。</p><p>接着进入新建了所需文件的路径，输入 <code>npm install</code> ，根据运行 <code>hexo init</code> 新建的文件中的配置安装必备的组件。</p><blockquote><p>注意：这里使用的下载命令是 <code>npm install</code> ，所以是局部安装，所以每次在其他路径初始化新的网站 (<code>hexo init</code>) 后，都要执行 <code>npm install</code> 下载一遍必备的组件。前面安装 hexo 是全局安装，所以不用重新安装 hexo。</p></blockquote><p>完成后，指定目录下有：</p><ul><li><code>node_modules:</code>  依赖包</li><li><code>public:</code> 存放生成的页面</li><li><code>scaffolds:</code> <a href="https://hexo.io/zh-cn/docs/writing#模版（Scaffold）">模版</a> 文件夹。新建文章时，Hexo 会根据 scaffold 来创建文件。</li></ul><blockquote><p>Hexo 的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改 <code>scaffold/post.md</code> 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</p></blockquote><ul><li><code>source:</code> 用来存放用户的文章</li></ul><blockquote><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p></blockquote><ul><li><code>themes:</code> <a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li><li><code>_config.yml:</code>  网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</li><li><code>package.json:</code> 应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，可以自由移除</li></ul><p>这样本地的最简单的网站配置就弄好了，输入<code>hexo g</code> 生成静态网页，然后输入<code>hexo s</code> 打开本地服务器：</p><pre><code>hexo ghexo server(或者简写:hexo s）)</code></pre><h2 id="配置-hexo-的-config-yml"><a href="#配置-hexo-的-config-yml" class="headerlink" title="配置  hexo 的 _config.yml"></a>配置  hexo 的 _config.yml</h2><p>官方的文档更详细——&gt;<a href="https://hexo.io/zh-cn/docs/configuration">配置</a> ，强烈建议忘记相关内容时优先看官方文档，在这里只选出部分内容配合图片进行说明。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词。支持多个关键词。</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table></div><p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者(如果在文章的参数中指定了另一个author，这里的author就会被覆盖，未指定就显示这里的author)。</p><p><img src="_config.yml-Site.png" alt=""></p><p><img src="./hexo的使用教程/_config.yml-Site.png" alt=""></p><p><img src="./hexo的使用教程/_config.yml-Site_1.png" alt=""></p><h2 id="细碎的网页配置记录"><a href="#细碎的网页配置记录" class="headerlink" title="细碎的网页配置记录"></a>细碎的网页配置记录</h2><h3 id="首页轮播"><a href="#首页轮播" class="headerlink" title="首页轮播"></a>首页轮播</h3><p>首先想要看到轮播效果必须先把文章加入轮播里，首页图片和文章图片组成了轮播，如果不把文章加入轮播里就算开启了轮播也没有办法看到轮播效果。怎么加入readme文件中有文章Front-matter的介绍(建议ctrl+f搜索关键字)，也就是新建文章需要有哪些配置</p><h3 id="首页背景颜色"><a href="#首页背景颜色" class="headerlink" title="首页背景颜色"></a>首页背景颜色</h3><p>更改颜色主题文件夹下的source/css/matery.css的606-696行， 背景颜色可以要可以不要，看你选择的轮播图片了。如果轮播图片颜色较浅就要加，因为不加的话上面的文字会看不清楚，颜色也可以更改。不过没有找到好的配色的话还是不要乱改变了，会很丑</p><h3 id="导航栏背景颜色"><a href="#导航栏背景颜色" class="headerlink" title="导航栏背景颜色"></a>导航栏背景颜色</h3><p>也是matery.css中找到.bg-cover修改，我用的是</p><pre class=" language-lang-css"><code class="language-lang-css">   .bg-color {    background-image: linear-gradient(to right, #7371BC 0%, #284D95 100%);   }</code></pre><p>改了你想用的颜色之后其他的图标、hover等等的颜色也要与导航栏相匹配才好看，怎么找其他的呢？告诉你一个比较笨又比较方便的一个办法。在matery.css中从头到尾找与刚才.bg-cover中相近的颜色(一般编辑器中都会显示颜色)全部改为你想要的颜色，轮播图片中按钮颜色找.cover-btns。具体配色看个人喜好了</p><h3 id="新建文章的模板修改"><a href="#新建文章的模板修改" class="headerlink" title="新建文章的模板修改"></a>新建文章的模板修改</h3><p>首先为了新建文章方便，我们可以修改一下文章模板，可以将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class=" language-lang-markdown"><code class="language-lang-markdown">---title: {{ title }}date: {{ date }}author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:keywords:tags:categories:---</code></pre><p>这样新建文章后 一些<code>Front-matter</code>参数不用你自己补充了，hexo会自动将这些内容复制到新建的博客中，修改对应信息就可以了。</p><h3 id="matery主题的背景图遮罩颜色"><a href="#matery主题的背景图遮罩颜色" class="headerlink" title="matery主题的背景图遮罩颜色"></a>matery主题的背景图遮罩颜色</h3><h3 id="在博客中使用本地图片"><a href="#在博客中使用本地图片" class="headerlink" title="在博客中使用本地图片"></a>在博客中使用本地图片</h3><p>对应官方文档的 <a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a> 章节</p><p>想要更有规律地提供图片和其他资源以及想要将资源分布在各个文章上时，可以将 hexo 的 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 。</p><p>这样的话 Hexo 将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><p><img src="hexo的使用教程/image-20240322031826172.png" alt="新建文章"></p><p><img src="hexo的使用教程/image-20240322032008441.png" alt="自动生成对应文件夹"></p><p>但是通过常规的 markdown 语法和相对路径来引用图片和其它资源在网页上并不能正常显示。</p><p><img src="hexo的使用教程/image-20240322032521818.png" alt="图片不能正常显示"></p><h4 id="使用标签插件"><a href="#使用标签插件" class="headerlink" title="使用标签插件"></a>使用标签插件</h4><p>要想让 md 文件中引用的本地图片在网页上正常显示，可以使用 hexo 提供的功能。</p><p>以上面图片中新建的 111.md 为例，把一个 <code>example.jpg</code> 图片放在了对应 111 文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](./111/example.jpg)</code> ，图片不会出现在网页上。要想在网页上正确显示图片，应该使用 hexo 插件提供的功能：</p><pre><code>{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %}</code></pre><pre><code>{% asset_img example.jpg This is an example image %}</code></pre><p>图片正常显示：</p><p><img src="123.jpg" alt="image-20240322040752173" style="zoom:50%;"></p><p>这种方法只能引用与文章同名的文件夹下的图片，上例中，如果在 111 文件夹下创建一个 222 文件夹，将图片放进去，想用  引用图片，这种操作是无效的。</p><p>通过这种方法引用的图片只能在构建成网页时显示，在 markdown 编辑器中只是一行代码而已，毕竟不是 markdown 语法的一部分，实际体验并不是很好。</p><h2 id="使用markdown语法"><a href="#使用markdown语法" class="headerlink" title="使用markdown语法"></a>使用markdown语法</h2><p>hexo-renderer-marked 允许你无需使用 <code>asset_img</code> 标签插件就可以在 markdown 中嵌入图片</p><h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><h3 id="部署-deploy-时遇到的问题"><a href="#部署-deploy-时遇到的问题" class="headerlink" title="部署(deploy)时遇到的问题"></a>部署(deploy)时遇到的问题</h3><p><img src="hexo的使用教程/error1.png" alt="error1"></p><p><strong>解决方法：</strong></p><p><img src="hexo的使用教程/error2.png" alt="error2"></p><p>图中提供的资料链接：<a href="https://docs.github.com/code-security/secret-scanning/pushing-a-branch-blocked-by-push-protection">Learn how to resolve a blocked push</a></p><p>黄框中用来进行验证的临时链接：</p><p><img src="hexo的使用教程/image-20240324035941633.png" alt="image-20240324035941633" style="zoom:67%;"></p><p>看了一下大概是为了保证仓库安全而采取的措施。</p><p>1</p><img src="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/error2.png" class="" title="这是一张图片"><p>2</p><p>3</p><p><img src="error2.png" alt="这是一张图片"></p><p>4</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/">hexo 官方中文文档</a></p><p><a href="https://blog.csdn.net/qq_58608526/article/details/124652412">Hexo+Github博客搭建教程</a></p><p><a href="https://blog.csdn.net/kuashijidexibao/article/details/112971657">Hexo-Matery主题细致美化</a></p><p><a href="https://x-hao.github.io/2021/04/22/hexo-matery-da-jian-ge-ren-bo-ke-cai-keng-ji-lu/">hexo+matery搭建个人博客踩坑记录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记</title>
      <link href="/Blogs/2023/03/07/shen-du-xue-xi/"/>
      <url>/Blogs/2023/03/07/shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<pre class=" language-lang-yaml"><code class="language-lang-yaml">    在机器学习中，一切的数据都可以看作是矩阵</code></pre><p>Tensor：可以进行GPU加速计算的矩阵（任意维度），Tensorflow操作的基本呢单元</p><p>Tensor可以和numpy进行相互转换</p><pre class=" language-lang-python"><code class="language-lang-python">#直接转换x.numpy()#指定转换格式x=tf.case(x,tf.float) #转换成浮点型矩阵</code></pre><p>机器学习流程：（深度学习属于机器学习的一部分）</p><ul><li>数据获取</li><li>特征工程</li><li>建立模型 </li><li>评估与应用</li></ul><p>特征工程的作用</p><ul><li>数据特征决定了模型的上限</li><li>预处理和特征提取是最核心的</li><li>算法与参数选择决定了如何逼近这个上限</li></ul><p>深度学习相对于传统的机器学习主要解决了特征工程这一部分，搭建了非常好的神经网络模型，去找出最合适的特征</p><p>深度学习应用：</p><p>主要用于计算机视觉处理、人脸识别</p><p>计算量很大，因此在移动端支持不是很好，神经网络的参数为百万千万级别。</p><p>颜色通道：RGB是其中一种，有3个颜色通道，读出来是一个三维数组</p><p>一张图片的颜色是由RGB三个通道构成, 可以把一张图片上的每一个像素点看成一个对象, 这个对象又由RGB三种颜色叠加, 即用一个一维数组表示,假如我们有一张 m * n 个像素点的图片, 那么每一行有 n 个像素, 即每一行有 n 个一维数组, 即这一行是一个二维数组, 那一张图片又有 m 行, 那么我们就得到了 m 个二维数组, 这m 个二维数组构成了一个三维数组，如果将RGB看作一个整体的值那么图像也可以理解成二维数组。</p><p>python中的图像（三位数组）</p><p><img src="图像与3维数组.png" alt=""></p><p>红色代表 R <a href="https://so.csdn.net/so/search?q=通道&amp;spm=1001.2101.3001.7020">通道</a>亮度值, 绿色代表 G 通道亮度值, 蓝色代表 B 通道亮度值</p><p><a href="https://blog.csdn.net/qq_29304033/article/details/116722162">https://blog.csdn.net/qq_29304033/article/details/116722162</a></p><p>计算机视觉面临的挑战：</p><ul><li>目标的一部分被其他物体遮蔽</li><li>目标与背景的特征高度相似（背景混入）</li></ul><p>需要给计算机遮蔽或混入的数据，并告诉它答案（标签），训练计算机去识别这种情况</p><p>机器学习的常规套路：</p><ul><li>收集数据集并给定标签</li><li>训练一个分类器</li><li>测试，评估</li></ul><p>视觉任务中要识别的往往只是图像中的一小部分主体，剩余的部分会影响处理，因此要尽可能地排除掉</p><p>线性函数：</p><p>从输入到输出的映射</p><p>输入一个图像和参数，输出每个类别的得分</p><p>损失函数：</p><p>衡量分类的结果</p><p>损失函数的值相同并不代表两个模型相同</p><p>损失函数=数据损失+正则化惩罚项</p><p>我们总是希望模型不要太复杂，过拟合的模型是没用的</p><p>神经网络整体架构</p><p>层次结构、神经元、全连接、非线性</p><p>神经元个数对结果的影响</p><p>个数越多，效果越好，过拟合风险越大</p><p>正则化和激活函数</p><h1 id="Neural-network-神经（元）网络"><a href="#Neural-network-神经（元）网络" class="headerlink" title="Neural network 神经（元）网络"></a>Neural network 神经（元）网络</h1><h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p><img src="数字图像.png" alt=""></p><p>What are the neurons ?  什么是神经元？</p><p>How are they connected ?  它们是如何连接在一起的？</p><p>以手写数字识别为例</p><p>在这里，我们先暂时把神经元理解成一个用来装数字的容器，装着一个0到1之间的数字，仅此而已。像上图，这个神经网络一开始的地方有很多神经元，分别对应了28x28输入图像的每一个像素，总计784个神经元，神经元中装着的数字代表对应像素的灰度值，0代表纯黑像素，1代表纯白像素。我们把神经元里装着的数叫做“激活值”（activation）。可以想象这么一个画面：激活值越大，那么这个神经元就点着越亮那么这784个像素就组成了神经网络的第一层。</p><p><img src="神经网络结构.png" alt=""></p><p>现在我们跳到网络的最后一层，这一层的十个神经元分别代表0~9这十个数字，它们的激活值，同理都处在0到1之间。这些事表示系统认为输入的图像对应着哪个数字的可能性。网络中间还有几层”隐藏层“。神经网络运作时，上层的激活值将决定下层的激活值。所以说神经网络处理信息的核心机制正是一层的激活值是通过怎样的运算，算出下一层的激活值的。某种程度上讲，它想模仿的是生物中神经元组成的网络，某些神经元的激发就会促使另一些神经元激发。</p><p>在介绍网络每层间如何影响，训练过程的数学原理之前，我们先讨论影响，凭什么我们就觉得这种层状结构可以做到只能判断。我们在期待什么？我们到底期望值这些中间层最好能做些什么呢？当我们人类在识别数字时，我们是在组合数字的各个部件，如下图：</p><p><img src="数字的组成.png" alt=""></p><p>在理想的情况下，我们希望倒数第二层中的各个神经元能分别对应一个笔画部件。这样一来，当我们输入9或者8这种带圈的数字时，某个神经元的激活值就会接近1。而且我并不特指某种样子的圈，我是希望所有位于图像顶部的圆圈团都能点亮这个神经元，这样一来从第三层到最后一层，我们只要学习哪些部件能组合出哪个数字即可。</p><p><img src="数字的组成2.png" alt=""></p><p>当然，这样一来我们就引来更多的问题，例如要如何识别这些部件，而且我还没提到上一层网络是如何影响下一层的，不过暂时让我们先把这个话题讨论完。</p><p>识别圆圈的任务同理可以拆分成更细微的问题，一种合理的方法是首先识别出数字图形中更小的边，比如像1、4、7中的这种长条，就是一条长边嘛，或者把它当做几条短边组合起来的图案也可以。于是我们希望，也许神经网络第二层的各个神经元，就能对应上这些各种各样的短边。</p><p><img src="数字的组成3.png" alt=""></p><p>没准当9的数字图像输入进来的时候，它就能把所有关联短边的神经元都点亮，接着就能点亮对应顶部圆圈和长竖条的神经元，最后就能点亮输出层对应9的神经元，至于不咱们的网络是否能做到这一步，等解释完网络如何训练，再回头讨论吧。但这就是我们所希望的，希望这种层状结构能完成的目标，更进一步讲，加入神经网络真能识别出这类边缘和图案，它就能很好的运用到其他图像的识别任务上。甚至不光是图像识别，世界上各种人工智能的任务都可以转化为抽象元素，一层层的抽丝剥茧，比如说语音识别，也就是要从原音频中识别出特殊的声音组合成特定的音节，组合成单词，再组合成短语以及更加抽象的概念。</p><p>回到神经网络工作原理的话题上来，试想一下，你要设计上一层中的激活值到底如何让决定下一层中的激活值，我们需要设计一个机制，可以把像素拼成短边，把短边拼成图案或者把图案拼成数字等等。在数字识别这个例子中我们来放大关注其中一个，我们来设计，让第二层中的这一个神经元能够识别出图像中的这块区域是否存在一条边。</p><p><img src="数字识别4.png" alt=""></p><p>我们需要给这个神经元和第一层所有神经元间的每一条接线都赋上一个权重值，这些权重值都不过是数字而已。然后，我们拿起第一层所有的激活值，和它们对应的权重一起，算出它们的加权和。</p><p>如果我们把关注区域的权重赋为正值，而其他所有的权重一律赋为0，这样一来，对所有的像素值取加权和就只会累加我们关注区域的像素值了，如果你真的像识别出这里是否存在一条边界，只需要给周围的一圈像素赋予负的权重，这样当中间的像素亮周围的像素暗时加权和就能达到最大。（在周围一圈加负数权重的意义在于确定像素点亮的区域是仅限于你关注的区域还是周围的一大片都是亮的，当只有负权重围住的的区域亮的时候加权和最大，若负权重对应的像素点也是亮的，则加权和减小）。这样计算出来的加权和可以是任意大小，但在这个网络中，我们需要激活值都处在0到1之间，那么我们就可以顺其自然把这个加权和输进某个函数，将加权和挤压进0到1的区间内（归一化），其中有一个叫sigmoid的函数非常有用，它能将很大范围的实数压进（0，1）区间</p><p><img src="sigmoid函数.png" alt=""></p><p>所以这个神经元中的激活值，实际上就是对加权和到底有多正的打分。但有时，即使加权和大于0时，你也不想把神经元点亮，可能只有当和大于10时才让它激发，此时你就需要加上一个偏置值，保证不能随便激发，而我们只需要在加权和之后加上一个负10之类的数，再把它送进sigmoid函数中压缩即可。</p><p><img src="sigmoid函数2.png" alt=""></p><p>总而言之，权重告诉你这个第二层的神经元关注什么样的像素图案，偏置则告诉你加权和得有多大才能让神经元的激发变得有意义。</p><p>我们这就解说完了其中一个神经元，但是第二层中的每个神经元都会和第一层中的784个神经元相连接，每一个的784个接线上都带着一个权重，而且每个神经元都会在计算自己的加权和后加上自己的偏置再通过sigmoid压缩输出自己的结果，一下子要考虑的就多起来了，而且这单单时第一层和第二层之间的连接，别的层之间的连接还有它们分别自带的权重和偏置，一套下来整个网络的参数和计算量都是非常大的。整个网络有非常多个参数等着你去调整，从而带来不一样的结果。所以当我们讨论机器如何学习的时候，我们其实在讲，电脑应该如何设置这一大坨数字参数，才能让它正确地解决问题。</p><p>如果每个激活值都用sigmoid函数列出来会非常麻烦，通常采用另一种方法表示：我们把某一层中所有的激活值统一成一列向量，再把它和下一层间所有的权重放到一个矩阵中，矩阵的第n行就是这一层的所有神经元和下一层第n个神经元间所有连线的权重。这样权重矩阵和向量乘积的第n项就是这一层所有的激活值和下一层第n个神经元间连线权重的加权和，最后加上偏置值组成的向量，最后用sigmoid包起来（就是指对表达式结果向量中的每一项都取一次sigmoid）</p><p><img src="加权和简洁表示.png" alt=""></p><p><img src="加权和简洁表示2.png" alt=""></p><p>现在只要我们写一下权重矩阵和相应向量的符号，神经网络各层之间激活值的转化就可以清晰简洁明了了。</p><p>前面提过暂时把神经元看作数字的容器，实际上神经元中装着的值是取决于你的输入图像的，所以我们把神经元看作一个函数才更加准确，它输入的是上一层所有神经元的输出，而它的输出是一个0到1之间的值。其实神经网络就是一个函数，一个输入784个值，输出10个值的函数，不过这个函数极其复杂，用了大量权重参数偏置参数来识别特殊图案，又要循环不停地用矩阵乘法和sigmoid映射运算，但它终究只是个函数而已。而它的复杂程度可以稍微让人安点心，如果它没这么复杂的话，我们恐怕就不大能指望它的数字识别能多准了。</p><p>值得一提的是，sigmoid函数多应用于早期的网络，把加权和映射到0~1的区间内，来模仿生物学上的神经元是否激发。但现在的网络基本都不用sigmoid了，相比之下ReLU（Rectified Linear Unit  线性整流函数）更好训练，其作用是返回0和a的最大值，其中a就是函数的输入。当超过一个阈值的时候，ReLU就和恒定函数一样，而没过这个阈值，那就不激发，输出0。sigmoid并没有让训练结果变得更好，或者某种程度上讲它很难训练，后来有人拿ReLU试了试，结果发现在特别深的神经网络上效果特别的好。</p><p><img src="ReLU.png" alt=""></p><h2 id="梯度下降法介绍"><a href="#梯度下降法介绍" class="headerlink" title="梯度下降法介绍"></a>梯度下降法介绍</h2><p>梯度下降法是神经网络学习的基础，机器学习中很多其他技术也是基于这个方法。</p><p>现在我们想要这么一种算法，你可以给这个网络看一大堆训练数据，其中包括一堆不同的手写数字图像以及它们代表哪个数字的标记。算法会调整神经网络的各个权重和偏置值，以提高网络对训练数据的表现。我们希望这种分层结构可以让它举一反三，识别训练数据之外的图像。训练好网络后，我们会给它更多以前从未见过的带标记的数据作为测试，你就能看到它对这些新图像进行分类的准确度。</p><p>虽然机器会”学习“的说法很大胆，但当你实际看到它的工作原理之后，这听起来就不再像是疯狂的科幻场面，而更像是一道微积分习题了———-我是指这实际上是再找某个函数的最小值。</p><p>从概念上讲，我们认为每个神经元都与上一层的所有神经元相连接。决定其激活值的加权和中的权重，有点像是那些连接的强弱，而偏置值则表明神经元是否更容易被激活</p><p><img src="加权和.png" alt=""></p><p>在一开始，我们会完全随机地初始化所有的权重和偏置值，可想而知，这个网络对于给定的训练示例会表现得非常糟糕，毕竟它只是在做随机的判断。这时你就要定义一个”代价函数“来告诉电脑它输出了提高糟糕的结果，用更加数学的语言来说，你要讲每个垃圾输出激活值与你想要的值之间的差的平方加起来，我们称之为训练单个样本的”代价“（注：单个样本上代价也叫Loss”损失/误差“ by吴恩达）。注意一下，网络能对图像进行正确的分类时，这个平方和就比较小，但如果网络稀里糊涂找不着北的话，这个平方和就很大。</p><p>接下来你就要考虑手头上几万个训练样本中代价的平均值，而我们就用这个平均代价来评价这个网络有多糟糕，电脑应该有多内疚。但这东西挺复杂的，要记得网络本身不过是个函数，有784个输入值即像素的灰度，最后的输出值是10个数字，而所有的权重值和偏置值可以说就组成了这个函数的参数。而代价函数还要再抽象一层，所有的权重值和偏置值作为它的参数，它输出的是单个数值，来表示这些权重和偏置有多差劲。而且代价函数取决于网络对于上万个训练数据的综合表现。</p><p>但如果你只告诉电脑它有多糟糕，那并不是很有用。你还得告诉它怎么改变这些权重和偏置值才能进步。为了简化问题，我们先不去想一个有庞大变量的函数，而先考虑简单的一元函数，只有一个输入变量，只输出一个数字要怎么找输入值x，使得函数值最小呢？</p><p><img src="一元函数的最小值.png" alt=""></p><p>学过微积分的都知道，有时候你可以直接算出这个最小值，不过函数很复杂的话就不一定能写出来，对于神经网络这个超复杂的函数就更加不可能做到了。一个更灵活的技巧是先随便挑选一个输入值，然后考虑向左走还是向右走，函数值才会变小。准确地说，如果你找到了函数在这里的斜率，那么斜率为正就向左走，斜率为负就向右走。在每个点都这样子重复计算新的斜率，在适当地走一小步的话，你就会逼近函数的某个局部最小值。要注意，就算是一个很简单的一元函数，由于不知道一开始的输入值在哪个位置，最后你可能落到许多不同的坑里，而且无法保证你落到的局部最小值就是代价函数可能达到的全局最小值，我们的神经网络也会遇到这个问题。值得一提的是如果每步的大小和斜率成比例，那么在最小值附近斜率会越来越平缓，每步会越来越小，这样可以防止调过头。</p><p>想象一个更复杂的，两个输入一个输出的二元函数，输入空间可以想象成XY平面，代价函数是平面上方的曲面，现在我们不问函数的斜率，而是应该问，在输入控件内沿哪个方向走，才好让输出结果下降得最快。</p><p><img src="二元函数.png" alt=""></p><p>熟悉多元微分的人已经知道，函数的梯度指出了函数的最陡增长方向。即是说，按梯度的方向走，函数值增长得就最快，那么沿梯度的负方向走，函数值自然就降低得最快了。而且，这个梯度向量的长度就代表了这个最陡的斜坡到底有多陡。</p><p>也就是说，让函数值最小的算法只不过是先计算梯度，再按梯度反方向走一步，然后循环。想想把所有权重偏置都放到一个列向量里，那么代价函数的负梯度也不过是个向量。负梯度正是指出了在这个大到爆炸的函数输入空间内，具体如何改变每一项参数，才可以让代价函数的值下降得最快。</p><p><img src="梯度向量.png" alt=""></p><p>那么，对于这个我们特别设计的代价函数，更新权重和偏置来降低代价函数的值，意味着输入训练集的每一份样本的输出都更接近期待的真实结果，而不是一串10个的随机数组。要注意的是这个函数取了整个训练集的平均值，所有最小化的意思是：对所有样本得到的总体结果都会更好一点。</p><p>这个梯度算法是神经网络的核心，我们叫做反向传播算法【BP】。</p><p>当我们提到让网络学习，实质上就是让代价函数的值最小，而未来达到这个效果，代价函数非常有必要是平滑的，这样我们才能，每次挪动一点点，最后找到一个局部最小值。这也顺便解释了为什么人工神经元的激活值是连续的而非直接沿袭生物学神经元那种二元式的，要么激活要么非激活的取值模式。这种按照负梯度的倍数，不停调整函数输入值的过程就叫做梯度下降法。这是一种可以让你收敛到代价函数某一个局部最小值里的地方。</p><p>目前为止我们都值展示了二元函数的图像，毕竟人脑想象一个太高维度空间中的变动是在是强人所难，但其实我们还有一种漂亮的思路，不用借助空间。</p><p><img src="梯度向量2.png" alt=""></p><p>负梯度中的每一项都告诉了我们两件事：正负号明显在告诉我们输入向量的这一项该调大还是调小，但重要的是每一项的相对大小更告诉了我们改变哪个值的影响更大。所以这时你再去看这个梯度向量，就可以把它理解为各个权重偏置的相对重要度，标记出了改变哪个参数的性价比最高。</p><p>这也是理解方向的另一种方式，举个简单的例子，假设有个输入两个变量的二元函数，你算出这个函数再某一点的梯度是[3，1]，一种解读是，你站在这个点顺着这个梯度的方向移动，函数的数值增加得最快,变化率最大（为该梯度的模）</p><p><img src="梯度向量3.png" alt=""></p><p>当你讲这个函数的曲面画出来时，可以看到沿着这个向量的方向走函数值增长最快。</p><p><img src="梯度向量4.png" alt=""></p><p>但我们还有另外一种解读，即<strong>第一个变量的重要性是第二个变量的3倍</strong>。也就是说，至少在这块取值区域内，改变x的值会造成更大（3倍）的影响。</p><p>好吧，我们回到对网络的讨论中来，小结一下。神经网络本身是一个多个输入和多个输出的函数，由各种加权和所定义。代价函数则是更复杂一层，讲所有权重偏置作为输入，通过训练数据，得出一个对网络糟糕程度的评分。而代价函数的梯度，则比上边还要复杂一层，告诉我们如何让微调群众偏置的值才可以让代价函数的结果改变得最快。也就是可以理解为，改变了哪些权重造成的影响最大。</p><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p><img src="反向传播算法.png" alt=""></p><p>开始讲解时就让我们我们先忘记上面的公式，完全抛弃所有符号，一步步解释每一个训练样本会对权重偏置的调整造成怎样的影响。</p><p>因为代价函数牵扯到对成千上万个训练样本的代价取平均值，所以我们调整每一步梯度下降用的权重偏置也会基于所有的训练样本——原理上时这么说。但未来计算效率，之后咱们会讨个巧，从而不必每部都非得要计算所有的训练样本。还需要说明一点，我们现在只关注一个训练样本，比如一张2的手写数字图片，这一个训练样本会对调整权重和偏置造成怎样的影响呢？</p><p><img src="反向传播算法2.png" alt=""></p><p>现在假设网络还没有完全训练好，那么输出层的激活值看起来就很随机，我们并不能直接改动这些激活值，只能改变权重和偏置值，但记住我们想要输出层出现怎样的变动还是很有用的。因为我们希望图像最终的分类结果是2，我们希望输出层中对应2 的神经元的激活值变大，其他神经元的数值变小，并且变动的大小应该与现在值和目标值之间的差呈正比。例如下图中增加数字2神经元的激活值，就应该比减少数字8神经元的激活值来得重要，因为后者已经很接近它的目标（0）了。</p><p><img src="反向传播算法3.png" alt=""></p><p>那好，我们更近一步，关注一下2对应的神经元，我们要让这里面的激活值变大。还记得吗？这个激活值是把前一层所有激活值的加权和加上一个偏置，再通过sigmoid、ReLU之类的挤压函数，最后算出来的吧。所有要增加这个激活值，二目有三条大路可走，一增加偏置，而增加权重，三改变前一层的激活值。</p><p>先来看看如何调整权重，各个权重它们的影响力各不相同，连接前一层最亮神经元的权重影响力也最大，因为这些权重会与大的激活值相乘。所有至少对于这样一个训练样本而言，增大了这几个权重值对最终代价函数造成的影响就比增大连接暗淡神经元的权重所造成的影响要大上很多倍。请记住当我们说到梯度下降的时候，我们并不只看每个参数是该增大还是减小，我们还该哪个参数的性价比最高。</p><p>对于改变前一层的激活值这一方法，更具体地说，如果所有正权重连接的神经元更亮，所有负权重连接的神经元更暗的话，那么数字2的神经元就会更强烈地激发，和改权重的时候类似，我们想造成更大的影响，就要依据权重的大小对激活值做出成比例的改变，当然我们并不能直接改变激活值，我们手头只能控制权重和偏置。但就光对输出层来说，记住我们期待的变化还是很有帮助的。</p><p>不过别忘了，从全局上看，这只不过是数字2的神经元所期待的变化。我们还需要输出层其余的神经元的激发变弱，但这其余的每个输出神经元对于如何让改变倒数第二层都由各自的想法。所以我们会把数字2神经元的期待和别的输出神经元的期待全部加起来，作为对如何改变倒数第二层神经元的指示。这些期待不仅是对应的权重的倍数，也是每个神经元激活值改变量的倍数。这其实就是再实现”反向传播“的理念了。我们把所有期待的改变加起来，就得到了一喜欢对倒数第二层改动的变化量，有了这些，我们就可以重复这个过程，改变倒数第二层神经元激活值的相关参数，从后一层到前一层，一直把这个过程循环到第一层。</p><p>放眼大局，还记得我们只是再讨论单个训练样本对所有权偏置的影响吗？如果我们只关注那个2的要求，最后网络只会把所有图像都分类成2，所以你要对其他所有的训练样本同样地过一遍反向传播，记录下每个样本想怎样修改权重与偏置，最后取一个平均值。</p><p><img src="反向传播算法4.png" alt=""></p><p>顺带一提，实际操作中，如果梯度下降的每一步都用每一个训练样本来计算的话，拿华东时间就太长了，所以我们一般会这样做：首先把训练样本打乱，然后分成很多组minibatch，每个minibatch就暂且当它包含100个样本好了，然后你算出这个minibatch下降的一步，这不是代价函数真正的梯度，毕竟计算真实梯度得用上所有的样本而非这个子集，所以这也不是找出代价函数局部最小值最高效的一步，然而，每个minibatch都会给你一个不错的近似，而且更重要的是，你的计算量也会减轻不少，这个技巧叫做随机梯度下降。</p><p>小结一下，反向传播算法算的是单个训练样本想怎样修改权重与偏置，不仅是说每个参数应该变大还是变小，还包括了这些变化的比例是多大，才能最快地降低代价，真正的梯度下降得对好几万个训练范例都这操作，然后对这些变化值取平均，但算起来太慢了，所以你会先把所有的样本分到各个minibatch中去，计算一个minibatch来作为梯度下降的一步，计算每个minibatch的梯度，调整参数，不断循环，最终你就会收敛到代价函数的一个局部最小值上。此时就可以说你的神经网络对付训练数据已经很不错了。</p><p>在实际设定神经网络的权重和偏置的初始值时，正态分布是一个有用的工具，使用服从这个分布的随机数，容易取得好的结果。</p><p>柯西-施瓦茨不等式：</p><script type="math/tex; mode=display">- \left | a \right | \left | b \right | \le a\cdot b\le \left | a \right | \left | b \right |</script><p>向量内积（点积、数量积）：</p><script type="math/tex; mode=display">a\cdot b=\left | a \right | \left | b \right | \cos \theta = a_{1}b_{1}+  a_{2}b_{2}\left ( \theta 为a、b的夹角 \right )</script><p>向量积（叉积、外积）：</p><script type="math/tex; mode=display">a\times b=det\begin{bmatrix} i & j &k \\ a_{x}   & a_{y}  & a_{z} \\ b_{x}   & b_{y}  & b_{z} \end{bmatrix}</script><p>根据柯西-施瓦茨不等式可以得出以下结论</p><ul><li>当两个向量方向相反时，内积取得最小值</li><li>当两个向量不平行时，内积取得平行时的中间值</li><li>当两个向量方向相同时，内积取得最大值</li></ul><p><img src="向量点积.jpg" alt=""></p><p>另外，可以认为内积表示两个向量在多大程度上指向相同方向。如果将方向相似判定为“相似”，则两个向量相似时内积变大。后面我们考察神经网络时，这个观点就变得十分重要。</p><p><img src="向量相似度.png" alt=""></p><p>向量的一般化 </p><p>我们平常见到的多是平面（二维空间）以及三维空间中的向量。向量的方便之处就在于，二维及三维空间中的性质可以照搬到任意维空间中。神经网络索然要处理数万维的空间，但是二维空间以及三维空间中的向量性质可以直接利用，处于该原因，向量被充分应用于梯度下降法中。</p><p>张量（tensor）时向量概念的推广，谷歌提供的人工智能学习系统TensorFlow的命名就用到了这个数学术语</p><p>tensor来源于tension（物理学中的张力）。想固体施加张力时，会在固体的截面产生力的作用，这个力称为应力。这个力在不同的界面上大小和方向各不相同。</p><p><img src="张量.png" alt=""></p><p>因此当法向为x、y、z轴时，作用在上面的力依次用向量表示为。</p><script type="math/tex; mode=display">\begin{bmatrix} T_{11}\\ T_{21}\\ T_{31}\end{bmatrix},\begin{bmatrix} T_{12}\\ T_{22}\\ T_{32}\end{bmatrix},\begin{bmatrix} T_{13}\\ T_{23}\\ T_{33}\end{bmatrix}</script><p>可以将它们合并为以下矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}  T_{11}& T_{12} & T_{13}\\  T_{21}& T_{22} & T_{23}\\  T_{31}& T_{32} & T_{33}\end{bmatrix}</script><p>我们称这个量为应力张量。</p><p>张量值应力张量在数学上的抽象。我们不清楚谷歌用TensorFlow明明人工智能学习系统的原委，不过在神经网络的世界里，经常用到附带多个下标的变量，这与张量的计算相似，可能也是出于这个原因，TensorFlow才这样命名吧。</p><p>需要区分张量中的维度与阶数的概念。具体地说，一个张量总由m^n个数值分量构成，其中m是维度数，n是阶数。</p><p>零阶张量就是平时说的标量，一阶张量就是向量，二阶张量就是矩阵。</p><p>多元函数</p><p>多元函数难以直观化，描述神经网络的函数的变量有成千上万个，因此难以从直观上理解这些函数。不过，只要了解了单变量的情况，我们就可以将多变量的情况作为其扩展来理解。</p><p>偏导数</p><p>求导的方法也同样适用于多变量函数的情况。但是，由于有多个白能量，所以必须知名对哪一个变量进行求导。在这个意义上，关于某个特定变量的导数就称为偏导数（partial derivative）。</p><p>多元函数的最小值条件</p><p>光滑的一元函数在某点取得最小值的必要条件是导函数在该点取值为0，事实上这对于多元函数同样适用。因此多元函数在某点取最小值的必要条件是函数在该点对各变量求偏导的值为0。在实际的最小值问题中，又是会对变量附加约束条件，这种情况下我们可以使用拉格朗日乘数法，在用于求性能良好的神经网络的正则化技术中，经常使用该方法。</p><p>梯度下降法思路</p><p>链式求导法则不再赘述，求二元函数的最小值</p><script type="math/tex; mode=display">z=f(x,y)\to \frac{\partial f(x,y)}{\partial x} =0,\frac{\partial f(x,y)}{\partial y} =0</script><p><img src="偏导.png" alt=""></p><p>在实际问题中，偏导公式通常不容易求解，梯度下降法（最速下降法）是一种具有代表性的替代方法。</p><script type="math/tex; mode=display">\Delta z=f(x+\Delta x,\Delta y)=\frac{\partial f(x,y)}{\partial x} \Delta x+\frac{\partial f(x,y)}{\partial y} \Delta y</script><p>上式可以表达为向量的内积形式</p><script type="math/tex; mode=display">\left ( \frac{\partial f(x,y)}{\partial x},\frac{\partial f(x,y)}{\partial y}  \right ).\left ( \Delta x,\Delta y \right )</script><p>注意这个内积的关系，这就是梯度下降法的出发点。我们知道，当两个向量的方向相反时，它们的内积取得最小值（负数），所以，当两个向量满足下式时，函数值减小得最快</p><script type="math/tex; mode=display">\left ( \Delta x,\Delta y  \right ) = -\eta \left ( \frac{\partial f(x,y)}{\partial x},\frac{\partial f(x,y)}{\partial y}  \right )  \eta为正的微小常数</script><p>右边的向量称为函数在点（x，y）处的梯度（gradient）。</p><p>寻找最小值时我们线选定一点，求出函数在该点的梯度，最后求出偏移向量并进行偏移，重复此过程直至找到梯度为0的点，求出最小值。</p><script type="math/tex; mode=display">\left ( x+\Delta x,y+\Delta y \right )</script><p>上述公式可以推广到任意维度的向量</p><script type="math/tex; mode=display">\left ( \Delta x_{1},\Delta x_{2},……,\Delta x_{n}  \right ) =-\eta\left ( \frac{\partial f}{\partial x_{1}}, \frac{\partial f}{\partial x_{2}},……,\frac{\partial f}{\partial x_{n}} \right )</script><p>哈密顿算子</p><p>在实际的神经网络中，主要处理由成千上万个变量构成的函数的最小值。在这种情况下，梯度向量的表达会变得十分冗长，需要用更简洁的表示方法。在数学中，有一个被称为向量分析的领域，其中有一个经常用到的符号，称为哈密顿算子，其定义如下：</p><script type="math/tex; mode=display">\nabla f=\left ( \frac{\partial f}{\partial x_{1}}, \frac{\partial f}{\partial x_{2}},……,\frac{\partial f}{\partial x_{n}} \right )\bigtriangledown 为哈密顿算子</script><script type="math/tex; mode=display">\left ( \Delta x_{1},\Delta x_{2},……,\Delta x_{n}  \right ) =-\eta\bigtriangledown f</script><p>η的含义以及梯度下降法的要点</p><p>到目前为止，η只是简单地表示正的微小常数。而在实际使用计算机进行计算时，如何恰当的确定这个η是个大问题。从前面的式子易知，η是在函数上移动的步长，根据η的值，可以确定下一步移动到那个点，如果步长会较大，那么可能会达到最小值点，也可能会直接跨过了最小值点（左）。而如果步长较小，则可能会滞留在极小值点（右）</p><p><img src="梯度下降法η值的确定.png" alt=""></p><p>在神经网络中，<strong>η称为学习率</strong>。遗憾的是，它的确定方法没有明确的标准，只能通过反复更改来寻找恰当的值。</p><h1 id="最优化问题与回归分析"><a href="#最优化问题与回归分析" class="headerlink" title="最优化问题与回归分析"></a>最优化问题与回归分析</h1><p>在为了分析数据而建立数学模型时，模型是由参数确定的。在数学世界中，最优化问题就是如何确定这些参数。</p><p>从数学上来说，确定神经网络的参数是一个最优化问题，具体是对神经网络的参数（权重和偏置）进行<strong>拟合</strong>，使得神经网络的输出与实际数据相吻合。</p><p>Tips：</p><p>形象的说，拟合就是把平面上一系列的点，用一条光滑的曲线连接起来。因为这条曲线有无数种可能，从而有各种拟合方法。拟合的曲线一般可以用函数表示，根据这个函数的不同有不同的拟合名字。</p><p>为了理解最优化问题，最浅显的例子就是回归分析。</p><h2 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h2><p>在由多个变量组成的数据中，着眼于其中一个特定的变量，用其余的变量来解释这个特定的变量，这样的方法称为回归分析。回归分析的种类有很多，其中最简单的就是一元线性回归分析。</p><p><img src="一元线性回归.png" alt=""></p><script type="math/tex; mode=display">y=px+q(p、q为常数)</script><p>x是自变量，y为因变量，常数p、q是这个回归分析模型的参数，由给出的数据来决定。（p称为回归系数，q为截距）</p><p>下面我们通过具体的例子来看看回归方程是如何确定的。</p><p>下面是一组身高与体重数据，根据这些数据求以体重y为因变量，身高x为自变量的回归方程y=px+q（p、q为常数）。</p><div class="table-container"><table><thead><tr><th>编号</th><th>身高x</th><th>体重y</th><th>预测值p+q</th></tr></thead><tbody><tr><td>1</td><td>153.3</td><td>45.5</td><td>153.3p+q</td></tr><tr><td>2</td><td>164.9</td><td>56.0</td><td>164.9p+q</td></tr><tr><td>3</td><td>168.1</td><td>55.0</td><td>168.1p+q</td></tr><tr><td>4</td><td>151.5</td><td>52.8</td><td>151.5p+q</td></tr><tr><td>5</td><td>157.8</td><td>55.6</td><td>157.8p+q</td></tr><tr><td>6</td><td>156.7</td><td>50.8</td><td>156.7p+q</td></tr><tr><td>7</td><td>161.1</td><td>56.4</td><td>161.1p+q</td></tr></tbody></table></div><p>y的实测值与预测值。在考虑数学上的最优化问题时，理解实测值与预测值的差异是十分重要的。</p><script type="math/tex; mode=display">e_{k}=y_{k}-(px_{k}+q) //实际体重y_{k}预测值的误差e_{k},可正可负\\C_{k}= \frac{1}{2} (e_{k})^2=\frac{1}{2}\left \{ y_{k}-(px_{k}+q)^2 \right \} //平方误差\\C_{T}=C_{1}+C_{2}+……+C_{n}//总误差和\\</script><p>我们的目标是确定常数p、q的值。回归分析任务p、q是使总误差和最小的解。知道这个思路后解题就很简单了。即</p><script type="math/tex; mode=display">\frac{\partial C_{T}}{\partial p}=0,\frac{\partial C_{T}}{\partial q}=0</script><p><img src="一元线性回归2.png" alt=""></p><p>以上就是一元线性回归分析中使用的回归直线的确定方法，这里的重点是最优化问题的求解思路。这里所考察的最优化方法在神经网络计算中也可以直接使用。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在最优化方面，误差综合可以称为误差函数、随时函数、代价函数等。这里采用代价函数（cost function）叫法。因为误差函数（error function）和损失函数（loss function）的首字母容易与神经网络中用到的熵（entropy）、层（layer）的首字母混淆。</p><p>此外，除了这里所说的平方误差的综合之外，根据不同的思路，代价函数还存在其他多种形式。利用平方误差的总和进行最优化的方法称为最小二乘法，目前就让我们先只考虑将平方误差综合作为代价函数。</p><h1 id="神经网络的最优化"><a href="#神经网络的最优化" class="headerlink" title="神经网络的最优化"></a>神经网络的最优化</h1><p>前面我们已经初步了解了神经网络的思想和工作原理。不过，要在数学上实际地确定其权重和偏置，必须将神经网络的思想用具体的式子表示出来。</p><h2 id="参数和变量"><a href="#参数和变量" class="headerlink" title="参数和变量"></a>参数和变量</h2><p>从数学上看，神经网络是一种用于数据分析的模型，这个模型是由权重和偏置确定的。相权重和偏置这种确定数学模型的常熟称为模型的参数。</p><p>除了参数以外，数据分析的模型还需要根据数据而变化的变量，但是参数和变量都用拉丁字母或希腊字母标记，这回引起混乱。而区分用于代入数据值的变量和用于确定模型的参数，对于逻辑的理解是不可或缺的。</p><p>在实际进行神经网络的计算时，往往会倍数量庞大的参数和变量所困扰。构成神经网络的神经单元的数量非常大，相应地表示偏置、权重、输入、输出的变量的数目也变得非常庞大。因此，参数和变量的表示需要统一标准（之前的表示方法都没有考虑统一性）。</p><p>下面我们来确认神经网络中变量和参数的表示方法。</p><p>首先，我们对层进行编号，如下图，最左边的输入层为层1，隐藏层为层2、层3……最右边的输出层为层l（l指的是last，表示层的总数）。</p><p><img src="阶层型神经网络各层的名称.png" alt=""></p><script type="math/tex; mode=display">\begin{aligned}&x_{i}:表示输入层(层1)的第i个神经单元的输入变量。由于输入层的神经单元的输入和输出为同一值，所以也是表示输出的变量。此外，这个\\&\qquad变量名也作为神经单元的名称使用\\&w_{ji}^{l}:从层l-1的第i个神经元指向层l的第j个神经元的箭头的权重。请注意i和j的顺序。这是神经网络的参数\\&z_{j}^{l}:表示层l的第j个神经元的输入变量\\&b_{j}^{l}:层l的第j个神经元的偏置。这是神经网络参数\\&a_{j}^{l}:层i的第j个神经元的输出变量。此外，这个变量名也作为神经单元的名称使用。\end{aligned}</script><p><img src="参数与变量的表示方法.png" alt=""></p><h2 id="学习数据和正解"><a href="#学习数据和正解" class="headerlink" title="学习数据和正解"></a>学习数据和正解</h2><p>利用事先准备好的数据（学习数据）来确定权重和偏置。这在神经网络中称为学习。学习的逻辑非常简单，使神经网络算出的预测值与学习数据的正解的总体误差达到最小即可。</p><h1 id="神经网络的和误差反向传播法"><a href="#神经网络的和误差反向传播法" class="headerlink" title="神经网络的和误差反向传播法"></a>神经网络的和误差反向传播法</h1><p>沿着最陡的坡度下山，就能以最少的部署到达山脚。梯度下降法就是将这个原理哟应用在数学上的数值分析方法。未来求出梯度的方向，需要进行求导，但在神经网络中，倒数计算的计算量非常大。误差反向传播法就解决了这个难题。</p><p>求函数最小值的通用方法中，最有名的就是利用最小值条件（导数为值0）。</p><script type="math/tex; mode=display">z=f(x,y)\Longrightarrow \frac{\partial f}{\partial y} =0,\frac{\partial f}{\partial x}=0</script><p>在神经网络中，代价函数就相当于f，权重和偏置相当于变量x、y。权重和偏置的总数十分庞大，而且代价函数中包含了激活函数，所以求解这样的方程是十分困难的。</p><p>例题：</p><p>已知一个用于识别通过4×3像素的图像读取的手写数字0、1的神经网络，其代价函数为 G 。尝试进行求代价函数最小值的计算。学习用的图像数据为64张图像，像素为单色二值。<br>前面已经考察过，我们可以建立如下图所示的神经网 作为这个例题的解。<br>注：神经单元名使用的是输出变量名。</p><p><img src="神经网络例题.png" alt=""></p><p>第一层与第二层之间有12X3=36个权重和3个偏置，第二层与第三层之间有6个权重和2个偏置，<strong>此神经网络共有47个参数</strong>。</p><p>列出这个神经网络的关系是，其中激活函数为a(z)。</p><p><img src="神经网络例题2.jpg" alt=""></p><p>此外，神经网络计算出的预测值（a）与学习数据的正解（t）的平方误差C如下所示：</p><script type="math/tex; mode=display">C=\frac{1}{2}\left \{ (t_{1}-a_{1}^{3} )^2 + (t_{2}-a_{2}^{3}) \right \}</script><p><strong>将n个实例输入到这个神经网络中，得到代价函数，现在的主角就是这个代价函数。</strong></p><script type="math/tex; mode=display">C_{T}=C_{1}+C_{2}+……+C_{n}</script><p><img src="神经网络例题3.jpg" alt=""></p><p>已知该神经网络要确定的参数共有47个，想要通过求偏导零点来确定参数就需要47个方程。</p><p><img src="神经网络例题4.png" alt=""></p><p>求解这些方程是极其困难的，于是梯度下降法应运而生。</p><p>把函数图像看作斜坡，沿着坡度最陡的方向一步一步地下降，将这个想法在数学上表示出来，就是梯度下降法。</p><script type="math/tex; mode=display">x_{1}+\Delta x_{1},x_{2}+\Delta x_{2},……,x_{n}+\Delta x_{n}</script><p>当以下关系式成立时，函数f减小得最快。η为正的微小常数</p><script type="math/tex; mode=display">\left ( \Delta x_{1},\Delta x_{2},……,\Delta x_{n}  \right ) =-\eta\left ( \frac{\partial f}{\partial x_{1}}, \frac{\partial f}{\partial x_{2}},……,\frac{\partial f}{\partial x_{n}} \right )</script><p>我们试着将上式应用到上面展示的神经网络中</p><script type="math/tex; mode=display">(\Delta w_{11}^{2},…,\Delta w_{11}^{3},…,\Delta b_{1}^{2},…,\Delta b_{1}^{3},…)=-\eta (\frac{\partial C_{T}}{\partial w_{11}^{2}},…,\frac{\partial C_{T}}{\partial w_{11}^{3}} ,...,\frac{\partial C_{T}}{\partial b_{1}^{2}},...,\frac{\partial C_{T}}{\partial b_{1}^{3}},...)</script><p>用计算机计算这个梯度的分量使十分麻烦的。仅计算一张图像的平方误差对一个参数的偏导就要进行如下计算：</p><script type="math/tex; mode=display">\frac{\partial C_{k}}{\partial w_{11}^{2}} =\frac{\partial C_{k}}{\partial a_{1}^{3}[k]} \frac{\partial a_{1}^{3}[k]}{\partial z_{1}^{3}[k]} \frac{\partial z_{1}^{3}[k]}{\partial a_{1}^{2}[k]} \frac{\partial a_{1}^{2}[k]}{\partial z_{1}^{2}[k]} \frac{\partial z_{1}^{2}[k]}{\partial w_{11}^{2}[k]}+ \\\frac{\partial C_{k}}{\partial a_{2}^{3}[k]} \frac{\partial a_{2}^{3}[k]}{\partial z_{2}^{3}[k]} \frac{\partial z_{2}^{3}[k]}{\partial a_{1}^{2}[k]} \frac{\partial a_{1}^{2}[k]}{\partial z_{2}^{2}[k]} \frac{\partial z_{1}^{2}[k]}{\partial w_{11}^{2}[k]}</script><p><img src="神经网络例题5.jpg" alt=""></p><p>若学习数据有64张图，则仅对一个参数求偏导就要将上面的过程还要再重复64次。</p><p><img src="神经网络例题6.png" alt=""></p><p>由此我们可以知道，用具体的式子来求梯度分量是非常困难的。未来解决这个问题，人们研究出了误差反向传播法。</p><p>通过上面的计算，我们了解到：梯度分量是一个个学习实例的简单和。也就是说，<strong>代价函数的偏导数是从各个学习实例中得到的偏导数的和。</strong></p><h2 id="神经元误差"><a href="#神经元误差" class="headerlink" title="神经元误差"></a>神经元误差</h2><p>梯度下降法对于寻找多变量函数的最小值的问题是有效的。然而在神经网络中，变量、参数和函数错综复杂，无法直接使用梯度下降法，于是出现了误差反向传播法。</p><p>误差反向传播法的特点是将繁杂的导数计算替换成数列的递推关系式，而提供这些递推关系式的就是名为神经单元误差（error）的变量。利用平方误差C，其定义如下所示：</p><script type="math/tex; mode=display">\delta_{j}^{l}=\frac{\partial C}{\partial z_{j}^{l}}</script><p>虽然神经单元误差和平方误差同为误差，但它们的含义却不一样。</p><p><img src="误差反向传播法.jpg" alt=""></p><script type="math/tex; mode=display">用\delta_{j}^{i}来表示\frac{\partial C}{\partial w_{11}^{3}} :\\\frac{\partial C}{\partial w_{11}^{3}}=\frac{\partial C}{\partial z_{11}^{3}}\frac{\partial z_{11}^{3}}{\partial w_{11}^{3}}\\z_{1}=w_{11}^{3}a_{1}^{2}+w_{12}^{3}a_{2}^{2}+w_{13}^{3}a_{3}^{2}\\\frac{\partial z_{1}^{3}}{\partial w_{11}^{3}}=a_{1}^{2}\\\frac{\partial C}{\partial w_{11}^{3}}=\delta_{1}^{3}a_{1}^{2}</script><p><img src="误差反向传播法2.png" alt=""></p><p>通过同样计算我们可以算出：</p><script type="math/tex; mode=display">\frac{\partial C}{\partial b_{1}^{2}}=\frac{\partial C}{\partial z_{1}^{2}}=\delta_{1}^{2}</script><p>我们可以得到如下的一般式：</p><script type="math/tex; mode=display">\frac{\partial C}{\partial w_{ji}^{l}}=\delta_{j}^{l}a_{i}^{l-1},\frac{\partial C}{\partial b_{j}^{l}}=\delta_{j}^{l}</script><h2 id="误差反向传播算法"><a href="#误差反向传播算法" class="headerlink" title="误差反向传播算法"></a>误差反向传播算法</h2><p>如果我们能得到神经单元误差，就可以得到作为梯度下降法基础的平方误差的偏导数。那么如何求神经单元误差呢？这里我们利用数学中的数列递推关系式思想。</p><p>数列为数的序列，其第一项为首相，最后一项为末项。有趣的是，将神经单元误差看作数列是，可以简单地求出它的“末项”。</p><p>现在我们考虑的例子中，神经网络的层数为3，因此我们试着计算数列末项的误差，以a(z)为激活函数，根据链式法则有：</p><script type="math/tex; mode=display">\delta_{j}^{3}=\frac{\partial C}{\partial z_{j}^{3}}=\frac{\partial C}{\partial a_{j}^{3}}\frac{\partial a_{j}^{3}}{\partial z_{j}^{3}}=\frac{\partial C}{\partial a_{j}^{3}}{a}'(z_{j}^{3})</script><p>像这样，如果给出平方误差C和激活函数，就可以具体地求出相当于“末项”的输出层神经误差。以L作为输出层的编号，将上面的式子一般化，如下所示：</p><script type="math/tex; mode=display">\delta_{j}^{L}=\frac{\partial C}{\partial a_{j}^{L}}{a}'(z_{j}^{L})</script><h3 id="中间层的“反向”递推关系式"><a href="#中间层的“反向”递推关系式" class="headerlink" title="中间层的“反向”递推关系式"></a>中间层的“反向”递推关系式</h3><p>神经元误差具有非常好的性质。它通过简单的关系式与下一层的神经元误差联系起来.</p><script type="math/tex; mode=display">\delta_{1}^{2}=\frac{\partial C}{\partial z_{1}^{2}}=\frac{\partial C}{\partial z_{1}^{3}}\frac{\partial z_{1}^{3}}{\partial a_{1}^{2}}\frac{\partial a_{1}^{2}}{\partial z_{1}^{2}}+\frac{\partial C}{\partial z_{2}^{3}}\frac{\partial z_{2}^{3}}{\partial a_{1}^{2}}\frac{\partial a_{1}^{2}}{\partial z_{1}^{2}}\\\frac{\partial C}{\partial z_{1}^{3}}=\delta_{1}^{3},\frac{\partial C}{\partial z_{2}^{3}}=\delta_{2}^{3} \\\frac{\partial z_{1}^{3}}{\partial a_{1}^{2}}=w_{11}^{3},\frac{\partial z_{2}^{3}}{\partial a_{1}^{2}}=w_{21}^{3}\\\frac{\partial a_{1}^{2}}{\partial z_{1}^{2}}={a}'(z_{1}^{2})\\\delta_{1}^{2}=\delta_{1}^{3}w_{11}^{3}{a}'(z_{1}^{2})+\delta_{2}^{3}w_{21}^{2}{a}'(z_{1}^{2})\\\delta_{1}^{2}=(\delta_{1}^{3}w_{11}^{3}+\delta_{2}^{3}w_{21}^{3}){a}'(z_{1}^{2})</script><p><img src="误差反向传播法3.png" style="zoom: 50%;"></p><p>由此我们可以得出当前层与下一层的一般关系式：</p><script type="math/tex; mode=display">\delta_{i}^{l}=(\delta_{1}^{l+1}w_{li}^{l+1}+\delta_{2}^{l+1}w_{2i}^{l+1}+…+\delta_{m}^{l+1}w_{mi}^{l+1}){a}'(z)\\m为层l+1的神经单元个数，l为2以上的整数</script><p>这样我们就可以从输出层开始反向求出各层的神经元误差，进而求出代价函数对权重和偏置的偏导。</p><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><p>建立一个6x6像素的图像读取数字1、2、3.图像的像素值为单色二值。</p><p>图中用圆圈将变量名圈起来的就是神经元，从图中我们可以了解到卷积神经网络的特点。隐藏层由多个具有结构的层组成。具体来说，<strong>隐藏层是由多个卷积层和池化层组成的</strong>。它不仅深，而且含有内置结构。卷积层的英文是convolution layer。这里展示的是最简单的卷积神经网络。</p><p><img src="卷积神经网络.png" style="zoom: 67%;"></p><p>我们设置一些过滤器，也就是图中的小恶魔，它们有自己对应的偏好模式，会对特定的模式的神经元起反应，而且它是活跃的，会积极地从图像中找出偏好模式。</p><p>为了让这些过滤器能够活动，我们为其提供工作场所，那就是由卷积层和池化层构成的隐藏子层。我们为每个过滤器准备一个隐藏子层作为工作场所。</p><p><img src="卷积神经网络(2).png" style="zoom:67%;"></p><p>活跃的过滤器积极地扫描图像，检查图像中是否含有自己偏好的模式。如果图像中含有较多偏好的模式，过滤器就起反应，反之就不起反应。此外，由于偏好的模式的大小比整个图像小，所以兴奋度被记录在多个神经单元中。</p><p><img src="卷积神经网络(3).png" style="zoom:50%;"></p><p><img src="卷积神经网络(4" alt="">.png)</p><p>注：一般用于扫描的过滤器大小是5x5。这里为了使结果变简单，我们使用3x3大小。</p><p>活跃的过滤器进一步整理自己的兴奋度，将兴奋度集中起来，整理后形成了池化层。</p><p><img src="卷积神经网络(5).png" style="zoom:50%;"></p><p>因此池化层的神经元中浓缩了作为考察对象的图像中包含了多少过滤器所偏好的模式这一信息。</p><p>要识别1、2、3，就需要让多个小恶魔登场。这里我们比较随意地假定有3个过滤器，输出层将这3个过滤器的报告组合起来，得出整个神经网络的判定结果。</p><p><img src="卷积神经网络(6).png" style="zoom:50%;"></p><p>与前面学的神经网络不同，这里的过滤器是动态的，它们会积极扫描图像，整理兴奋度并向下一层汇报。由于这些特点，卷积神经网络有我们前面学习的简单神经网络所没有的确定。</p><ul><li>对于复杂的模式识别问题，也可以用简洁的网络来处理。</li><li>整体而言，因为神经单元的数量少了，使用计算比较轻松。</li></ul><h2 id="过滤器的数量"><a href="#过滤器的数量" class="headerlink" title="过滤器的数量"></a>过滤器的数量</h2><p>过滤器的数量是不确定的，如果我们预估用5个模式能过区分图像，那么就需要有5个过滤器。这样一来，我们就应当准备好5个由卷积层和池化层形成的隐藏子层。</p><p><img src="卷积神经网络过滤器数量.png" style="zoom: 33%;"></p><p>而且，在识别复杂图像的情况下，隐藏层的结构本身也需要变得更复杂。这就需要设计人员大展身手了。</p><h2 id="过滤器的工作过程"><a href="#过滤器的工作过程" class="headerlink" title="过滤器的工作过程"></a>过滤器的工作过程</h2><p>我们来观察一个过滤器的工作，假设过滤器偏好模式如下：</p><p><img src="卷积_偏好模式.png" style="zoom: 25%;"></p><p>假设下面的图像“2”就是要考察的图像，我们将手写数字2作为它的正解。</p><p><img src="卷积_数字识别.png" style="zoom: 25%;"></p><p>首先过滤器对图像进行扫描。</p><p><img src="卷积_过滤器扫描.jpg" style="zoom: 33%;"></p><p>各个图像下面的“相似度”表示过滤器的灰色各自部分与扫描图像块的灰色各自部分吻合的地方的个数。这个值越大，就说明越符合过滤器的偏好模式。（这个是像素为二值0或1时的情况，更一般的情况后面再讨论）</p><p>我们将这个相似度汇总一下，如下所示，就是根据过滤器得到的卷积（convolution）的结果，称为特征映射（feature map）。</p><p><img src="卷积_特征映射.png" style="zoom:25%;"></p><p>这样的过滤器计算称为卷积。</p><p>卷积层中的神经单元将这一卷积的结果作为输入信息。个神经单元将对应的卷积值加上特征映射固有的偏置作为加权输入。</p><p><img src="卷积_加权输入.png" style="zoom: 50%;"></p><p>卷积层的各个神经单元通过激活函数来处理加权输入，并将处理结果作为神经单元的输出。这样卷积层的处理就完成了。</p><p><img src="卷积_输入处理.png" style="zoom:33%;"></p><h2 id="通过池化进行信息压缩"><a href="#通过池化进行信息压缩" class="headerlink" title="通过池化进行信息压缩"></a>通过池化进行信息压缩</h2><p>再实际图像情况下，卷积层神经单元的数目还是十分庞大的。因此需要进行信息压缩操作，然后将压缩结果放进池化层的神经单元中。</p><p>压缩的方法十分简单，只需要将卷积神经单元划分为相等大小不重叠的区域，然后在各区域中计算出代表值即可。这里我们使用最有名的信息压缩方法——最大池化（max polling），就是将划分好的各区域的最大值提取出来。</p><p><img src="卷积_最大池化.png" style="zoom: 33%;"></p><p>这样一来，一张图像的信息，就被集中在紧凑的神经单元集合中了。</p><p><img src="卷积_池化(2).png" style="zoom:33%;"></p><p><img src="卷积_池化(3).png" style="zoom:33%;"></p><p>如果一个过滤器的池化层神经单元的输出值较大，就表示原始图像中包含较多该过滤器的模式。</p><h2 id="卷积神经网络的变量关系式"><a href="#卷积神经网络的变量关系式" class="headerlink" title="卷积神经网络的变量关系式"></a>卷积神经网络的变量关系式</h2><p>前面我们初步了解了过滤器工作的数学思路，下面我们用数学式子表示出来。</p><h3 id="确定各层的含义以及变量明、参数名"><a href="#确定各层的含义以及变量明、参数名" class="headerlink" title="确定各层的含义以及变量明、参数名"></a>确定各层的含义以及变量明、参数名</h3><p>还是前面的那个神经网络，我们先总览一下这个网络：</p><p><img src="卷积神经网络总览.jpg" alt=""></p><p>我们把确定这个卷积神经网络所需的变量、参数的符号及其含义魂宗在下表中：</p><div class="table-container"><table><thead><tr><th>位置</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>输入层</td><td>$x_{ij}$</td><td>神经单元中输入的图像像素（i行j列)的值。与输出值相同</td></tr><tr><td>过滤器</td><td>$w_{ij}^{Fk}$</td><td>用于建立第k个特征映射的过滤器的i行j列的值</td></tr><tr><td>卷积层</td><td>$z_{ij}^{Fk}$</td><td>卷积层第k个子层的i行j列的神经单元的加权输入</td></tr><tr><td></td><td>$b^{Fk}$</td><td>卷积层第k个子层的i行j列的神经单元的偏置。注意这些偏置在同一层各特征映射中是相同的</td></tr><tr><td></td><td>$a_{ij}^{Fk}$</td><td>卷积层第k个子层的i行j列的神经单元的输出（激活函数的值）</td></tr><tr><td>池化层</td><td>$z_{ij}^{Pk}$</td><td>池化层第k个子层的i行j列的神经单元输入。通常是前一层输出值的非线性函数值</td></tr><tr><td></td><td>$a_{ij}^{Pk}$</td><td>池化层第k个子层的i行j列的神经单元的输出。与输入值$z_{ij}^{Pk}$一致</td></tr><tr><td>输出层</td><td>$w_{k-ij}^{On}$</td><td>从池化层第k个子层的i行j列的神经单元指向输出层第n个神经单元的箭头的权重</td></tr><tr><td></td><td>$z_n^o$</td><td>输出层第n个神经单元的加权输入</td></tr><tr><td></td><td>$b_n^o$</td><td>输出层第n个神经单元的偏置</td></tr><tr><td></td><td>$a_n^o$</td><td>输出层第n个神经单元的输出（激活函数的值）</td></tr><tr><td>学习数据</td><td>$t_n$</td><td>正解为1时，$t_1$=1，$t_2$=0，$t_3$=0 <br>正解为2时，$t_1$=0，$t_2$=1，$t_3$=0 <br>正解为3时，$t_1$=0，$t_2$=0，$t_3$=1</td></tr></tbody></table></div><p><img src="卷积神经网络流程.jpg" alt=""></p><p>与神经网络不同的是，卷积神经网络中考虑的参数增加了过滤器这个新的成分。</p><h3 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h3><p>在输入层的神经单元中，输入值与输出值相同，有：</p><script type="math/tex; mode=display">a_{ij}^I=x_{ij}</script><h3 id="过滤层和卷积层"><a href="#过滤层和卷积层" class="headerlink" title="过滤层和卷积层"></a>过滤层和卷积层</h3><p>由于过滤器的数值是通过对学习数据进行学习确定的，所以它们是模型的参数。<strong>过滤器（Filter）也称为核（Kernel）</strong></p><p><img src="卷积_过滤器计算.png" alt=""></p><p>由此可以求出卷积值：</p><script type="math/tex; mode=display">c_{ij}^{Fk}=w_{11}^{Fk}x_{ij}+w_{12}^{Fk}x_{ij+1}+w_{13}^{Fk}x_{ij+2}+…+w_{33}^{Fk}x_{i+2\thinspace j+2}</script><p>这样得到的数值集合就形成特征映射。我们给这些卷积值加上一个不依赖预备$i、j$的输$b^{Fk}$</p><script type="math/tex; mode=display">z_{ij}^{Fk}=c_{ij}^{Fk}+b^{Fk}</script><p><img src="卷积_加权输入计算.png" alt=""></p><p>考虑以$z_{ij}^{Fk}$作为加权输入的神经单元，这中神经单元的集合形成卷积层的一个子层。$b^{Fk}$为卷积层共同的偏置。</p><p>激活函数为$a(z)$，对于加权输入$z<em>{ij}^{Fk}$，神经单元的输入$a</em>{ij}^{Fk}$可以如下表示：</p><script type="math/tex; mode=display">a_{ij}^{Fk}=a(z_{ij}^{Fk})</script><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>卷积神经网络中设置有用于压缩卷积层信息的池化层，在很多文献中，将特征有映射的2x2（不一定是2x2）个神经元压缩为1个神经元。通过一次池化操作，特征映射的神经元数就缩减到来原先的1/4。</p><p><img src="卷积_池化(4).png" style="zoom:33%;"></p><p>比较有名的是最大池化法。</p><p><img src="卷积_最大池化(2).png" style="zoom:33%;"></p><p>从神经网络观点来看，池化层也是神经单元的集合。不过，从计算方法可知，这些神经单元在数学上是非常简单的。通常的神经单元是从前一层的神经单元接收甲醛输入，儿池化层的神经单元不存在权重和偏置概念，也就是不具有模型参数。此外，由于输入和输出的值相同，所以也不存在激活函数的概念、从数学上说，激活函数$a(x)$可以认为是恒等式$a(x)=x$。这个特性和输出层的神经单元相似。</p><p><img src="卷积_池化层神经单元.png" style="zoom:33%;"></p><p>以上讨论的池化层性质可以用式子如下表示。k是子层编号，i、j为整数，取值必须使它们指定的参数有意义。</p><script type="math/tex; mode=display">\left\{\begin{matrix}z_{ij}^k=Max(a_{2i-1\thinspace 2j-1}^{Pk},a_{2i-1\thinspace 2j}^{Pk},a_{2i\thinspace 2j-1}^{Pk},a_{2i\thinspace 2j}^{Pk},)\hfil\\a_{ij}^{Pk}=z_{ij}^{Pk}\hfil\end{matrix}\right.</script><p><img src="卷积_池化层计算.png" style="zoom:33%;"></p><h3 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h3><p> 输出层中的神经元接收来自池化层的说有神经单元的箭头（全连接）。这样就可以综合地考察池化层的神经单元的信息。</p><p> <img src="卷积_输出层.png" style="zoom: 33%;"></p><p>上图可以用下面的式子来表示：</p><script type="math/tex; mode=display">z_n^O=w_{1-11}^{On}a_{11}^{P1}+w_{1-12}^{On}a_{12}^{P1}+…+w_{2-11}^{On}a_{11}^{P2}+w_{2-12}^{On}a_{12}^{P2}+…+w_{3-11}^{On}a_{11}^{P3}+w_{3-12}^{On}a_{12}^{P3}+…+b_n^o</script><p>这里的系数$w<em>{k-ij}^{On}$为输出层第n个神经单元给池化层十九点的输出$a</em>{ij}^{Pk}(k=1,2,3;i=1,2;j=1,2)$分配的权重，$b_n^o$为输出层第$n$个神经单元的偏置。</p><p>我们具体写出$z_1^O$的式子：</p><script type="math/tex; mode=display">z_1^O=w_{1-11}^{O1}a_{11}^{P1}+w_{1-12}^{O1}a_{12}^{P1}+…+w_{2-11}^{O1}a_{11}^{P2}+w_{2-12}^{O1}a_{12}^{P2}+…+w_{3-11}^{O1}a_{11}^{P3}+w_{3-12}^{O1}a_{12}^{P3}+…+b_1^O</script><p><img src="卷积_输出层(2).png" style="zoom:33%;"></p><p>接下来考虑输出层神经单元的输出，它们形成了整个神经网络的输出。输出层的第n个神经单元的输出值为$a_n^O$，激活函数为$a(z)$，则：</p><script type="math/tex; mode=display">a_n^O=a(z_n^O)</script><h3 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h3><p>现在我们考虑的神经网络中，输出层神经单元的3个输出为$a_1^O、a_2^O、a_3^O$，对应的学习数据正解分别为$t_1、t_2、t_3$。于是，平方误差C可以如下表示。</p><script type="math/tex; mode=display">C=\frac{1}{2}(t_1-a_1^O)^2+(t_2-a_2^O)^2+(t_3-a_3^O)^2</script><p>注：系数$\frac{1}{2}$是为了简洁倒数计算，这个$\frac{1}{2}$会在求导的过程中被约掉，不同的文献可能会使用不同的系数，这个系数对结论没有影响。</p><p><img src="卷积_代价函数.png" style="zoom:33%;"></p><p>将输入第k个图像时的平方误差的值记为$C_k$，如下所示：</p><script type="math/tex; mode=display">C_k=\frac{1}{2}(t_1[k]-a_1^O[k])^2+(t_2[k]-a_2^O[k])^2+(t_3[k]-a_3^O[k])^2</script><p>全体学习数据的平方误差的总和就是代价函数$C_T$。</p><script type="math/tex; mode=display">C_T=C_1+C_2+…+C_n</script><p>由此我们得到了作为计算主角的代价函数$C_T$。接下来的目标就是求得使代价函数达到最小值的权重和偏置。</p><h3 id="其他池化方法"><a href="#其他池化方法" class="headerlink" title="其他池化方法"></a>其他池化方法</h3><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>最大池化</td><td>使用对象区域的最大值作为代表值的压缩方法</td></tr><tr><td>平均池化</td><td>使用对象区域的平均值作为代表值的压缩方法</td></tr><tr><td>L2池化</td><td>例如，对于4个神经单元的输出值$a_1、a_2、a_3、a_4$，使用$\sqrt{a_1^2+a_2^2+a_3^2+a_4^2}$作为代表值的压缩方法</td></tr></tbody></table></div><h1 id="卷积神经网络和误差反向传播法"><a href="#卷积神经网络和误差反向传播法" class="headerlink" title="卷积神经网络和误差反向传播法"></a>卷积神经网络和误差反向传播法</h1>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
