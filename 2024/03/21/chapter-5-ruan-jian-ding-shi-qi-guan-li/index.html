<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Chapter 5 软件定时器管理, Koito Yuu&#39;s Blogs">
    <meta name="description" content="Chapter 5 软件定时器管理章节介绍和范围软件定时器用于安排函数在设定的未来时间点执行，或者以固定频率定期执行。 软件定时器执行的函数称为软件定时器的回调函数。
软件定时器由 FreeRTOS 内核实现，并受 FreeRTOS内核 的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Chapter 5 软件定时器管理 | Koito Yuu&#39;s Blogs</title>
    <link rel="icon" type="image/png" href="/Blogs/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/Blogs/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/matery.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/my.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/Blogs/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/Blogs/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/Blogs/css/reward.css">
    



    <script src="/Blogs/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/Blogs/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/Blogs/" class="waves-effect waves-light">
                    
                    <img src="/Blogs/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Koito Yuu&#39;s Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/Blogs/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Koito Yuu&#39;s Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/Blogs/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Chapter 5 软件定时器管理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/Blogs/categories/FreeRTOS/" class="post-category">
                                FreeRTOS
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-03-21
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Chapter-5-软件定时器管理"><a href="#Chapter-5-软件定时器管理" class="headerlink" title="Chapter 5 软件定时器管理"></a>Chapter 5 软件定时器管理</h1><h2 id="章节介绍和范围"><a href="#章节介绍和范围" class="headerlink" title="章节介绍和范围"></a>章节介绍和范围</h2><p>软件定时器用于安排函数在设定的未来时间点执行，或者以固定频率定期执行。 软件定时器执行的函数称为软件定时器的回调函数。</p>
<p>软件定时器由 FreeRTOS 内核实现，并受 FreeRTOS内核 的控制。它们不需要硬件支持，也与硬件定时器或硬件计数器无关。</p>
<p>请注意，根据 FreeRTOS 使用创新设计以确保最高效率的理念，软件定时器不会使用任何处理时间，除非实际执行软件定时器回调函数。</p>
<p>软件定时器功能是可选的。要包含软件定时器功能，请执行以下操作:</p>
<ol>
<li>将FreeRTOS源文件 <code>FreeRTOS/Source/timers.c</code> 构建为项目的一部分 </li>
<li>在 <code>FreeRTOSConfig.h</code> 中将<code>configUSE_TIMERS</code>设置为1。</li>
</ol>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h3><p>本章旨在让读者更好地了解以下内容：</p>
<ul>
<li>软件定时器的特性与任务特性的比较。</li>
<li>RTOS 守护进程任务。</li>
<li>定时器命令队列。</li>
<li>一次性软件定时器和周期性软件定时器之间的区别。</li>
<li>如何创建、启动、重置和更改软件定时器的周期。</li>
</ul>
<h2 id="软件定时器回调函数"><a href="#软件定时器回调函数" class="headerlink" title="软件定时器回调函数"></a>软件定时器回调函数</h2><p>软件定时器回调函数被实现为 C 函数。它们唯一的特别之处是它们的原型，它必须返回void，并将软件定时器的句柄作为其唯一的参数。清单 72 演示了回调函数原型。</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 72. 软件定时器回调函数原型</p>
<p>软件定时器回调函数自始至终执行，并以正常方式退出。它们应该保持简短，并且不能进入阻塞状态。</p>
<blockquote>
<p>注意：正如将看到的，软件定时器回调函数在启动 FreeRTOS 调度程序时自动创建的任务的上下文中执行。 因此，软件定时器回调函数决不能调用会导致调用任务进入阻塞状态的FreeRTOS API 函数，这一点至关重要。 可以调用 xQueueReceive() 之类的函数，但前提是该函数的 xTicksToWait 参数(指定函数的阻塞时间)设置为 0。 调用 vTaskDelay() 之类的函数是不对的，因为调用vTaskDelay()会始终将调用任务置于阻塞状态。</p>
</blockquote>
<h2 id="软件定时器的属性和状态"><a href="#软件定时器的属性和状态" class="headerlink" title="软件定时器的属性和状态"></a>软件定时器的属性和状态</h2><h3 id="软件定时器的周期"><a href="#软件定时器的周期" class="headerlink" title="软件定时器的周期"></a><strong>软件定时器的周期</strong></h3><p>软件定时器的 <code>‘周期’(period)</code> 是软件定时器启动和软件定时器的回调函数执行之间的时间</p>
<h3 id="一次性定时器和自动重载定时器"><a href="#一次性定时器和自动重载定时器" class="headerlink" title="一次性定时器和自动重载定时器"></a><strong>一次性定时器和自动重载定时器</strong></h3><p>有两种类型的软件定时器：</p>
<ol>
<li><p>一次性定时器 一旦启动</p>
<p>一旦启动，一次性定时器将仅执行一次其回调函数。一次性定时器可以手动重新启动，但不会自行重新启动。</p>
</li>
<li><p>自动重载定时器 </p>
<p>一旦启动，自动重载定时器将在每次到期时重新启动，从而定期执行其回调函数。</p>
</li>
</ol>
<p>图38显示了一次性定时器和自动重载定时器之间的行为差异。虚线垂直线标记滴答中断发生的时间。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330161114285.png" alt="图38一次性软件定时器和自动重载软件定时器之间的行为差异"></p>
<p>参考图38：</p>
<ul>
<li><p>定时器 1 </p>
<p>定时器 1 是具有 6 个滴答长的周期的一次性定时器。它在 t1 时刻启动，因此它的回调函数在6个滴答之后，即 t7 时刻执行。由于定时器 1是一次性定时器，其回调函数不会再次执行。</p>
</li>
<li><p>定时器 2 </p>
<p>定时器 2 是具有 5 个滴答长的周期的自动重载定时器。它在 t1 时刻启动，因此它的回调函数在 t1 时刻之后每5 滴答执行一次。在图38中，这是 t6 、 t11 和 t16 时刻。</p>
</li>
</ul>
<h3 id="软件定时器状态"><a href="#软件定时器状态" class="headerlink" title="软件定时器状态"></a><strong>软件定时器状态</strong></h3><p>软件定时器可以处于以下两种状态之一：</p>
<ul>
<li><p>休眠</p>
<p>休眠的软件定时器存在，并且可以通过其句柄引用，但未运行，因此其回调函数将不会执行。</p>
</li>
<li><p>运行</p>
<p>正在运行的软件定时器将在从软件定时器进入运行状态起或者从软件定时器最后被重置起经过等于其周期的时间之后执行其回调函数。</p>
</li>
</ul>
<p>图39和图40分别显示了自动重载定时器和一次性定时器在休眠状态和运行状态之间的可能的转换。这两个图的关键区别在于定时器到期后进入的状态；自动重载定时器执行其回调函数，然后重新进入运行状态，一次性定时器执行其回调函数，然后进入休眠状态。</p>
<p>xTimerDelete() API 函数的作用是：删除一个定时器。可以随时删除定时器。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240615012641295.png" alt="图 39 自动重载软件定时器状态和转换"></p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330163007600.png" alt="图 40 一次性软件定时器状态和转换"></p>
<h2 id="软件定时器的上下文"><a href="#软件定时器的上下文" class="headerlink" title="软件定时器的上下文"></a>软件定时器的上下文</h2><h3 id="RTOS守护进程-定时器服务-任务"><a href="#RTOS守护进程-定时器服务-任务" class="headerlink" title="RTOS守护进程(定时器服务)任务"></a><strong>RTOS守护进程(定时器服务)任务</strong></h3><p>所有软件定时器回调函数都在同一 RTOS <code>守护进程任务-daemon task</code> (或 <code>“定时器服务任务-timer service task”</code> ) 的上下文中执行[1]。</p>
<blockquote>
<p>[1] 该任务过去被称为 “定时器服务任务” ，因为最初它只用于执行软件定时器回调函数。现在同一任务也用于其他目的，因此它被称为 “RTOS守护进程任务” 的更一般的名称。</p>
<p>daemon : 计算机中的概念，多翻译为守护进程，守护进程是运行在后台的一种特殊进程，它周期性地执行某种任务或循环等待处理某些事件的发生，在不需要时处于休眠状态。</p>
</blockquote>
<p>守护进程任务，是在启动调度程序时，自动创建的标准的 FreeRTOS 任务。其优先级和堆栈大小分别由 <code>configTIMER_TASK_PRIORITY</code> 和 <code>configTIMER_TASK_STACK_DEPTH</code> 编译时配置常量设置。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p>
<p>软件定时器回调函数不得调用会导致调用任务进入阻塞状态的 FreeRTOS API 函数，因为这样做将导致守护进程任务进入阻塞状态。</p>
<h3 id="定时器命令队列"><a href="#定时器命令队列" class="headerlink" title="定时器命令队列"></a><strong>定时器命令队列</strong></h3><p>软件定时器 API 函数将命令从调用任务发送到称为 “定时器命令队列” 的队列上的守护进程任务。这如图 41 所示。命令的示例包括 <code>"start a timer (启动定时器)"</code> 、<code>stop a timer (停止定时器)</code> 和 <code>reset a timer (重置定时器)</code> 。</p>
<p>定时器命令队列是在启动调度程序时自动创建的标准 FreeRTOS 队列。定时器命令队列的长度由 <code>FreeRTOSConfig.h</code> 中的 <code>configTIMER_QUEUE_LENGTH</code> 编译时配置常量设置。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330165153654.png" alt="图 41 软件定时器API函数使用定时器命令队列与RTOS守护进程任务通信"></p>
<h3 id="守护进程任务调度"><a href="#守护进程任务调度" class="headerlink" title="守护进程任务调度"></a><strong>守护进程任务调度</strong></h3><p>守护进程任务与任何其他 FreeRTOS 任务一样进行调度；当守护进程任务是能够运行的最高优先级任务时，它只会处理命令或执行定时器回调函数。图 42 和图 43 演示了 <code>configTIMER_TASK_PRIORITY</code> 设置如何影响执行模式</p>
<p>图 42 显示了当守护进程任务的优先级低于调用 <code>xTimerStart()</code> API 函数的任务的优先级时的执行模式</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240330170229111.png" alt="图 42 调用xTimerStart()的任务的优先级高于守护进程任务的优先级时的执行模式"></p>
<p>参照图 42 ，其中任务1 的优先级高于守护进程任务的优先级，并且守护进程任务的优先级高于空闲任务的优先级：</p>
<ol>
<li>t1 时刻</li>
</ol>
<p>   任务1 处于运行状态，守护进程任务处于阻塞状态。</p>
<p>   如果有命令发送到定时器命令队列，守护进程任务将离开阻塞状态，在这种情况下，它将处理该命令，或者如果软件定时器到期，在这种情况下，它将执行软件定时器的回调函数。</p>
<ol start="2">
<li><p>t2 时刻：</p>
<p>任务1 调用 <code>xTimerStart()</code> 。</p>
<p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。 任务1 的优先级高于守护进程任务的优先级，因此守护进程任务不会抢占任务1 。 </p>
<p>任务1 仍处于运行状态，守护进程任务已离开阻塞状态，进入就绪状态。</p>
</li>
<li><p>t3 时刻：</p>
<p>任务1 完成 <code>xTimerStart()</code> API 函数的执行。</p>
<p>任务1 从头到尾执行完 <code>xTimerStart()</code> ，而不离开运行状态。</p>
</li>
<li><p>t4 时刻：</p>
<p>任务1 调用导致其进入阻塞状态的 API 函数。守护进程任务现在是处于就绪状态的最高优先级任务，因此调度程序选择守护进程任务作为进入运行状态的任务。然后，守护进程任务开始处理任务1 发送到定时器命令队列的命令。 </p>
<p><em>注意：正在启动的软件定时器将到期的时间是从向定时器命令队列发送 “启动定时器” 命令开始计算的，而不是从守护进程任务从定时器命令队列接收到 “启动定时器” 命令的时间计算的。</em></p>
</li>
<li><p>t5 时刻：</p>
<p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。定时器命令队列为空，因此守护进程任务重新进入阻塞状态。如果将命令发送到定时器命令队列，或者如果软件定时器到期，则守护进程任务将再次离开阻塞状态。</p>
<p>空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p>
</li>
</ol>
<p>图 43 显示了类似于图 42 所示的场景，但是这一次守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240331001216768.png" alt="图 43 当调用xTimerStart()的任务的优先级低于守护进程任务的优先级时的执行模式"></p>
<p>参照图 43 ，其中守护进程任务的优先级高于任务1 的优先级，任务1 的优先级高于空闲任务的优先级：</p>
<ol>
<li><p>t1 时刻 </p>
<p>和之前一样，任务1 处于运行状态，守护进程任务处在阻塞状态。 </p>
</li>
<li><p>t2 时刻 </p>
<p>任务1调用 <code>xTimerStart()</code> 。</p>
<p><code>xTimerStart()</code> 向定时器命令队列发送命令，使守护进程任务离开阻塞状态。守护进程任务的优先级高于任务1 的优先级，因此调度器选择守护进程任务作为进入运行状态的任务。</p>
<p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，现在处于就绪状态。守护进程任务开始处理任务1 发送到定时器命令队列的命令。</p>
</li>
<li><p>t3 时刻 </p>
<p>守护进程任务已完成对任务1 发送给它的命令的处理，并尝试从定时器命令队列接收更多数据。 定时器命令队列为空，因此守护进程任务重新进入阻塞状态。</p>
<p>任务1 现在是处于就绪状态的最高优先级任务，因此调度程序选择任务1 作为要进入运行状态的任务。</p>
</li>
<li><p>t4 时刻 </p>
<p>任务1 在完成执行 <code>xTimerStart()</code> 函数之前被守护进程任务抢占，并且只有在重新进入运行状态后才退出 <code>xTimerStart()</code> (从<code>xTimerStart()</code> return)。</p>
</li>
<li><p>t5 时刻 </p>
<p>任务1 调用导致其进入阻塞状态的 API 函数。空闲任务现在是处于就绪状态的最高优先级任务，因此调度程序选择空闲任务作为要进入运行状态的任务。</p>
</li>
</ol>
<p>在图 42 所示的场景中，任务1 向定时器命令队列发送命令与守护进程任务接收和处理命令之间经过了一段时间。在图 43 所示的场景中，在 任务1 从发送命令的函数返回之前，守护进程任务已经接收并处理了任务1 发送给它的命令。</p>
<p>发送到定时器命令队列的命令包含时间戳。时间戳用于计算应用程序任务发送的命令与守护进程任务处理同一命令之间经过的任何时间。例如，如果发送 “启动定时器” 命令来启动周期为 10 个滴答的定时器，则时间戳用于确保正在启动的定时器是在命令发送后 10 个滴答到期，而不是在命令被守护进程任务处理之后 10 个滴答超时。</p>
<h2 id="创建和开始一个软件定时器"><a href="#创建和开始一个软件定时器" class="headerlink" title="创建和开始一个软件定时器"></a>创建和开始一个软件定时器</h2><h3 id="xTimerCreate-API函数"><a href="#xTimerCreate-API函数" class="headerlink" title="xTimerCreate()API函数"></a>xTimerCreate()API函数</h3><p>FreeRTOS V9.0.0还包含 <code>xTimerCreateStatic()</code> 函数，该函数在编译时静态分配创建定时器所需的内存: 软件定时器必须先显式创建，然后才能使用。</p>
<p>软件定时器由 <code>TimerHandle_t</code> 类型的变量引用。<code>xTimerCreate()</code> 用于创建软件定时器，并返回 <code>TimerHandle_t</code> 以引用其创建的软件定时器。软件定时器是在休眠状态下创建的。</p>
<p>可以在调度器运行之前创建软件定时器，也可以在调度器启动后从任务创建软件定时器。第 0 节介绍了使用的数据类型和命名约定。</p>
<pre class=" language-c"><code class="language-c">TimerHandle_t <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> pcTimerName<span class="token punctuation">,</span> 
                                TickType_t xTimerPeriodInTicks<span class="token punctuation">,</span> 
                                UBaseType_t uxAutoReload<span class="token punctuation">,</span> 
                                <span class="token keyword">void</span> <span class="token operator">*</span> pvTimerID<span class="token punctuation">,</span> 
                                TimerCallbackFunction_t pxCallbackFunction <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 73 . xTimerCreate()API函数原型</p>
<p>表 27 . xTimerCreate()参数和返回值</p>
<table>
<thead>
<tr>
<th>参数/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pcTimerName</td>
<td>计时器的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。使用人类可读的名称标识计时器比尝试通过其句柄标识要简单得多。</td>
</tr>
<tr>
<td>xTimerPeriodInTicks</td>
<td>以滴答为单位指定的计时器周期。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td>
</tr>
<tr>
<td>uxAutoReload</td>
<td>将 <code>uxAutoReload</code> 设置为 <code>pdTRUE</code> 以创建自动重载计时器。将 <code>uxAutoReload</code> 设置为 <code>pdFALSE</code> 以创建一次性计时器</td>
</tr>
<tr>
<td>pvTimerID</td>
<td>每个软件定时器都有一个 ID 值。ID 是一个 <code>void</code> 指针，应用程序编写者可以将其用于任何目的。当多个软件计时器使用相同的回调函数时，ID 特别有用，因为它可用于提供特定于时器的存储。本章中的一个示例演示了定时器 ID 的使用。<br><code>pvTimerID</code> 设置正在创建的任务的ID的初始值。</td>
</tr>
<tr>
<td>pxCallbackFunction</td>
<td>软件计时器回调函数仅仅是符合清单72中所示原型的C函数。<code>pxCallbackFunction</code> 参数是指向要用作正在创建的软件定时器的回调函数的函数指针 (实际上就是函数名) 。</td>
</tr>
<tr>
<td>返回值</td>
<td>如果返回 NULL ，则无法创建软件定时器，因为 FreeRTOS 没有足够的堆内存来分配必要的数据结构。<br>返回的非 NULL 值表示软件定时器已成功创建。返回值是创建的计时器的句柄。<br> 第2章提供了有关堆内存管理的更多信息。</td>
</tr>
</tbody></table>
<h3 id="xTimerStart-API函数"><a href="#xTimerStart-API函数" class="headerlink" title="xTimerStart()API函数"></a>xTimerStart()API函数</h3><p><code>xTimerStart()</code> 用于启动处于休眠状态的软件定时器，或重置(重新启动)处于运行状态的软件定时器。<code>xTimerStop()</code> 用于停止处于运行状态的软件定时器。停止软件定时器等同于与将定时器转换到休眠状态。</p>
<p>可以在调度程序启动之前调用 <code>xTimerStart()</code> ，但是当这样做时，软件定时器直到调度程序启动时才会实际启动。</p>
<blockquote>
<p>注意：切勿从中断服务例程调用 <code>xTimerStart()</code> 。应该使用中断安全版本 <code>xTimerStartFromISR()</code> 来代替它。</p>
</blockquote>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerStart</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 74 . xTimerStart()API函数原型</p>
<p>表 28 . xTimerStart()参数和返回值</p>
<table>
<thead>
<tr>
<th>参数/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xTimer</td>
<td>正在启动或重置的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td><code>xTimerStart()</code> 使用定时器命令队列向守护程序任务发送 “启动计时器” 命令。<br><code> xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerStart()</code> 将立即返回。<br>阻塞时间以滴答周期指定，因此它表示的绝对时间取决于滴答频率。宏 <code>pdMS_TO_TICKS()</code> 可用于将以毫秒为单位的时间转换为以滴答为单位的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在调度程序启动之前调用 <code>xTimerStart()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerStart()</code>的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td>
</tr>
<tr>
<td>返回值</td>
<td>有两个可能的返回值<br>1.  <code>pdPASS</code><br>只有当 “启动定时器” 命令成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果守护进程任务的优先级高于调用 <code>xTimerStart()</code> 的任务的优先级，那么调度程序将确保在 <code>xTimerStart()</code> 返回之前处理启动命令。这是因为一旦定时器命令队列中有数据，守护进程任务就会抢占调用 <code>TimerStart()</code>的任务。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br>2. <code>pdFALSE</code><br>如果由于队列已满而无法将 “启动定时器” 命令写入定时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在定时器命令队列中腾出空间，但指定的阻塞时间在此之前已到期。</td>
</tr>
</tbody></table>
<h3 id="示例-13-创建一次性和自动重载计时器"><a href="#示例-13-创建一次性和自动重载计时器" class="headerlink" title="示例 13. 创建一次性和自动重载计时器"></a>示例 13. 创建一次性和自动重载计时器</h3><p>此示例创建并启动一个一次性定时器和一个自动重载定时器 - 如清单 75 所示。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 分配给一次性和自动重载定时器的周期分别为3.333秒和半秒。 */</span> 
<span class="token macro property">#<span class="token directive keyword">define</span> mainONE_SHOT_TIMER_PERIOD pdMS_TO_TICKS( 3333 )</span>
<span class="token macro property">#<span class="token directive keyword">define</span> mainAUTO_RELOAD_TIMER_PERIOD pdMS_TO_TICKS( 500 ) </span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
 TimerHandle_t xAutoReloadTimer<span class="token punctuation">,</span> xOneShotTimer<span class="token punctuation">;</span>
 BaseType_t xTimer1Started<span class="token punctuation">,</span> xTimer2Started<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 创建一次性定时器，将创建的定时器的句柄存储在 xOneShotTimer 中。*/</span>  
    xOneShotTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> 
    <span class="token comment" spellcheck="true">/* 软件定时器的文本名称-未由 FreeRTOS 使用。*/</span>
    <span class="token string">"OneShot"</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/*软件定时器的周期(以滴答为单位)。*/</span>
    mainONE_SHOT_TIMER_PERIOD<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 将 uxAutoRealod 设置为 pdFALSE 将创建一次性软件定时器。*/</span>
    pdFALSE<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 此示例不使用定时器 ID。*/</span>
    <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 要由正在创建的软件定时器使用的回调函数。*/</span>
    prvOneShotTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 创建自动重载定时器，将创建的定时器的句柄存储在 xAutoReloadTimer 中。*/</span> 
    xAutoReloadTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> 
    <span class="token comment" spellcheck="true">/* 软件定时器的文本名称-未由 FreeRTOS 使用。 */</span>
    <span class="token string">"AutoReload"</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 软件定时器的周期(以滴答为单位)。*/</span>
    mainAUTO_RELOAD_TIMER_PERIOD<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 将 uxAutoRealod 设置为 pdTRUE 将创建自动重载定时器。*/</span>
    pdTRUE<span class="token punctuation">,</span> 
    <span class="token comment" spellcheck="true">/* 此示例不使用定时器 ID。 */</span>
    <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">/* 要由正在创建的软件定时器使用的回调函数。*/</span>
    prvAutoReloadTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 检查软件定时器是否已创建。*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xOneShotTimer <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xAutoReloadTimer <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* 阻塞时间设为 0 (无阻塞时间) 启动软件定时器。调度程序尚未启动，因此此处指定的任何阻塞时间都将被忽略。
 */</span>
    xTimer1Started <span class="token operator">=</span> <span class="token function">xTimerStart</span><span class="token punctuation">(</span> xOneShotTimer<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    xTimer2Started <span class="token operator">=</span> <span class="token function">xTimerStart</span><span class="token punctuation">(</span> xAutoReloadTimer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* xTimerStart() 的实现使用定时器命令队列，如果定时器命令队列已满，xTimerStart() 将失败。守护进程任务在调度程序启动之前不会创建，因此发送到命令队列的所有命令都将保留在队列中，直到调度程序启动之后。检查传递的两个 xTimerStart() 调用。*/</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimer1Started <span class="token operator">==</span> pdPASS <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>xTimer2Started <span class="token operator">==</span> pdPASS <span class="token punctuation">)</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* Start the scheduler. */</span>
    <span class="token function">vTaskStartScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
    <span class="token comment" spellcheck="true">/*一如既往，这条线不应该达到。 */</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>清单 75.  创建并启动示例 13 中使用的定时器</p>
<p>定时器的回调函数在每次被调用时只打印一条消息。清单 76 中显示了一次性定时器回调函数的实现。自动重载定时器回调函数的实现如清单 77 所示。</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvOneShotTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    TickType_t xTimeNow<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 获取当前的滴答计数。 */</span>
    xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 输出一个字符串以显示执行回调的时间*/</span>
    <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"One-shot timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* 文件作用域变量。(全局变量) */</span>
    ulCallCount<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
<p>清单 76.  示例 13 中的一次性定时器使用的回调函数</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvAutoReloadTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
TickType_t xTimeNow<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 获取当前的滴答计数。 */</span>
    xTimeNow <span class="token operator">=</span> <span class="token function">uxTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true">/* 输出一个字符串以显示执行回调的时间*/</span>
   <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Auto-reload timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>

  ulCallCount<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre>
<p>清单 77.  示例 13 中的自动重载定时器使用的回调函数</p>
<p>执行此示例将生成如图 44 所示的输出。图 44 显示了自动重载定时器的回调函数以500个滴答的固定周期执行 (清单 75 中的 <code>mainAUTO_RELOAD_TIMER_PERIOD</code> 设置为 500 )，当滴答计数为 3333 时，一次性定时器的回调函数只执行一次 (清单 75 中的 <code>mainOne_Shot_Timer_Period</code> 设置为 3333 )。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240331225428946.png" alt="图 44 执行示例 13 时产生的输出"></p>
<h2 id="定时器-ID"><a href="#定时器-ID" class="headerlink" title="定时器 ID"></a>定时器 ID</h2><p>每个软件定时器都有一个 ID，它是应用程序编写者可以出于任何目的使用的标记值。ID 存储在空指针 <code>(void*)</code> 中，因此可以直接存储整数值、指向任何其他对象或用作函数指针。</p>
<p>创建软件定时器时会为ID分配初始值 — 之后可以使用 <code>vTimerSetTimerID()</code> API函数更新 ID，并使用 <code>pvTimerGetTimerID()</code> API函数进行查询。</p>
<p>与其他软件定时器 API 函数不同，<code>vTimerSetTimerID()</code> 和 <code>pvTimerGetTimerID()</code> 直接访问软件定时器 — 它们不向定时器命令队列发送命令。</p>
<h3 id="vTimerSetTimerID-API函数"><a href="#vTimerSetTimerID-API函数" class="headerlink" title="vTimerSetTimerID()API函数"></a><strong>vTimerSetTimerID()API函数</strong></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">vTimerSetTimerID</span><span class="token punctuation">(</span> <span class="token keyword">const</span> TimerHandle_t xTimer<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvNewID <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 78.  vTimerSetTimerID() API 函数原型</p>
<p><strong>表 29. vTimerSetTimerID() 参数</strong></p>
<table>
<thead>
<tr>
<th align="left">参数/返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xTimer</td>
<td align="left">使用新 ID 值更新的软件定时器的句柄。 句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td align="left">pvNewID</td>
<td align="left">软件定时器 ID 将被设为的值。</td>
</tr>
</tbody></table>
<h3 id="pvTimerGetTimerID-API-函数"><a href="#pvTimerGetTimerID-API-函数" class="headerlink" title="pvTimerGetTimerID() API 函数"></a>pvTimerGetTimerID() API 函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pvTimerGetTimerID</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 79. pvTimerGetTimerID() API 函数原型</p>
<p>表 30.  pvTimerGetTimerID() 参数和返回值</p>
<table>
<thead>
<tr>
<th align="left">参数/返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">xTimer</td>
<td align="left">查询的软件定时器的句柄。句柄将从用于创建软件定时器的 <code>xTimerCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">查询的软件定时器的 ID。</td>
</tr>
</tbody></table>
<h3 id="示例-14-使用回调函数参数和软件定时器ID"><a href="#示例-14-使用回调函数参数和软件定时器ID" class="headerlink" title="示例 14. 使用回调函数参数和软件定时器ID"></a>示例 14. 使用回调函数参数和软件定时器ID</h3><p>可以将相同的回调函数分配给多个软件定时器。完成后，回调函数参数用于确定哪个软件定时器已到期。</p>
<p>示例 13 使用了两个单独的回调函数；一个回调函数由一次性定时器使用，另一个回调函数由自动重载定时器使用。示例 14 创建与示例 13 创建的功能类似的功能，但将单个回调函数分配给两个软件定时器。</p>
<p>示例 14 使用的 main() 函数与示例 13 使用的 main() 函数几乎相同，唯一的区别是创建软件定时器的位置。清单 80 显示了这种差异，其中 <code>prvTimerCallback()</code> 用作两个定时器的回调函数。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 创建一次定时器软件定时器，将句柄存储在 xOneShotTimer 中。*/</span>
xOneShotTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token string">"OneShot"</span><span class="token punctuation">,</span>
                                          mainONE_SHOT_TIMER_PERIOD<span class="token punctuation">,</span>
                                          pdFALSE<span class="token punctuation">,</span>
                                          <span class="token comment" spellcheck="true">/* 定时器ID初始化为0*/</span>
                                          <span class="token number">0</span><span class="token punctuation">,</span>
                                         <span class="token comment" spellcheck="true">/* 两个定时器都使用 prvTimerCallback()。*/</span>
                                         prvTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment" spellcheck="true">/* 创建自动重载软件定时器，将句柄存储在 xAutoReloadTimer 中*/</span>
xAutoReloadTimer <span class="token operator">=</span> <span class="token function">xTimerCreate</span><span class="token punctuation">(</span> <span class="token string">"AutoReload"</span><span class="token punctuation">,</span>
                                               mainAUTO_RELOAD_TIMER_PERIOD<span class="token punctuation">,</span>
                                               pdTRUE<span class="token punctuation">,</span>
                                               <span class="token comment" spellcheck="true">/* 定时器的ID初始化为0。 */</span>
                                               <span class="token number">0</span><span class="token punctuation">,</span>
                                               <span class="token comment" spellcheck="true">/* 两个定时器都使用 prvTimerCallback()。*/</span>
                                               prvTimerCallback <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 80. 创建示例 14 中使用的定时器</p>
<p><code>prvTimerCallback()</code> 将在任一定时器到期时执行。<code>prvTimerCallback()</code> 的实现使用函数的参数来确定调用它是因为一次性定时器已到期，还是因为自动重载定时器已到期。</p>
<p><code>prvTimerCallback()</code> 还演示了如何将软件定时器 ID 用作特定于定时器的存储；每个软件定时器在其自己的 ID 中保存其到期次数的计数，并且自动重载定时器在第五次执行时使用该计数停止自身。</p>
<p><code>prvTimerCallback()</code> 的实现如清单79所示</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
TickType_t xTimeNow<span class="token punctuation">;</span>
uint32_t ulExecutionCount<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/* 此软件定时器到期次数的计数存储在定时器的 ID 中。获取 ID，将其递增，
        然后将其另存为新的 ID 值。该 ID 是一个 void 指针，因此被强制转换为 uint32_t。*/</span>
        ulExecutionCount <span class="token operator">=</span> <span class="token punctuation">(</span> uint32_t <span class="token punctuation">)</span> <span class="token function">pvTimerGetTimerID</span><span class="token punctuation">(</span> xTimer <span class="token punctuation">)</span><span class="token punctuation">;</span>
        ulExecutionCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">vTimerSetTimerID</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token punctuation">)</span> ulExecutionCount <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*获取当前的计时次数。*/</span>
        xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*创建定时器时，一次性定时器的句柄存储在 xOneShotTimer 中。将传入此函数的句柄与
        xOneShotTimer 进行比较，以确定是一次性定时器还是自动重载定时器到期，然后输出一个
        字符串以显示执行回调的时间。*/</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> xTimer <span class="token operator">==</span> xOneShotTimer <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"One-shot timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">/*xTimer不等于 xOneShotTimer，所以一定是自动重载定时器到期，调用了回掉函数。*/</span>
            <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Auto-reload timer callback executing"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span> ulExecutionCount <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">/*自动重载定时器执行 5 次后停止。此回调函数在 RTOS 守护进程任务的上下文中执行，
                因此不能调用任何可能将守护进程任务置于阻塞状态的函数。因此，使用阻塞时间 0。*/</span>

                <span class="token function">xTimerStop</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre>
<p>清单 81. 示例 14 中使用的定时器回调函数</p>
<p>示例 14 产生的输出如图 45 所示。可以看到，自动重载定时器只执行了五次。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401025314788.png" alt="图 45 执行示例 14 时产生的输出"></p>
<h2 id="更改定时器的周期"><a href="#更改定时器的周期" class="headerlink" title="更改定时器的周期"></a>更改定时器的周期</h2><p>每个官方 FreeRTOS 移植都提供了一个或多个示例工程。大多数示例项目都是在运行中不断自检，LED用于提供项目状态的可视反馈；如果自检总是通过，则LED缓慢闪烁，如果自检失败，则LED快速闪烁。</p>
<p>一些示例工程在任务中执行自检，并使用 <code>vTaskDelay()</code> 函数控制LED的翻转速率。其他示例工程在软件定时器回调函数中执行自检，并使用定时器的周期来控制LED的翻转速率。</p>
<h3 id="xTimerChangePeriod-API函数"><a href="#xTimerChangePeriod-API函数" class="headerlink" title="xTimerChangePeriod()API函数"></a>xTimerChangePeriod()API函数</h3><p>使用 <code>xTimerChangePeriod()</code> 函数更改软件定时器的周期。</p>
<p>如果 <code>xTimerChangePeriod()</code> 用于更改已在运行的定时器的周期，则该定时器将使用新的周期值重新计算其到期时间。重新计算的到期时间是相对于调用 <code>xTimerChangePeriod()</code> 的时间，而不是相对于定时器最初启动的时间。</p>
<p>如果使用 <code>xTimerChangePeriod()</code> 来更改处于休眠状态的定时器(未运行的定时器)的周期，则定时器将计算到期时间，并转换到运行状态(定时器将开始运行)。</p>
<blockquote>
<p>注意：切勿从中断服务例程调用 <code>xTimerChangePeriod()</code>。应该使用中断安全版本 <code>xTimerChangePerodFromISR()</code> 来代替它。</p>
</blockquote>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerChangePeriod</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span>  
                               TickType_t xNewTimerPeriodInTicks<span class="token punctuation">,</span> 
                               TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 82.  xTimerChangePeriod() API 函数原型</p>
<p>表 31 xTimerChangePeriod() 参数和返回值</p>
<table>
<thead>
<tr>
<th>参数/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xTimer</td>
<td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td>xTimerPeriodInTicks</td>
<td>软件定时器的新的周期，以滴答为单位指定。<code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td><code>xTimerChangePeriod()</code> 使用定时器命令队列向守护进程任务发送 <code>"change Period"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerChangePeriod()</code> 将立即返回。<br><code>pdMS_TO_TICKS()</code> 宏可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有超时期限)，以等待定时器命令队列中的空间变得可用。<br>如果在启动调度程序之前调用了 <code>xTimerChangePeriod()</code>，则会忽略 <code>xTicksToWait</code> 的值，并且 <code>xTimerChangePeriod()</code> 的行为与将 <code>xTicksToWait</code> 设置为零时一样。</td>
</tr>
<tr>
<td>返回值</td>
<td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"Change Period"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td>
</tr>
</tbody></table>
<p>清单 83 展示了包含自检的 FreeRTOS 例程是怎么在软件定时器的回调函数中使用 <code>xTimerChangePeriod()</code> 在自检失败时提高LED闪烁速度的。执行自检的软件定时器被称为 “检查定时器 — check timer”。</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 检查定时器的创建周期为3000毫秒，导致LED每3秒切换一次。如果自检功能检测到意外状态，则检查定时器的周期将更改为仅200毫秒，从而导致更快的翻转速率。*/</span> 
<span class="token keyword">const</span> TickType_t xHealthyTimerPeriod <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">const</span> TickType_t xErrorTimerPeriod <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment" spellcheck="true">/* 检查定时器使用的回调函数。 */</span> 
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvCheckTimerCallbackFunction</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span> 
<span class="token punctuation">{</span> 
<span class="token keyword">static</span> BaseType_t xErrorDetected <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span> 

    <span class="token keyword">if</span><span class="token punctuation">(</span> xErrorDetected <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">/* 尚未检测到任何错误。再次运行自检功能。该函数要求示例创建的每个任务
        报告自己的状态，并检查所有任务是否实际上仍在运行(因此能够正确报告其状态)。*/</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">CheckTasksAreRunningWithoutError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> pdFAIL <span class="token punctuation">)</span> 
        <span class="token punctuation">{</span> 
            <span class="token comment" spellcheck="true">/*一个或多个任务报告意外状态，可能发生了错误。
            减少检查定时器的周期以提高此回调函数的执行速率，这样做还可以提高 LED 的切换速率。
            此回调函数在 RTOS 守护进程任务的上下文中执行，因此使用阻塞时间 0 来确保守护进程任务永
            远不会进入阻塞状态。*/</span> 
            <span class="token function">xTimerChangePeriod</span><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">/* 正要更新的定时器。*/</span> 
                                xErrorTimerPeriod<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 定时器的新周期*/</span> 
                                <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* 发送此命令时不要阻塞。 */</span> 
        <span class="token punctuation">}</span> 

        <span class="token comment" spellcheck="true">/* 锁定已检测到错误。 */</span> 
        xErrorDetected <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

    <span class="token comment" spellcheck="true">/* 切换 LED。LED 翻转的速率取决于调用此函数的频率，
    该频率由检查定时器的周期确定。如果
    CheckTasksAreRunningWithoutError() 曾经返回 pdFAIL，
    则定时器的周期将从 3000ms 减少到 200ms。*/</span> 
    <span class="token function">ToggleLED</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<p>清单 83. 使用 xTimerChangePeriod()</p>
<h2 id="重置一个定时器"><a href="#重置一个定时器" class="headerlink" title="重置一个定时器"></a>重置一个定时器</h2><p>重置软件定时器意味着重新启动定时器；计时器的到期时间将根据重置计时器的时间重新计算，而不是相对于计时器最初启动的时间。图 46 演示了这一点，它显示了一个以 6 为周期启动的定时器，然后重置两次，最后到期并执行其回调函数。</p>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401041311370.png" alt="图 46. 启动和重置周期为 6 个滴答的软件定时器"></p>
<p>参考图 46：</p>
<ul>
<li>定时器 1 在 t1 时刻启动。它的周期为 6，因此它执行回调函数的时间最初计算为 t7，即启动后的 6 个滴答。</li>
<li>定时器1在到达 t7 时刻之前重置，也就是在它到期并执行其回调函数之前被重置。定时器 1 在 t5 时刻 被重置，因此它将执行其回调函数的时间被重新计算为 t11，即它被重置后的6个滴答。</li>
<li>定时器 1 在 t11 时刻之前再次重置，因此在其到期并执行其回调函数之前再次复位。定时器1在 t9 时刻被重置，因此它将执行其回调函数的时间被重新计算为 t15，这是它上次被重置后的6个滴答。</li>
<li>定时器1 不会再次重置，因此它在 t15 时刻到期，并且相应地执行其回调函数。</li>
</ul>
<h3 id="xTimerReset-API函数"><a href="#xTimerReset-API函数" class="headerlink" title="xTimerReset() API函数"></a>xTimerReset() API函数</h3><p>使用 <code>xTimerReset()</code> API函数重置定时器。</p>
<p><code>xTimerReset()</code> 还可用于启动处于休眠状态的定时器。</p>
<blockquote>
<p>注意：切勿从中断服务例程调用 <code>xTimerReset()</code>。应该使用中断安全版本 <code>xTimerResetFromISR()</code> 来代替它。</p>
</blockquote>
<pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTimerReset</span><span class="token punctuation">(</span> TimerHandle_t xTimer<span class="token punctuation">,</span> TickType_t xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>清单 84. xTimerReset() API 函数原型</p>
<p>表 32. xTimerReset()参数和返回值</p>
<table>
<thead>
<tr>
<th>参数/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>xTimer</td>
<td>需要更新的软件定时器的句柄。句柄将从用于创建软件计时器的 <code>xTimerCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td><code>xTimerReset()</code> 使用定时器命令队列向守护进程任务发送 <code>"reset"</code> 命令。<code>xTicksToWait</code> 指定如果队列已满，调用任务应保持在阻塞状态以等待定时器命令队列上的空间变为可用的最长时间。<br>如果 <code>xTicksToWait</code> 为零且定时器命令队列已满，则 <code>xTimerReset()</code> 将立即返回。<br>如果 <code>FreeRTOSConfig.h</code> 中的 <code>include_vTaskSuspend</code> 设置为 1，则。将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致调用任务无限期地保持在阻塞状态(没有期限)，以等待定时器命令队列中的空间变得可用。</td>
</tr>
<tr>
<td>返回值</td>
<td>有两个可能的返回值 <br>1. <code>pdPASS</code> <br>只有当数据成功发送到定时器命令队列时，才会返回 <code>pdPASS</code>。<br>如果指定了阻塞时间( <code>xTicksToWait</code> 不为零)，则在函数返回之前，调用任务可能被置于阻塞状态，以等待定时器命令队列中的空间变为可用，但在阻塞时间到期之前，数据已成功写入定时器命令队列。<br><code>2. pdFALSE</code> <br>如果由于队列已满而无法将 <code>"reset"</code> 命令写入计时器命令队列，则将返回 <code>pdFALSE</code>。<br>如果指定了阻塞时间 ( <code>xTicksToWait</code> 不是零)，则调用任务将被置于阻塞状态，以等待守护进程任务在队列中腾出空间，但指定的阻塞时间在此之前已到期。</td>
</tr>
</tbody></table>
<h3 id="示例-15-重置软件定时器"><a href="#示例-15-重置软件定时器" class="headerlink" title="示例 15. 重置软件定时器"></a>示例 15. 重置软件定时器</h3><p>此示例模拟手机上的背光行为。背光：</p>
<ul>
<li>按下某个按键时打开。</li>
<li>如果在一定时间段内按下按键，则保持开启。</li>
<li>如果在一定时间段内没有按下按键，则自动关闭。</li>
</ul>
<p>使用一次性软件定时器来实现此行为：</p>
<ul>
<li>按下按键时打开 [模拟] 背光，在软件定时器的回调函数中关闭 [模拟] 背光。</li>
<li>每次按键按下，软件定时器重置。</li>
<li>因此，需要按下按键防止背光熄灭的时间段等于软件定时器的周期；如果在定时器到期之前没有通过按键重置软件定时器，则执行定时器的回调功能，关闭背光。</li>
</ul>
<p><code>xSimulatedBacklightOn</code> 变量保存背光状态。<code>xSimulatedBacklightOn</code> 设置为pdTRUE表示背光打开，设置为 <code>pdFALSE</code> 表示背光关闭。</p>
<p>软件定时器回调函数如清单85所示。</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prvBacklightTimerCallback</span><span class="token punctuation">(</span> TimerHandle_t xTimer <span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
    TickType_t xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">/* 背光定时器超时，关闭背光。*/</span>
        xSimulatedBacklightOn <span class="token operator">=</span> pdFALSE<span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">/*打印背光关闭的时间。*/</span>
         <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span> <span class="token string">"Timer expired, turning backlight OFF at time\t\t"</span><span class="token punctuation">,</span> xTimeNow<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<p>清单 85. 示例 15 中使用的一次性定时器的回调函数</p>
<p>示例 15 创建一个任务来轮询键盘[1]。清单 86 显示了该任务，但是由于下一段中描述的原因，清单 86 并不是最佳设计的代表。</p>
<p><em>[1].打印到 Windows 控制台和从 Windows 控制台读取按键都会导致执行 Windows 系统调用。Windows 系统调用 ( 包括使用 Windows 控制台、磁盘或 TCP/IP 堆栈 )，可能会对 FreeRTOS Windows 移植的行为产生不利影响，因此通常应避免使用。</em></p>
<p>使用FreeRTOS允许您的应用程序是事件驱动的。事件驱动设计非常有效地使用处理时间，因为处理时间仅在事件已发生时使用，并且处理时间不会浪费在轮询尚未发生的事件上。示例 15 不能由事件驱动，因为在使用 FreeRTOS Windows 移植时处理键盘中断是不切实际的，因此必须使用效率低得多的轮询技术。如果清单 86 是一个中断服务例程，那么将使用 <code>xTimerResetFromISR()</code> 代替 <code>xTimerReset()</code>。</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vKeyHitTask</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span> 
<span class="token punctuation">{</span> 
<span class="token keyword">const</span> TickType_t xShortDelay <span class="token operator">=</span> <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span> <span class="token number">50</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
TickType_t xTimeNow<span class="token punctuation">;</span>

    <span class="token function">vPrintString</span><span class="token punctuation">(</span> <span class="token string">"Press a key to turn the backlight on.\r\n"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token comment" spellcheck="true">/* 理想情况下，应用程序应该是事件驱动的，并使用中断来处理按键。
    在使用 FreeRTOS Windows 移植时使用键盘中断是不切实际的，
    因此此任务用于轮询按键。*/</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/* 按键被按下了吗?*/</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">_kbhit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">/* 已按下一个按键。记录时间。 */</span> 
            xTimeNow <span class="token operator">=</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span> xSimulatedBacklightOn <span class="token operator">==</span> pdFALSE <span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">/* 背光已关闭，因此将其打开并打印其打开的时间。 */</span> 
                xSimulatedBacklightOn <span class="token operator">=</span> pdTRUE<span class="token punctuation">;</span> <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span>
                                            <span class="token string">"Key pressed, turning backlight ON at time\t\t"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span> 
                <span class="token comment" spellcheck="true">/* 背光已打开，因此打印一条消息，说明定时器即将重置以及重置的时间。*/</span>
                <span class="token function">vPrintStringAndNumber</span><span class="token punctuation">(</span>
                                    <span class="token string">"Key pressed, resetting software timer at time\t\t"</span><span class="token punctuation">,</span> xTimeNow <span class="token punctuation">)</span><span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> 

             <span class="token comment" spellcheck="true">/* 重置软件定时器。如果之前关闭了背光，则此调用将启动定时器。
             如果背光先前处于打开状态，则此调用将重新启动定时器。
             真实的应用程序可以读取中断中的按键。如果此函数是中断服务例程，
             则必须使用xTimerResetFromISR()而不是xTimerReset()。*/</span>
             <span class="token function">xTimerReset</span><span class="token punctuation">(</span> xBacklightTimer<span class="token punctuation">,</span> xShortDelay <span class="token punctuation">)</span><span class="token punctuation">;</span> 

             <span class="token comment" spellcheck="true">/* 读取并丢弃按下的按键 --- 这在这个简单的示例中不是必需的。*/</span> 
             <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token function">_getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
           <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>清单 86. 示例15中用于重置软件定时器的任务</p>
<p>执行示例 15 时产生的输出如图 47 所示。参考图 47 ：</p>
<ul>
<li>在滴答计数为 812 的时候发生第一次按键。此时，打开背光，并启动一次性定时器。</li>
<li>当滴答计数为 1813、3114、4015 和 5016 时，发生了进一步的按键。所有这些按键都会导致定时器在到期之前被重置。</li>
<li>定时器在滴答计数为 10016 时到期。此时，关闭背光。</li>
</ul>
<p><img src="/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/image-20240401055137191.png" alt="图 47 执行示例 15 时产生的输出"></p>
<p>在图 47 中可以看到，定时器有 5000 个滴答的周期；最后一次按下按键后，背光恰好在 5000 次滴答后关闭，所以在最后一次重置定时器之后有 5000 个滴答。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/Blogs/about" rel="external nofollow noreferrer">Koito Yuu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://koito-yuu153.github.io/Blogs/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/">https://koito-yuu153.github.io/Blogs/Blogs/2024/03/21/chapter-5-ruan-jian-ding-shi-qi-guan-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/Blogs/about" target="_blank">Koito Yuu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/Blogs/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/Blogs/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/Blogs/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/Blogs/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/Blogs/2024/03/21/chapter-3-ren-wu-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/21.jpg" class="responsive-img" alt="Chapter 3 任务管理">
                        
                        <span class="card-title">Chapter 3 任务管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-03-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/Blogs/categories/FreeRTOS/" class="post-category">
                                    FreeRTOS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/Blogs/2024/03/21/chapter-6-zhong-duan-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/22.jpg" class="responsive-img" alt="Chapter 6 中断管理">
                        
                        <span class="card-title">Chapter 6 中断管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/Blogs/categories/FreeRTOS/" class="post-category">
                                    FreeRTOS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/Blogs/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/Blogs/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/Blogs/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="9479612817"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/Blogs/libs/aplayer/APlayer.min.js"></script>
<script src="/Blogs/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <a href="/Blogs/about" target="_blank">Koito Yuu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Koito-Yuu153" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2810880357" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2810880357" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/Blogs/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/Blogs/libs/materialize/materialize.min.js"></script>
    <script src="/Blogs/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/Blogs/libs/aos/aos.js"></script>
    <script src="/Blogs/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/Blogs/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/Blogs/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/Blogs/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/Blogs/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/Blogs/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/Blogs/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
