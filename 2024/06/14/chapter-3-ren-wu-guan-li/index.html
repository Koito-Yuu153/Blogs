<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Chapter 3 任务管理, Koito Yuu&#39;s Blogs">
    <meta name="description" content="Chapter 3 任务管理3.1 章节介绍和范围范围本章旨在让读者更好地理解 : 

FreeRTOS 如何为应用程序中的每个任务分配处理时间。
FreeRTOS 如何选择在任何给定时间应该执行哪个任务。
每个任务的相对优先级如何影响系统">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Chapter 3 任务管理 | Koito Yuu&#39;s Blogs</title>
    <link rel="icon" type="image/png" href="/Blogs/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/Blogs/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/matery.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/my.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/Blogs/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/Blogs/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/Blogs/css/reward.css">
    



    <script src="/Blogs/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/Blogs/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/Blogs/" class="waves-effect waves-light">
                    
                    <img src="/Blogs/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Koito Yuu&#39;s Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/Blogs/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Koito Yuu&#39;s Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/Blogs/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Chapter 3 任务管理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-06-14
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/Blogs/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Chapter-3-任务管理"><a href="#Chapter-3-任务管理" class="headerlink" title="Chapter 3 任务管理"></a>Chapter 3 任务管理</h1><h2 id="3-1-章节介绍和范围"><a href="#3-1-章节介绍和范围" class="headerlink" title="3.1 章节介绍和范围"></a>3.1 章节介绍和范围</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章旨在让读者更好地理解 : </p>
<ul>
<li>FreeRTOS 如何为应用程序中的每个任务分配处理时间。</li>
<li>FreeRTOS 如何选择在任何给定时间应该执行哪个任务。</li>
<li>每个任务的相对优先级如何影响系统行为。 </li>
<li>任务可以存在的状态。</li>
</ul>
<p>读者还应该充分了解 : </p>
<ul>
<li>如何实现任务。</li>
<li>如何创建任务的一个或多个实例 ( instance ) 。</li>
<li>如何使用任务参数。</li>
<li>如何更改已创建任务的优先级。</li>
<li>如何删除任务。</li>
<li>如何使用任务实现周期性处理 ( 软件定时器将在后面的章节中讨论 ) 。</li>
<li>空闲任务何时执行以及如何使用。</li>
</ul>
<p>本章介绍的概念对于理解如何使用 FreeRTOS 以及 FreeRTOS 应用程序的行为至关重要。因此，这是书中最详细的一章。</p>
<h2 id="3-2-任务函数"><a href="#3-2-任务函数" class="headerlink" title="3.2 任务函数"></a>3.2 任务函数</h2><p>任务被实现为 C 函数。 它们唯一的特殊之处是它们的原型，它必须返回 <code>void</code> 并接受一个 <code>void</code> 指针参数。 清单 11 展示了原型。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 11. 任务函数原型</p>
<p>每个任务本身都是一个小程序。 它有一个入口点，通常会在无限循环内永远运行，并且不会退出。典型任务的结构如清单 12 所示。</p>
<p>不得允许 FreeRTOS 任务以任何方式从其实现函数返回 —— 它们不得包含 <code>return</code> 语句，并且不得允许执行到函数末尾之后。如果不再需要某个任务，则应将其显式删除。清单 12 也演示了这一点。</p>
<p>单个任务函数定义可用于创建任意数量的任务 —— 每个创建的任务都是一个单独的执行实例 ( instance )，具有自己的堆栈和在任务本身内定义的任何自动 ( 堆栈 ) 变量的副本。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/* 变量可以像普通函数一样声明。使用此示例函数创建的任务的每个实例都将拥有自己的 lVariableExample </span></span><br><span class="line"><span class="comment">变量副本。如果变量被声明为静态，则情况并非如此——在这种情况下，只会存在该变量的一个副本，</span></span><br><span class="line"><span class="comment">并且该副本将由每个创建的任务实例共享。 ( 添加到变量名称的前缀在第 1.5 节“数据类型和编码风格指南”中描述。 )*/</span></span><br><span class="line"><span class="type">int32_t</span> lVariableExample = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务通常会以无限循环的形式实现。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 实现任务功能的代码将放在这里。 */</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果任务实现突破上述循环，则必须在到达其实现功能结束之前删除该任务。 传递给 vTaskDelete() </span></span><br><span class="line"><span class="comment">    API 函数的 NULL 参数指示要删除的任务是调用（当前）任务。 用于命名 API 函数的约定在第 0 节中</span></span><br><span class="line"><span class="comment">    描述，使用早于 V9.0.0 的 FreeRTOS 版本的项目必须构建一个 heap_n.c 文件。 从 </span></span><br><span class="line"><span class="comment">    FreeRTOS V9.0.0 开始，只有在 FreeRTOSConfig.h 中将 configSUPPORT_DYNAMIC_ALLOCATION</span></span><br><span class="line"><span class="comment">    设置为 1 或者未定义 configSUPPORT_DYNAMIC_ALLOCATION 时才需要 heap_n.c 文件。 有关更多</span></span><br><span class="line"><span class="comment">    信息，请参阅第 2 章堆内存管理。 数据类型和编码风格指南。</span></span><br><span class="line"><span class="comment">    如果任务实现从上述循环中突破，则必须在到达其实现函数末尾之前删除该任务。</span></span><br><span class="line"><span class="comment">    传递给 vTaskDelete() API 函数的 NULL 参数指示要删除的任务是调用 (此) 任务。</span></span><br><span class="line"><span class="comment">    用于命名 API 函数的约定在第 0 节中进行了描述，使用早于 V9.0.0 的 FreeRTOS </span></span><br><span class="line"><span class="comment">    版本的项目必须构建 heap_n.c 文件之一。从 FreeRTOS V9.0.0 开始，</span></span><br><span class="line"><span class="comment">    仅当 FreeRTOSConfig.h 中的 configSUPPORT_DYNAMIC_ALLOCATION 设置为 1 </span></span><br><span class="line"><span class="comment">    或 configSUPPORT_DYNAMIC_ALLOCATION 未定义时才需要 heap_n.c 文件。</span></span><br><span class="line"><span class="comment">    有关详细信息，请参阅第 2 章“堆内存管理”。  </span></span><br><span class="line"><span class="comment">    数据类型和编码风格指南。*/</span></span><br><span class="line">    vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 12.  一个典型的任务函数的结构</p>
<h2 id="3-3-顶层任务状态"><a href="#3-3-顶层任务状态" class="headerlink" title="3.3 顶层任务状态"></a>3.3 顶层任务状态</h2><p>应用程序可以包含许多任务。 如果运行应用程序的处理器是单核的，那么在任何给定时间只能执行一个任务。 这意味着任务可以存在两种状态：运行和未运行。 首先考虑这种简单化的模型，但请记住，这是一种过度简化。 在本章的后面，显示 “未运行” 状态实际上包含许多子状态。</p>
<p>一个应用程序可以包含许多任务。如果运行应用程序的处理器是单核的，则在任何给定时间只能执行一个任务。这意味着任务可以存在于两种状态之一：<code>运行 ( Running )</code> 和 <code>非运行 ( No Running )</code> 。首先考虑这种简单化的模型，但请记住，它过于简单化了。本章后面显示 <code>"非运行 ( No Running )"</code> 状态实际上包含许多子状态。</p>
<p>当任务处于运行状态时，处理器正在执行任务的代码。当任务处于 <code>"非运行 ( No Running )"</code> 状态时，该任务处于休眠状态，其状态已被保存，以便下次调度程序决定它应该进入 <code>"运行 ( Running ) "</code> 状态时恢复执行。   当任务恢复执行时，它会从上次离开 <code>"运行 ( Running )"</code> 状态之前即将执行的指令开始执行。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240526132629539.png" alt="图 9. 顶层任务状态和转换"></p>
<p>从 “未运行” 状态转换为 “运行” 状态的任务被称为 “切入” 或 “换入”。 相反，从 “运行” 状态转换到 “未运行” 状态的任务据说已被 “切出” 或 “换出”。 FreeRTOS 的调度程序是唯一可以切换任务的实体。</p>
<p>从非运行状态转换到运行状态的任务被称为 <code>"切换入 ( switched in ) "</code> 或 <code>"交换入 ( swapped in )"</code>。相反，从运行状态转换到非运行状态的任务被称为 <code>"切换出 ( switched out )"</code> 或 <code>"交换出 ( swapped out )"</code>。FreeRTOS 调度程序是唯一可以切换入和切换出任务的实体。</p>
<h2 id="3-4-创建任务"><a href="#3-4-创建任务" class="headerlink" title="3.4 创建任务"></a>3.4 创建任务</h2><h3 id="xTaskCreate-API-函数"><a href="#xTaskCreate-API-函数" class="headerlink" title="xTaskCreate() API 函数"></a>xTaskCreate() API 函数</h3><p>FreeRTOS V9.0.0 还包括 <code>xTaskCreateStatic()</code> 函数，该函数在编译时静态地分配创建任务所需的内存: 使用 FreeRTOS <code>xTaskCreate()</code> API 函数创建任务。这可能是所有 API 函数中最复杂的，因此很不幸，它是第一个遇到的函数，但是必须首先掌握任务，因为它们是多任务系统中最基本的组件。本书附带的所有示例都使用了 <code>xTaskCreate()</code> 函数，因此有大量示例可供参考。</p>
<p>第 1.5 节 “数据类型和编程样式指南” 描述了所使用的数据类型和命名约定。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pvTaskCode, </span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">                        <span class="type">uint16_t</span> usStackDepth, </span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *pvParameters, </span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority, </span></span><br><span class="line"><span class="params">                        TaskHandle_t *pxCreatedTask )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 13. <code>xTaskCreate()</code> API 函数原型</p>
<p>表 8. <code>xTaskCreate()</code> 参数和返回值</p>
<table>
<thead>
<tr>
<th>参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pvTaskCode</code></td>
<td>任务只是永不退出的 C 函数，因此通常作为无限循环实现。 <code>pvTaskCode</code> 参数只是一个指向实现任务的函数的指针（实际上，只是函数的名称）。</td>
</tr>
<tr>
<td><code>pcName</code></td>
<td>任务的描述性名称。FreeRTOS 不会以任何方式使用它。它纯粹是作为调试辅助工具而包含的。通过人类可读的名称来识别任务要比尝试通过其句柄来识别任务简单得多。<br><br>应用程序定义的常量 <code>configMAX_TASK_NAME_LEN</code> 定义了任务名称可以采用的最大长度 — 包括空终止符。提供长度超过此最大值的字符串将导致字符串被自动截断。<p></p></td>
</tr>
<tr>
<td><code>usStackDepth</code></td>
<td>每个任务都有自己的唯一堆栈，该堆栈在任务创建时由内核分配给任务。 <code>usStackDepth</code> 值告诉内核堆栈的大小。<br>该值指定堆栈可以容纳的字数，而不是字节数。 例如，如果堆栈是 32 位宽并且 <code>usStackDepth</code> 作为 100 传入，则将分配 400 字节的堆栈空间（100 * 4 字节）。 堆栈深度乘以堆栈宽度不得超过 <code>uint16_t</code> 类型的变量中可包含的最大值。<br>空闲任务使用的堆栈大小由应用程序定义的常量 <code>configMINIMAL_STACK_SIZE</code> [1] 定义。在 FreeRTOS 演示应用程序中为所使用的处理器架构分配给该常量的值是建议用于任何任务的最小值。如果您的任务使用了大量堆栈的空间，则必须分配一个更大的值。<br>没有简单的方法可以确定任务所需的堆栈空间。   可以计算，但大多数用户会简单地分配一个他们认为合理的值，然后使用FreeRTOS提供的功能来确保分配的空间确实足够，并且RAM不会被不必要地浪费。第 12.3 节 “堆栈溢出” 包含有关如何查询任务实际已使用的最大堆栈空间的信息。</td>
</tr>
<tr>
<td><code>pvParameters</code></td>
<td>任务函数接受指向 <code>void ( void* )</code> 的指针类型的参数。分配给 <code>pvParameters</code> 的值是传递到任务中的值。   本书中的一些示例演示了如何使用该参数。</td>
</tr>
<tr>
<td><code>uxPriority</code></td>
<td>定义任务执行的优先级。优先级可以从 0（最低优先级）到 ( <code>configMAX_PRIORITIES</code> – 1)（最高优先级）进行分配。 <code>configMAX_PRIORITIES</code> 是一个用户定义的常量，在 3.5 节中描述。<br>传递高于 ( <code>configMAX_PRIORITIES</code> - 1 ) 的 <code>uxPriority</code> 值将导致分配给任务的优先级被静默地限制为最大合法值。</td>
</tr>
<tr>
<td><code>pxCreatedTask</code></td>
<td><code>pxCreatedTask</code> 可用于传递正在创建的任务的句柄。然后，该句柄可用于在 API 调用中引用任务，例如更改任务优先级或删除任务<br>如果您的应用程序不需要任务句柄，则可以将 <code>pxCreatedTask</code> 设置为 <code>NULL</code>。</td>
</tr>
<tr>
<td>返回值</td>
<td>有两种可能的返回值：<br><code>pdPASS</code>：<br>这表明任务已成功创建。<br><code>pdFAIL</code>：<br>这表明任务尚未创建，因为没有足够的堆内存可供FreeRTOS分配足够的RAM来容纳任务数据结构和堆栈。<br>第 2 章提供了有关堆内存管理的更多信息。</td>
</tr>
</tbody></table>
<blockquote>
<p>[1] : 这是 FreeRTOS 源代码使用 <code>configMINIMAL_STACK_SIZE</code> 设置的唯一方式，尽管该常量也在演示应用程序内部使用，以帮助演示在多个处理器架构之间移植。</p>
</blockquote>
<h3 id="示例-1-创建任务"><a href="#示例-1-创建任务" class="headerlink" title="示例 1. 创建任务"></a>示例 1. 创建任务</h3><p>此示例演示了创建两个简单任务，然后启动任务执行所需的步骤。这些任务只是周期性地打印出一个字符串，使用一个粗略的空循环来创建周期延迟。这两个任务都是以相同的优先级创建的，除了它们打印出来的字符串之外，它们都是相同的 —— 它们各自的实现见清单14和清单15。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">"Task 1 is running\r\n"</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile 以确保 ul 不会被优化掉。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟一段时间。 */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。</span></span><br><span class="line"><span class="comment">            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 14. 示例 1 中使用的第一个任务的实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">"Task 2 is running\r\n"</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile 以确保 ul 不会被优化掉。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟一段时间。 */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。</span></span><br><span class="line"><span class="comment">            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。*/</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 15. 示例 1 中使用的第二个任务的实现</p>
<p><code>main()</code> 函数在启动调度程序之前创建任务，有关其实现请参见清单 16。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 创建两个任务之一。请注意，真正的应用程序应该检查 xTaskCreate() </span></span><br><span class="line"><span class="comment">    调用的返回值，以确保任务创建成功。 */</span></span><br><span class="line">    xTaskCreate(    vTask1,  <span class="comment">/* 指向实现任务的函数的指针。 */</span></span><br><span class="line">                    <span class="string">"Task 1"</span>,<span class="comment">/* 任务的文本名称。这只是为了方便调试。 */</span></span><br><span class="line">                    <span class="number">1000</span>,    <span class="comment">/* 堆栈深度，小型微控制器将使用比这少得多的堆栈。 */</span></span><br><span class="line">                    <span class="literal">NULL</span>,    <span class="comment">/* 此示例不使用任务参数。 */</span></span><br><span class="line">                    <span class="number">1</span>,       <span class="comment">/* 此任务将以优先级 1 运行。 */</span></span><br><span class="line">                    <span class="literal">NULL</span> );  <span class="comment">/* 此示例不使用任务句柄。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以完全相同的方式，以相同的优先级创建另一个任务。 */</span></span><br><span class="line">    xTaskCreate(vTask2, <span class="string">"Task 2"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动调度程序，以便任务开始执行。 */</span></span><br><span class="line">    vTaskStartScheduler();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行任务。</span></span><br><span class="line"><span class="comment">    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了</span></span><br><span class="line"><span class="comment">    关于堆内存管理的更多信息。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 16. 启动示例 1 任务</p>
<p>执行该示例将产生图 10 中所示的输出。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240526181455382.png" alt="图 10. 执行示例 1 时产生的输出"></p>
<blockquote>
<p>屏幕截图显示每个任务在下一个任务执行之前打印一次其消息。   这是使用 FreeRTOS Windows 模拟器产生的人为场景。 Windows 模拟器并不是真正的实时。此外，写入 Windows 控制台需要相对较长的时间，并会导致一系列 Windows 系统调用。在具有快速且非阻塞打印功能的真正嵌入式目标上执行相同的代码可能会导致每个任务在切换出去以允许其他任务运行之前多次打印其字符串。</p>
</blockquote>
<p>图 10 显示了两个任务似乎同时执行；然而，由于两个任务都在同一处理器核心上执行，因此情况并非如此。实际上，这两个任务都在快速进入和退出运行状态。两个任务都以相同的优先级运行，因此在同一处理器核心上共享时间。它们的实际执行模式如图 11 所示。</p>
<p>图11底部的箭头显示了从时间 t1 开始的时间流逝。彩色线显示每个时间点正在执行哪个任务 —— 例如，任务 1 在时间 t1 和时间 t2 之间执行。</p>
<p>任何时候只有一个任务可以处于运行状态。 因此，当一个任务进入 <code>"运行 ( Running ) "</code>  状态 ( 任务被切入 ) 时，另一个任务进入 <code>"非运行 ( No Running ) "</code> 状态（任务被切出）。 </p>
<p>任一时刻只能有一个任务处于运行状态。因此，当一个任务进入“正在运行”状态（任务被切换入）时，另一个任务进入“未运行”状态（任务被切换出）。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240526182954329.png" alt="图 11. 两个示例 1 任务的实际执行模式"></p>
<p>示例 1 在启动调度程序之前从 <code>main()</code> 中创建了两个任务。也可以从另一个任务中创建一个任务。例如，可以从任务 1 中创建任务 2，如清单 17 所示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">"Task 1 is running\r\n"</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile 以确保 ul 不会被优化掉。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果正在执行此任务代码，则调度程序必须已经启动。</span></span><br><span class="line"><span class="comment">    在进入无限循环之前创建另一个任务。 */</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">"Task 2"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟一段时间。 */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。</span></span><br><span class="line"><span class="comment">            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 17. 调度程序启动后从另一个任务中创建一个任务</p>
<h3 id="示例-2-使用任务参数"><a href="#示例-2-使用任务参数" class="headerlink" title="示例 2. 使用任务参数"></a>示例 2. 使用任务参数</h3><p>在示例 1 中创建的两个任务是字面上的，它们之间的唯一区别是它们打印出来的文本字符串。 相反，可以通过创建单个任务实现的两个实例来消除这种重复。 然后可以使用任务参数将其应打印的字符串传递给每个任务。</p>
<p>清单 18 包含示例 2 使用的单任务函数（ <code>vTaskFunction</code> ）的代码。此单个函数替换了示例 1 中使用的两个任务函数（ <code>vTask1</code> 和  <code>vTask2</code> ）。请注意如何将任务参数转换为 <code>char *</code> 以获得任务应该打印出来的字符串。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> *pcTaskName;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> ul; <span class="comment">/* volatile 以确保 ul 不被优化掉。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要打印出来的字符串是通过参数传入的。将其强制转换为字符指针。 */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟一段时间。 */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* 这个循环只是一个非常粗糙的延迟实现。这里没什么可做的。</span></span><br><span class="line"><span class="comment">            后面的示例将用适当的延迟/睡眠函数替换这个粗略循环。 */</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 18. 用于在示例 2 中创建两个任务的单个任务函数</p>
<p>即使现在只有一个任务实现（<code>vTaskFunction</code>），也可以创建多个已定义任务的实例。每个创建的实例将在 FreeRTOS 调度程序的控制下独立执行。</p>
<p>清单 19 演示了如何使用 <code>xTaskCreate()</code> 函数的 <code>pvParameters</code> 参数将文本字符串传递给任务。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义将作为任务参数传入的字符串。它们被定义为 const 并且不在堆栈上，</span></span><br><span class="line"><span class="comment">以确保它们在任务执行时保持有效。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask1 = <span class="string">"Task 1 is running\r\n"</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask2 = <span class="string">"Task 2 is running\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 创建两个任务之一。 */</span></span><br><span class="line">    xTaskCreate(    vTaskFunction,         <span class="comment">/* 指向实现任务的函数的指针。 */</span></span><br><span class="line">                    <span class="string">"Task 1"</span>,              <span class="comment">/* 任务的文本名称。这只是为了方便调试。 */</span></span><br><span class="line">                    <span class="number">1000</span>,                  <span class="comment">/* 堆栈深度 - 小型微控制器将使用比这少得多的堆栈。 */</span></span><br><span class="line">                    (<span class="type">void</span>*)pcTextForTask1, <span class="comment">/* 使用任务参数将要打印的文本传递到任务中。 */</span></span><br><span class="line">                    <span class="number">1</span>,                     <span class="comment">/* 这个任务将以优先级 1 运行。 */</span></span><br><span class="line">                    <span class="literal">NULL</span> );                <span class="comment">/* 本例中没有使用任务句柄。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用完全相同的方法创建另一个任务。注意，这一次将从同一个任务实现 (vTaskFunction) </span></span><br><span class="line"><span class="comment">    创建多个任务。只有参数中传递的值不同。正在创建同一任务的两个实例。 */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="string">"Task 2"</span>, <span class="number">1000</span>, (<span class="type">void</span>*)pcTextForTask2, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动调度程序，使任务开始执行。 */</span></span><br><span class="line">    vTaskStartScheduler();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。</span></span><br><span class="line"><span class="comment">    如果 main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆</span></span><br><span class="line"><span class="comment">    内存管理的更多信息。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 19. 示例 2 所使用的 <code>main()</code> 函数</p>
<p>示例 2 的输出与图 10 中示例 1 所示的输出完全相同。</p>
<h2 id="3-5-任务优先级"><a href="#3-5-任务优先级" class="headerlink" title="3.5 任务优先级"></a>3.5 任务优先级</h2><p><code>xTaskCreate()</code> API 函数的 <code>uxPriority</code> 参数为正在创建的任务分配初始优先级。调度程序启动后，可以使用 <code>vTaskPrioritySet()</code> API 函数更改优先级。</p>
<p>可用优先级的最大数量由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configMAX_PRIORITIES</code> 编译时配置常量设置。低数字优先级值表示低优先级任务，优先级 0 是可能的最低优先级。因此，可用优先级的范围是 0 到 ( <code>configMAX_PRIORITIES</code> – 1)。   任意数量的任务可以共享相同的优先级 —— 确保最大的设计灵活性。</p>
<p>FreeRTOS 调度程序可以使用两种方法之一来决定哪个任务将处于运行状态。 <code>configMAX_PRIORITIES</code> 可以设置的最大值取决于所使用的方法：</p>
<ol>
<li><p>通用方法：通用方法在 C 中实现，可以与所有 FreeRTOS 架构移植一起使用。</p>
<p>使用通用方法时，FreeRTOS 不会限制 <code>configMAX_PRIORITIES</code> 可以设置的最大值。 但是，始终建议将 <code>configMAX_PRIORITIES</code> 值保持在必要的最小值，因为该值越高，消耗的 RAM 就越多，并且最坏情况下的执行时间也就越长。</p>
<p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 0，或者如果 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 未定义，或者通用方法是为正在使用的 FreeRTOS 移植提供的唯一方法，则将使用通用方法。</p>
</li>
<li><p>架构优化方法：</p>
<p>体系结构优化方法使用少量汇编代码，并且比通用方法更快。 <code>configMAX_PRIORITIES</code> 置不会影响最坏情况下的执行时间。</p>
<p>如果使用架构优化方法，则 <code>configMAX_PRIORITIES</code> 不能大于 32。与通用方法一样，建议将 <code>configMAX_PRIORITIES</code> 保持在必要的最小值，因为其值越高，消耗的 RAM 就越多。</p>
<p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 设置为 1，则将使用架构优化方法。并非所有 FreeRTOS 移植都提供架构优化方法。</p>
</li>
</ol>
<p>FreeRTOS 调度程序将始终确保能够运行的最高优先级任务是选择进入运行状态的任务。 当多个具有相同优先级的任务能够运行时，调度程序将依次将每个任务转入和转出运行状态。</p>
<h2 id="3-6-时间测量和嘀嗒中断"><a href="#3-6-时间测量和嘀嗒中断" class="headerlink" title="3.6 时间测量和嘀嗒中断"></a>3.6 时间测量和嘀嗒中断</h2><p>第 3.12 节 “调度算法” 描述了一个名为 “时间切片 ( time slicing )” 的可选功能。 到目前为止所提供的示例中使用了时间切片，并且是在它们生成的输出中观察到的行为。在示例中，两个任务都是以相同的优先级创建的，并且两个任务始终能够运行。 因此，每个任务执行一个 <code>"时间片 ( time slice )"</code>，在时间片开始时进入运行状态，在时间片结束时退出运行状态。在图 11 中，t1 和 t2 之间的时间等于单个时间片。</p>
<p>为了能够选择下一个要运行的任务，调度程序本身必须在每个时间片 <strong>[1]</strong> 的末尾执行。称为 <code>"嘀嗒中断 ( tick interrupt )"</code> 的周期性中断用于此目的。时间片的长度由嘀嗒中断频率有效地设置，该频率由 <code>FreeRTOSConfig.h</code> 中应用程序定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100 (Hz)，则时间片将为 10 毫秒。两次嘀嗒中断之间的时间称为 <code>"嘀嗒周期 (tick period)"</code>。   一个时间片等于一个嘀嗒周期。</p>
<blockquote>
<p>[1] : 需要注意的是，时间片的末尾并不是调度程序可以选择运行新任务的唯一位置；正如本书将演示的那样，在当前正在执行的任务进入阻塞状态后，或者当中断将更高优先级的任务移至就绪状态时，调度程序还将选择一个新任务立即运行。</p>
</blockquote>
<p>为了能够选择要运行的下一个任务，调度程序本身必须在每个时间片的末尾执行。 称为 “嘀嗒中断” 的周期性中断用于此目的。 时间片的长度由嘀嗒中断频率有效设置，嘀嗒中断频率由应用程序在 <code>FreeRTOSConfig.h</code> 中定义的 <code>configTICK_RATE_HZ</code> 编译时配置常量配置。 例如，如果 <code>configTICK_RATE_HZ</code> 设置为 100（Hz），则时间片将为 10 毫秒。 两次嘀嗒中断之间的时间称为 “嘀嗒期”。 一个时间片等于一个嘀嗒时间段。</p>
<p>图 11 可以展开来显示调度程序本身在执行序列中的执行情况。如图 12 所示，其中顶部行显示调度程序何时执行，细箭头显示从任务到嘀嗒中断，然后从嘀嗒中断返回到不同任务的执行顺序。</p>
<p><code>configTICK_RATE_HZ</code> 的最佳值取决于正在开发的应用程序，但其值通常为 100。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240527235850366.png" alt="图 12. 执行序列展开以显示嘀嗒中断执行"></p>
<p>FreeRTOS API 调用始终以嘀嗒周期的倍数指定时间，这通常被简单地称为嘀嗒。<code>pdMS_TO_TICKS()</code> 宏将以毫秒为单位的时间转换为以嘀嗒为单位的时间。可用的分辨率取决于定义的嘀嗒频率，如果嘀嗒频率高于 1 KHz (<code>configTICK RATE HZ</code> 大于 1000)，则不能使用 <code>pdMS_TO_TICKS()</code>。则无法使用 <code>pdMS_TO_TICKS()</code>。清单 20 显示了如何使用 <code>pdMS_TO_TICKS()</code> 将指定为 200 毫秒的时间转换为以嘀嗒为单位指定的等效时间。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pdMS_TO_TICKS() 将以毫秒为单位的时间作为其唯一参数，并计算为以嘀嗒周期为单位的等效时间。 </span></span><br><span class="line"><span class="comment">此示例显示 xTimeInTicks 设置为等于 200 毫秒的嘀嗒周期数。 */</span></span><br><span class="line">TickType_t xTimeInTicks = pdMS_TO_TICKS( <span class="number">200</span> );</span><br></pre></td></tr></tbody></table></figure>

<p>清单 20. 使用 <code>pdMS_TO_TICKS()</code> 宏将 200 毫秒转换为嘀嗒周期中的等效时间</p>
<blockquote>
<p>注意 : 不建议在应用程序中直接以嘀嗒为单位指定时间，而是使用 <code>pdMS_TO_TICKS()</code> 宏来指定以毫秒为单位的时间，这样做可以确保如果嘀嗒频率发生变化，应用程序中指定的时间不会发生变化。</p>
</blockquote>
<p><code>"嘀嗒计数 ( tick count )"</code> 值是自调度器启动以来发生的嘀嗒中断的总数，假设嘀嗒计数没有溢出。用户应用程序在指定延迟周期时不必考虑溢出，因为时间一致性由 FreeRTOS 内部管理。</p>
<p>第 3.12 节 “调度算法” 描述了影响调度程序何时选择要运行的新任务以及何时执行嘀嗒中断的配置常量。</p>
<h3 id="示例-3-使用优先级进行实验"><a href="#示例-3-使用优先级进行实验" class="headerlink" title="示例 3. 使用优先级进行实验"></a>示例 3. 使用优先级进行实验</h3><p>调度程序将始终确保能够运行的最高优先级任务是被选择进入运行状态的任务。 到目前为止，在我们的示例中，已经以相同的优先级创建了两个任务，因此它们是依次进入和退出运行状态的。 此示例研究当示例 2 中创建的两个任务之一的优先级发生更改时会发生什么情况。 这次，第一个任务将以优先级 1 创建，第二个任务将以优先级 2 创建。创建任务的代码如清单 21 所示。实现这两个任务的单个函数没有改变；它仍然只是定期打印出一个字符串，使用空循环来创建延迟。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义将作为任务参数传入的字符串。</span></span><br><span class="line"><span class="comment">它们被定义为 const 并且不在堆栈上，以确保它们在任务执行时保持有效。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask1 = <span class="string">"Task 1 is running\r\n"</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask2 = <span class="string">"Task 2 is running\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 以优先级 1 创建第一个任务。优先级是倒数第二个参数。 */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="string">"Task 1"</span>, <span class="number">1000</span>, (<span class="type">void</span>*)pcTextForTask1, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以优先级 2 创建第二个任务，该任务高于优先级 1。优先级是倒数第二个参数。。 */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="string">"Task 2"</span>, <span class="number">1000</span>, (<span class="type">void</span>*)pcTextForTask2, <span class="number">2</span>, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动调度程序以便任务开始执行。 */</span></span><br><span class="line">    vTaskStartScheduler();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不会到达这里。 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 21. 创建两个不同优先级的任务</p>
<p>示例 3 生成的输出如图 13 所示。</p>
<p>调度程序将始终选择能够运行的最高优先级任务。 任务 2 的优先级高于任务 1，并且始终能够运行；因此，任务 2 是唯一进入运行状态的任务。 由于任务 1 永远不会进入运行状态，因此它永远不会打印出其字符串。则称任务1被任务2 “ 剥夺 “ 了处理时间。( Task 1 is said to be ‘starved’ of processing time by Task 2.  )</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240529001654557.png" alt="图 13. 以不同优先级运行两个任务"></p>
<p>任务2总是能够运行，因为它永远不需要等待任何东西  —— 它要么是在一个空循环中循环，要么打印到终端。</p>
<p>图 14 显示了示例 3 的执行顺序。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240529001913254.png" alt="图 14. 当一个任务的优先级高于另一个任务时的执行模式"></p>
<h2 id="3-7-展开说明-“-非运行-“-状态"><a href="#3-7-展开说明-“-非运行-“-状态" class="headerlink" title="3.7 展开说明 “ 非运行 “ 状态"></a>3.7 展开说明 “ 非运行 “ 状态</h2><p>到目前为止，创建的任务总是有处理要执行，并且不需要等待任何事情 —— 因为它们不需要等待任何事情，所以它们总是能够进入运行状态。这种类型的 “ 连续处理 ( continuous processing ) “ 任务的用途有限，因为它们只能以最低优先级创建。如果它们以任何其他优先级运行，它们将完全阻止优先级较低的任务运行。</p>
<p>为了使任务有用，必须重写它们以使其成为事件驱动的。 事件驱动的任务只有在触发它的事件发生后才能执行工作 ( 处理 )，并且在该事件发生之前无法进入运行状态。 调度程序始终选择能够运行的最高优先级任务。高优先级任务无法运行意味着调度程序无法选择它们，而必须选择能够运行的较低优先级任务。 因此，使用事件驱动的任务意味着可以以不同的优先级创建任务，而最高优先级的任务不会耗尽所有较低优先级的任务的处理时间。</p>
<h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>正在等待事件的任务被认为处于 <code>"阻塞 ( Blocked ) "</code> 状态，这是 <code>"非运行 ( No Running ) "</code> 状态的子状态。</p>
<p>任务可以进入阻止状态以等待两种不同类型的事件:</p>
<ol>
<li>时间 ( 与时间相关 time-related ) 事件 Temporal events —— 该事件要么是延迟期到期，要么是达到绝对时间。例如，任务可能会进入阻塞状态，等待 10 毫秒过去。</li>
<li>同步事件 Synchronization events —— 事件源自另一个任务或中断。例如，任务可能会进入阻塞状态以等待数据到达队列。   同步事件涵盖了广泛的事件类型。</li>
</ol>
<p>FreeRTOS 的队列，二进制信号量，计数信号量，互斥量，递归互斥量，事件组和直接到任务通知都可用于创建同步事件。 所有这些功能都将在本书的后续章节中介绍。</p>
<p>任务可以在具有超时的同步事件上阻塞，从而有效地同时阻塞两种类型的事件。例如，任务可以选择等待最多 10 毫秒以便数据到达队列。如果 10 毫秒内有数据到达，或者 10 毫秒后没有数据到达，任务将离开阻塞状态。</p>
<h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p><code>" 暂停 ( Suspended ) "</code> 也是 <code>"非运行 ( No Running ) "</code> 状态的子状态。 处于暂停状态的任务对调度程序是不可用的。 进入暂停状态的唯一方法是通过调用 <code>vTaskSuspend()</code> API 函数，退出暂停状态的唯一方法是通过调用 <code>vTaskResume()</code> 或 <code>xTaskResumeFromISR()</code> API 函数。大多数应用程序不使用暂停状态。</p>
<h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><p>处于 “未运行” 状态但未被阻塞或挂起的任务被称为处于 “就绪” 状态。 它们能够运行，因此 “准备好” 运行，但当前不处于 “运行” 状态。</p>
<p>处于 <code>"非运行 ( No Running )"</code> 状态但未被 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 的任务被称为 <code>"就绪 ( Ready ) "</code> 状态。它们能够运行，因此 “准备 ( ready ) “ 运行，但目前不处于 <code>"运行 ( Running ) "</code> 状态。</p>
<h3 id="完成状态转换图"><a href="#完成状态转换图" class="headerlink" title="完成状态转换图"></a>完成状态转换图</h3><p>图 15 扩展了之前过于简化的状态图，以包含本节中描述的所有<code>"非运行 ( No Running )"</code>子状态。到目前为止，示例中创建的任务尚未使用 <code>"阻塞 ( Blocked ) "</code> 或 <code>" 暂停 ( Suspended ) "</code> 状态；它们仅在  <code>"就绪 ( Ready ) "</code> 状态和 <code>"运行 ( Running ) "</code> 状态之间转换 —— 在图 15 中用粗线突出显示。</p>
<img src="image-20240529231955847.png" alt="图 15. 完整任务状态机" style="zoom:67%;">



<h3 id="示例-4-使用阻塞状态创建延迟"><a href="#示例-4-使用阻塞状态创建延迟" class="headerlink" title="示例 4. 使用阻塞状态创建延迟"></a>示例 4. 使用阻塞状态创建延迟</h3><p>到目前为止，示例中创建的所有任务都是 “周期性的”——它们会延迟一段时间并打印出字符串，然后再延迟一次，依此类推。延迟是使用空循环非常粗略地生成的 —— 任务有效地轮询一个递增的循环计数器，直到它达到固定值。示例 3 清楚地展示了这种方法的缺点。优先级较高的任务在执行空循环时始终保持运行状态，” 剥夺 ( starving ) “ 了优先级较低的任务的任何处理时间。</p>
<p>任何形式的轮询都存在其他一些缺点，其中最主要的是效率低下。在轮询期间，任务实际上没有任何工作要做，但它仍然使用最长的处理时间，因此浪费了处理器周期。示例 4 通过将轮询空循环替换为对 <code>vTaskDelay()</code> API 函数的调用来纠正此行为，该函数的原型如清单 22 所示。新任务定义如清单 23 所示。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelay</code> 设置为 1 时，<code>vTaskDelay()</code> API 函数才可用。</p>
<p><code>vTaskDelay()</code> 将调用任务置于阻塞状态，并持续固定数量的嘀嗒中断。任务处于阻塞状态时不使用任何处理时间，因此任务仅在实际有工作要做时才使用处理时间。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( TickType_txTicksToDelay )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 22. <code>vTaskDelay()</code> 的函数原型</p>
<p>表 9. <code>vTaskDelay()</code> 参数 </p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xTicksToDelay</code></td>
<td>调用任务在转换回就绪状态之前将保持在阻塞状态的嘀嗒中断数。<br>例如，调用 <code>vTaskDelay(pdMS_TO_TICKS(100))</code> 将导致调用任务保持阻塞状态 100 毫秒。<p></p>例如，如果一个任务在嘀嗒 ( tick ) 计数为 <code>10,000</code> 时调用 <code>vTaskDelay( 100 )</code>，那么它将立即进入阻塞状态，并保持阻塞状态，直到嘀嗒 ( tick ) 计数达到 <code>10,100</code>。</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span> </span><br><span class="line">{ </span><br><span class="line"><span class="type">char</span> *pcTaskName; </span><br><span class="line"><span class="type">const</span> TickType_t xDelay250ms = pdMS_TO_TICKS( <span class="number">250</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟一段时间。这次调用 vTaskDelay()，将任务置于阻塞状态，直到延迟时间到期。</span></span><br><span class="line"><span class="comment">        该参数采用以 "ticks" 为单位指定的时间，并使用 pdMS_TO_TICKS() 宏 </span></span><br><span class="line"><span class="comment">        ( 其中声明了 xDelay250ms 常量 ) 将 250 毫秒转换为以 ticks 为单位的等效时间。*/</span></span><br><span class="line">        vTaskDelay( xDelay250ms );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 23. 空循环延迟已被 <code>vTaskDelay()</code> 调用替换后的示例任务的源代码</p>
<p>尽管这两个任务仍以不同的优先级创建，但现在它们都将运行。示例 4 的输出（如图 16 所示）证实了预期的行为。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240605201928489.png" alt="图 16. 执行示例 4 时产生的输出"></p>
<p>图 17 所示的执行序列解释了为什么两个任务都会运行，即使它们是以不同的优先级创建的。为简单起见，这里省略了调度程序本身的执行。</p>
<p>空闲任务在调度程序启动时自动创建，以确保始终至少有一个任务可以运行 ( 至少有一个任务处于就绪状态 ) 。第 3.8 节 空闲任务和空闲任务钩子 更详细地描述了空闲任务。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240605202818532.png" alt="图 17. 任务使用 vTaskDelay() 代替空循环时的执行顺序"></p>
<p>这两个任务只有实现方式发生了变化，功能没有变化。将图 17 与图 12 进行比较可以清楚地看出，此功能是以更高效的方式实现的。</p>
<p>图 12 显示了当任务使用空循环来创建延迟时的执行模式——始终运行，因此在任务之间使用百分之百的可用处理器时间。 图 17 显示了任务在整个延迟期间进入阻塞状态时的执行模式，因此只有当它们确实有需要执行的工作时 ( 在本例中只是一条要打印出来的消息 ) 才会使用处理器时间，因此仅使用可用处理时间的一小部分。</p>
<p>在图 17 的场景中，每次任务离开阻塞状态时，它们都会执行一小段时钟周期，然后重新进入阻塞状态。大多数时候，没有应用程序任务可以运行 ( 没有应用程序任务处于就绪状态 ) ，因此，没有应用程序任务可以选择进入运行状态。在这种情况下，空闲任务将运行。分配给空闲任务的处理时间量是系统中备用处理能力的衡量标准。使用 RTOS 可以显著增加备用处理能力，只需允许应用程序完全由事件驱动即可。</p>
<p>图 18 中的粗线显示了示例 4 中的任务执行的转换，每个任务现在都经过阻塞状态，然后返回到就绪状态。</p>
<img src="image-20240605235232308.png" alt="图 18. 粗线表示示例 4 中的任务执行的状态转换" style="zoom:67%;">



<h3 id="vTaskDelayUntil-API-函数"><a href="#vTaskDelayUntil-API-函数" class="headerlink" title="vTaskDelayUntil() API 函数"></a>vTaskDelayUntil() API 函数</h3><p><code>vTaskDelayUntil()</code> 与 <code>vTaskDelay()</code> 类似。正如刚才所演示的，<code>vTaskDelay()</code> 参数指定在调用 <code>vTaskDelay()</code> 的任务和同一任务再次退出阻塞状态之间应发生的嘀嗒 ( tick ) 中断数。任务保持阻塞状态的时间长度由 <code>vTaskDelay()</code> 参数指定，但任务离开阻塞状态的时间与调用 <code>vTaskDelay()</code> 的时间有关。</p>
<p>相反，<code>vTaskDelayUntil()</code> 的参数指定调用任务应从阻塞状态移至就绪状态的确切嘀嗒 ( tick ) 计数值。<code>vTaskDelayUntil()</code> 是当需要固定执行周期 ( 您希望任务以固定频率定期执行 ) 时应使用的 API 函数，因为调用任务被解除阻塞的时间是绝对的，而不是相对于调用函数的时间 ( 与 <code>vTaskDelay()</code> 的情况一样 ) 。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( TickType_t* pxPreviousWakeTime, TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 24. <code>vTaskDelayUntil()</code> API 函数原型</p>
<p>表 10. <code>vTaskDelayUntil()</code> 的参数</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxPreviousWakeTime</code></td>
<td>此参数的命名基于以下假设：<code>vTaskDelayUntil()</code> 用于实现定期且以固定频率执行的任务。在这种情况下，<code>pxPreviousWakeTime</code> 保存任务上次离开阻塞状态 ( 被 <code>" 唤醒 ( woken ) "</code> ) 的时间。此时间用作参考点，以计算任务下次离开阻塞状态的时间。<br><code>pxPreviousWakeTime</code> 指向的变量在 <code>vTaskDelayUntil()</code> 函数中自动更新；它通常不会被应用程序代码修改，但在第一次使用之前必须初始化为当前嘀嗒计数。清单 25 演示了如何执行初始化。</td>
</tr>
<tr>
<td><code>xTimeIncrement</code></td>
<td>此参数的命名也是基于这样的假设：<code>vTaskDelayUntil()</code> 用于实现定期执行且具有固定频率 ( 由 <code>xTimeIncrement</code> 值设置的频率 ) 的任务。</td>
</tr>
</tbody></table>
<h3 id="示例-5-将示例任务转换为使用-vTaskDelayUntil"><a href="#示例-5-将示例任务转换为使用-vTaskDelayUntil" class="headerlink" title="示例 5. 将示例任务转换为使用 vTaskDelayUntil()"></a>示例 5. 将示例任务转换为使用 vTaskDelayUntil()</h3><p>示例 4 中创建的两个任务是周期性任务，但是使用 <code>vTaskDelay()</code> 并不保证它们运行的频率是固定的，因为任务离开阻塞状态的时间与它们调用 <code>vTaskDelay()</code> 的时间相关。 将任务转换为使用<code>vTaskDelayUntil()</code> 而不是 <code>vTaskDelay()</code> 可以解决这个潜在的问题。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> *pcTaskName;</span><br><span class="line">TickType_t xLastWakeTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要使用当前嘀嗒计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。</span></span><br><span class="line"><span class="comment">    此后，xLastWakeTime 将在 vTaskDelayUntil() 中自动更新。 */</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个任务应该精确地每 250 毫秒执行一次。根据 vTaskDelay() 函数，时间是以嘀嗒为</span></span><br><span class="line"><span class="comment">        单位度量的，pdMS_TO_TICKS() 宏用于将毫秒转换为嘀嗒。xLastWakeTime 在 </span></span><br><span class="line"><span class="comment">        vTaskDelayUntil() 中自动更新，因此任务不会显式地更新 xLastWakeTime。 */</span></span><br><span class="line">        vTaskDelayUntil( &amp;xLastWakeTime, pdMS_TO_TICKS( <span class="number">250</span> ));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 25. 使用 <code>vTaskDelayUntil()</code> 实现示例任务</p>
<p>示例 5 产生的输出与图 16 中的示例 4 所示的输出完全相同。</p>
<h3 id="示例-6-组合阻塞和非阻塞任务"><a href="#示例-6-组合阻塞和非阻塞任务" class="headerlink" title="示例 6. 组合阻塞和非阻塞任务"></a>示例 6. 组合阻塞和非阻塞任务</h3><p>前面的示例已经单独检查了轮询和阻塞任务的行为。该示例通过演示两个方案组合时的执行序列来重新实施所述的预期系统行为，如下所述。</p>
<ol>
<li><p>创建两个优先级为 1 的任务。它们除了连续打印出一个字符串之外不执行任何操作。</p>
<p>这些任务从不进行任何可能导致它们进入阻塞状态的 API 函数调用，因此始终处于就绪状态或运行状态。这种性质的任务被称为 <code>" 连续处理 ( continuous processing ) "</code> 任务，因为它们总是有工作要做（尽管在这种情况下是相当琐碎的工作）。清单 26 显示了连续处理任务的源代码。</p>
</li>
<li><p>然后创建优先级为 2 的第三个任务，因此优先级高于其他两个任务。第三个任务也只是打印出一个字符串，但这次是定期打印的，所以使用 <code>vTaskDelayUntil()</code> API 函数在每次打印迭代之间将自己置于阻塞状态。</p>
</li>
</ol>
<p>周期性任务的源代码如清单 27 所示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vContinuousProcessingTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> *pcTaskName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。此任务只是重复执行此操作，不会阻塞或延迟。 */</span></span><br><span class="line">        vPrintString( pcTaskName );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 26. 示例 6 中使用的连续处理任务</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPeriodicTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line">TickType_t xLastWakeTime;</span><br><span class="line"><span class="type">const</span> TickType_t xDelay3ms = pdMS_TO_TICKS( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要使用当前滴答计数初始化 xLastWakeTime 变量。注意，这是唯一一次显式地写入变量。</span></span><br><span class="line"><span class="comment">    在此之后，xLastWakeTime 由 vTaskDelayUntil() API 函数自动管理。 */</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，该任务是在一个无限循环中实现的。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( <span class="string">"Periodic task is running\r\n"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 该任务应每 3 毫秒准确执行一次 - 请参阅此函数中 xDelay3ms 的声明。 */</span></span><br><span class="line">        vTaskDelayUntil( &amp;xLastWakeTime, xDelay3ms);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 27. 示例 6 中使用的周期性任务</p>
<p>图 19 显示了示例 6 产生的输出，并解释了图 20 中显示的执行序列所观察到的行为。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240609003733891.png" alt="图 19. 执行示例 6 时产生的输出"></p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240609004733190.png" alt="图 20. 示例 6 的执行模式"></p>
<h2 id="3-8-空闲任务和空闲任务钩子"><a href="#3-8-空闲任务和空闲任务钩子" class="headerlink" title="3.8 空闲任务和空闲任务钩子"></a>3.8 空闲任务和空闲任务钩子</h2><p>示例 4 中创建的任务大部分时间处于阻塞状态。处于此状态时，它们无法运行，因此无法被调度程序选中。</p>
<p>必须始终至少有一个任务可以进入运行状态 [1] 。为确保这种情况，在调用 <code>vTaskStartScheduler()</code> 时，调度程序会自动创建一个空闲任务。空闲任务除了处于循环中之外几乎不执行其他操作 — 因此，与最初第一个示例中的任务一样，它始终能够运行。</p>
<blockquote>
<p>[1] : 即使在使用 FreeRTOS 的特殊低功耗功能时也是如此，在这种情况下，如果应用程序创建的任务都无法执行，则执行 FreeRTOS 的微控制器将进入低功耗模式。</p>
</blockquote>
<p>空闲任务具有可能的最低优先级 ( 优先级为零 ) ，以确保它永远不会阻止更高优先级的应用程序任务进入运行状态 —— 尽管没有什么可以阻止应用程序设计人员在空闲任务优先级上创建任务，从而共享空闲任务优先级 ( 如果需要 ) ，<code>FreeRTOSConfig.h</code> 中的 <code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于防止空闲任务消耗处理时间，而这些时间可以更有效地分配给应用程序任务。<code>configIDLE_SHOULD_YIELD</code> 在第 3.12 节 “ 调度算法 “ 中进行了描述。</p>
<p>以最低优先级运行可确保只要优先级较高的任务进入就绪状态，空闲任务就会从运行状态转移出来。 这可以在图 17 中的时间点看到，其中空闲任务被立即换出以允许任务 2 在任务 2 离开被阻止状态的瞬间执行。 据说任务 2 已经抢占了空闲任务。 抢先自动发生，并且不知道任务被抢占。</p>
<p>以最低优先级运行可确保空闲任务在更高优先级任务进入就绪状态时立即退出运行状态。这可以在图 17 中的时间 tn 处看到，其中空闲任务立即被换出，以允许任务 2 在任务 2 离开阻塞状态的瞬间执行。则称任务 2 已抢占 ( pre-empted ) 空闲任务。抢占是自动发生的，被抢占的任务对此并不知情。Pre-emption occurs automatically, and without the knowledge of the task being pre-empted.</p>
<p>如果应用程序使用 <code>vTaskDelete()</code> API 函数，那么空闲任务就不会浪费处理时间。这是因为空闲任务负责在删除任务之后清理内核资源。</p>
<blockquote>
<p>注意 : 注意：如果应用程序使用 vTaskDelete() API 函数，则空闲任务不能缺少处理时间，这一点至关重要。这是因为空闲任务负责在删除任务后清理内核资源。</p>
</blockquote>
<h3 id="空闲任务钩子函数"><a href="#空闲任务钩子函数" class="headerlink" title="空闲任务钩子函数"></a>空闲任务钩子函数</h3><p>可以通过使用空闲钩子 idle hook ( 或空闲回调 idle callback ) 函数将特定于应用程序的功能直接添加到空闲任务中 —— 该函数在空闲任务循环的每次迭代中由空闲任务自动调用一次。</p>
<p>空闲任务钩子的常见用途包括：</p>
<ul>
<li><p>执行低优先级、后台或连续处理功能。</p>
</li>
<li><p>测量备用处理能力的数量。（当所有优先级较高的应用程序任务无法执行时，空闲任务将会运行；因此，测量分配给空闲任务的处理时间量可清楚地指示多少处理时间。）</p>
<p>测量空闲处理能力的数量。( 只有当所有优先级较高的应用程序任务都没有工作要执行时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地表明有多少空闲处理时间。)</p>
</li>
<li><p>将处理器置于低功耗模式，提供一种在没有应用程序处理需要执行时节省电量的简单而自动的方法 ( 尽管使用此方法可以实现的电量节省效果不如使用第 10 章 “ 低功耗支持 “ 中描述的无滴答空闲模式  tick-less idle mode 可以实现的电量节省效果 ) 。</p>
</li>
</ul>
<h3 id="对空闲任务钩子函数实现的限制"><a href="#对空闲任务钩子函数实现的限制" class="headerlink" title="对空闲任务钩子函数实现的限制"></a>对空闲任务钩子函数实现的限制</h3><p>空闲任务钩子函数必须遵守以下规则。</p>
<ol>
<li><p>空闲任务钩子函数绝不能尝试阻塞或暂停。</p>
<blockquote>
<p>注意 : 以任何方式阻塞空闲任务都可能导致没有可用任务进入运行状态的情况。</p>
</blockquote>
</li>
<li><p>如果应用程序使用了 <code>vTaskDelete()</code> API函数，则空闲任务钩子必须始终在合理的时间段内返回其调用者。这是因为空闲任务负责在任务被删除后清理内核资源。如果空闲任务永久地保持在空闲钩子函数中，则无法进行清理。</p>
</li>
</ol>
<p>空闲任务钩子函数必须具有清单 28 所示的名称和原型。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 28. 空闲任务钩子函数名称和原型</p>
<h3 id="示例-7-定义一个空闲任务钩子函数"><a href="#示例-7-定义一个空闲任务钩子函数" class="headerlink" title="示例 7. 定义一个空闲任务钩子函数"></a>示例 7. 定义一个空闲任务钩子函数</h3><p>示例 4 中使用阻塞 vTaskDelay() API 调用会产生大量空闲时间 — 因为两个应用程序任务都处于阻塞状态，所以空闲任务正在执行的时间。示例 7 通过添加空闲钩子函数来利用此空闲时间，其源代码如清单 29 所示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明一个将由钩子函数递增的变量。 */</span></span><br><span class="line"><span class="keyword">volatile</span> uint32_tulIdleCycleCount = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 空闲钩子函数必须命名为 vApplicationIdleHook()，不带参数，并且返回 void。 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 这个钩子函数除了递增计数器外什么都不做。 */</span></span><br><span class="line">    ulIdleCycleCount++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 29. 一个非常简单的空闲钩子函数</p>
<p>必须在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_IDLE_HOOK</code> 设置为 1，才能调用空闲挂钩函数。</p>
<p>对实现创建任务的函数稍加修改，以打印出 <code>ulIdleCycleCount</code> 值，如清单 30 所示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> *pcTaskName;</span><br><span class="line"><span class="type">const</span> TickType_t xDelay250ms = pdMS_TO_TICKS( <span class="number">250</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要打印的字符串通过参数传入。将其强制转换为字符指针。 */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 与大多数任务一样，此任务在无限循环中实现。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称和 ulIdleCycleCount 已增加的次数。 */</span></span><br><span class="line">        vPrintStringAndNumber( pcTaskName, ulIdleCycleCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 延迟 250 毫秒。 */</span></span><br><span class="line">        vTaskDelay( xDelay250ms);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 30. 示例任务的源代码现在打印出 <code>ulIdleCycleCount</code> 值</p>
<p>示例 7 产生的输出如图 21 所示。 因此，在应用任务的每次迭代之间，空闲任务钩子函数被调用大约 400 万次（迭代次数取决于演示执行的硬件的速度）。</p>
<p>示例 7 产生的输出如图 21 所示。它表明空闲任务钩子函数在应用程序任务的每次迭代之间被调用大约 400 万次 ( 迭代次数取决于执行演示的硬件的速度 ) 。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240609143325610.png" alt="图 21. 执行示例 7 时产生的输出"></p>
<h2 id="3-9-更改任务的优先级"><a href="#3-9-更改任务的优先级" class="headerlink" title="3.9 更改任务的优先级"></a>3.9 更改任务的优先级</h2><h3 id="vTaskPrioritySet-API-函数"><a href="#vTaskPrioritySet-API-函数" class="headerlink" title="vTaskPrioritySet() API 函数"></a>vTaskPrioritySet() API 函数</h3><p><code>vTaskPrioritySet()</code> API 函数可用于在调度程序启动后更改任何任务的优先级。请注意，当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数是可用的。</p>
<p>启动调度程序后，可以使用 <code>vTaskPrioritySet()</code> API 函数来更改任何任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时，<code>vTaskPrioritySet()</code> API 函数才可用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t pxTask, UBaseType_t uxNewPriority )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 31. <code>vTaskPrioritySet()</code> API 函数原型</p>
<p>表 11. <code>vTaskPrioritySet()</code> 参数</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTask</code></td>
<td>正在修改其优先级的任务 ( 主题任务 the subject task ) 的句柄—— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来更改自己的优先级。</td>
</tr>
<tr>
<td><code>uxNewPriority</code></td>
<td>主题任务要设置的优先级。该优先级自动限制在最大可用优先级 ( <code>configMAX_PRIORITIES - 1</code> ) 内，其中 <code>configMAX_PRIORITIES</code> 是 <code>FreeRTOSConfig.h</code> 头文件中设置的编译时常量。</td>
</tr>
</tbody></table>
<h3 id="uxTaskPriorityGet-API-函数"><a href="#uxTaskPriorityGet-API-函数" class="headerlink" title="uxTaskPriorityGet() API 函数"></a>uxTaskPriorityGet() API 函数</h3><p><code>uxTaskPriorityGet()</code> API 函数可用于查询任务的优先级。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_uxTaskPriorityGet</code> 设置为 1 时，<code>uxTaskPriorityGet()</code> API 函数才可用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( TaskHandle_t pxTask )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 32. <code>uxTaskPriorityGet()</code> API 函数原型</p>
<p>表 12. <code>uxTaskPriorityGet()</code> 参数和返回值</p>
<table>
<thead>
<tr>
<th>参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTask</code></td>
<td>正在查询其优先级的任务 ( 主题任务 ) 的句柄 —— 有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 以代替有效的任务句柄来查询自己的优先级。</td>
</tr>
<tr>
<td>返回值</td>
<td>当前分配给正在查询的任务的优先级。</td>
</tr>
</tbody></table>
<h3 id="示例-8-更改任务优先级"><a href="#示例-8-更改任务优先级" class="headerlink" title="示例 8. 更改任务优先级"></a>示例 8. 更改任务优先级</h3><p>调度程序将始终选择最高 ( 优先级 ) 就绪状态的任务作为进入运行状态的任务。示例 8 通过使用 <code>vTaskPrioritySet()</code> API 函数更改两个任务相对于彼此的优先级来演示这一点。</p>
<p>示例 8 创建了两个优先级不同的任务。两个任务均未进行任何可能导致其进入阻塞状态的 API 函数调用，因此它们始终处于就绪状态或运行状态。因此，具有最高相对优先级的任务将始终是调度程序选择处于运行状态的任务。</p>
<p>示例 8 的行为如下：</p>
<ol>
<li><p>任务 1 ( 清单 33 ) 创建时具有最高优先级，因此保证首先运行。 任务 1 在将任务 2 ( 清单 34 ) 的优先级提高到高于自己的优先级之前打印出几个字符串。</p>
</li>
<li><p>任务 2 一旦具有最高相对优先级就开始运行（进入运行状态）。 任何时候只有一个任务可以处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p>
<p>任务 2 一旦具有最高的相对优先级，就会开始运行 ( 进入运行状态 ) 。任何时刻只能有一个任务处于运行状态，因此当任务 2 处于运行状态时，任务 1 处于就绪状态。</p>
</li>
<li><p>任务 2 在将自己的优先级设置回低于任务 1 的优先级之前打印出一条消息。</p>
</li>
<li><p>任务 2 将自己的优先级调低意味着任务 1 再次成为最高优先级任务，因此任务 1 重新进入运行状态，迫使任务 2 回到就绪状态。</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line">UBaseType_t uxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此任务将始终在任务 2 之前运行，因为它以更高的优先级创建。</span></span><br><span class="line"><span class="comment">    任务 1 和任务 2 都不会阻塞，因此两者始终处于正在运行或就绪状态。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " 。 */</span></span><br><span class="line">    uxPriority = uxTaskPriorityGet( <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( <span class="string">"Task 1 is running\r\n"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务 2 的优先级设置为高于任务 1 的优先级将导致任务 2 立即开始运行 </span></span><br><span class="line"><span class="comment">        ( 因为任务 2 的优先级在两个创建的任务中更高 ) 。</span></span><br><span class="line"><span class="comment">        请注意在调用 vTaskPrioritySet() 时使用任务 2 的句柄 (xTask2Handle)。</span></span><br><span class="line"><span class="comment">        清单 35 显示了如何获取句柄。*/</span></span><br><span class="line">        vPrintString( <span class="string">"About to raise the Task 2 priority\r\n"</span> );</span><br><span class="line">        vTaskPrioritySet( xTask2Handle, ( uxPriority + <span class="number">1</span> ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务 1 只有在优先级高于任务 2 时才会运行。因此，要使此任务达到此点，</span></span><br><span class="line"><span class="comment">        任务 2 必须已经执行，并将其优先级重新设置回低于此任务的优先级。 */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 33. 示例 8 中任务 1 的实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line">UBaseType_t uxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务 1 将始终在此任务之前运行，因为任务 1 的创建优先级更高。</span></span><br><span class="line"><span class="comment">    任务 1 和任务 2 都不会阻塞，因此将始终处于正在运行或就绪状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    查询此任务运行的优先级 - 传入 NULL 表示 " 返回调用任务的优先级 " */</span></span><br><span class="line">    uxPriority = uxTaskPriorityGet( <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 要使此任务达到此点，任务 1 必须已经运行，并将此任务的优先级设置为高</span></span><br><span class="line"><span class="comment">        于其自身的优先级。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        打印出此任务的名称。 */</span></span><br><span class="line">        vPrintString( <span class="string">"Task 2 is running\r\n"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 传入 NULL 作为任务句柄意味着 " 更改调用任务的优先级 "。</span></span><br><span class="line"><span class="comment">        将优先级设置为低于任务 1 的优先级将导致任务 1 立即再次开始运行 </span></span><br><span class="line"><span class="comment">        - 抢占此任务。*/</span></span><br><span class="line">        vPrintString( <span class="string">"About to lower the Task 2 priority\r\n"</span> );</span><br><span class="line">        vTaskPrioritySet( <span class="literal">NULL</span>, ( uxPriority - <span class="number">2</span>) );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 34. 示例 8 中任务 2 的实现</p>
<p>每个任务都可以查询和设置自己的优先级，而无需使用有效的任务句柄，只需使用 <code>NULL</code> 即可。只有当任务希望引用除自身之外的其他任务时，才需要任务句柄，例如当任务 1 更改任务 2 的优先级时。为了允许任务 1 执行此操作，在创建任务 2 时获取并保存任务 2 句柄，如清单 35 中的注释中突出显示的那样。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明一个用于保存任务 2 的句柄的变量。 */</span></span><br><span class="line">TaskHandle_t xTask2Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 创建优先级为 2 的第一个任务。任务参数未使用，</span></span><br><span class="line"><span class="comment">    设置为 NULL。任务句柄也未使用，因此也设置为 NULL。 */</span></span><br><span class="line">    xTaskCreate( vTask1, <span class="string">"Task 1"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* 任务以优先级 2 创建 ______________________^. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建优先级为 1 的第二个任务 - 该优先级低于赋予任务 1 的优先级。</span></span><br><span class="line"><span class="comment">    同样，任务参数未使用因此设置为 NULL - 但这次需要任务句柄，</span></span><br><span class="line"><span class="comment">    因此 xTask2Handle 的地址在最后一个参数中传递。*/</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">"Task 2"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;xTask2Handle );</span><br><span class="line">    <span class="comment">/* 任务句柄是最后一个参数 _______________________^^^^^^^^^^^^^ */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动调度程序，使任务开始执行。 */</span></span><br><span class="line">    vTaskStartScheduler();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。</span></span><br><span class="line"><span class="comment">    如果 main() 确实到达这里，那么很可能没有足够的堆内存可用于创建空闲任务。第 2 章</span></span><br><span class="line"><span class="comment">    提供了关于堆内存管理的更多信息。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 35. 示例 8 的 <code>main()</code> 实现</p>
<p>图 22 演示了示例 8 任务的执行顺序，其结果输出如图 23 所示。</p>
<img src="image-20240609163053423.png" alt="图 22. 运行示例 8 时的任务执行顺序" style="zoom:67%;">



<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240609163343194.png" alt="图 23. 执行示例 8 时产生的输出"></p>
<h2 id="3-10-删除任务"><a href="#3-10-删除任务" class="headerlink" title="3.10 删除任务"></a>3.10 删除任务</h2><h3 id="vTaskDelete-API-函数"><a href="#vTaskDelete-API-函数" class="headerlink" title="vTaskDelete() API 函数"></a>vTaskDelete() API 函数</h3><p>任务可以使用 <code>vTaskDelete()</code> API 函数删除自身或任何其他任务。请注意，仅当 <code>FreeRTOSConfig.h</code> 中的 <code>INCLUDE_vTaskDelete</code> 设置为 1 时，<code>vTaskDelete()</code> API 函数才可用。</p>
<p>删除的任务不再存在，无法再次进入运行状态。</p>
<p>空闲任务负责释放分配给已删除任务的内存。因此，使用 <code>vTaskDelete()</code> API 函数的应用程序不要完全剥夺 ( starve ) 空闲任务的所有处理时间，这一点很重要。</p>
<blockquote>
<p>注意 : 只有内核分配给任务的内存才会在任务被删除时自动释放。任何由任务实现分配的内存或其他资源必须显式释放。</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t pxTaskToDelete )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>清单 36. <code>vTaskDelete()</code> 函数原型</p>
<p>表 13. <code>vTaskDelete()</code> 参数</p>
<table>
<thead>
<tr>
<th>参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>pxTaskToDelete</code></td>
<td>要删除的任务 ( 主题任务 ) 的句柄——有关获取任务句柄的信息，请参阅 <code>xTaskCreate()</code> API 函数的 <code>pxCreatedTask</code> 参数。<br>任务可以通过传递 <code>NULL</code> 来代替有效的任务句柄来删除自身。</td>
</tr>
</tbody></table>
<h3 id="示例9-删除任务"><a href="#示例9-删除任务" class="headerlink" title="示例9. 删除任务"></a>示例9. 删除任务</h3><p>这是一个非常简单的示例，其行为如下。</p>
<ol>
<li>任务 1 由 <code>main()</code> 创建，优先级为 1。当它运行时，它会创建优先级为 2 的任务 2。任务 2 现在是最高优先级的任务，因此它会立即开始执行。<code>main()</code> 的源代码如清单 37 所示，任务 1 的源代码如清单 38 所示。</li>
<li>任务 2 除了删除自己之外，什么也不会做。它可以通过向 <code>vTaskDelete()</code> 传递 <code>NULL</code> 来删除自己，但是出于演示目的，它会使用自己的任务句柄。任务 2  的源代码如清单 39 所示。</li>
<li>当任务 2 被删除时，任务 1 再次成为优先级最高的任务，所以它将继续执行 —— 此时它会调用 <code>vTaskDelay()</code> 来阻塞一小段时间。</li>
<li>空空闲任务在任务 1 处于阻塞状态时执行，并释放分配给现已删除的任务 2 的内存。</li>
<li>当任务 1 离开阻塞状态时，它将再次变为最高优先级的就绪状态任务，从而抢占空闲任务。当进它入运行状态时，它将再次创建任务 2， 以此类推。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 以优先级 1 创建第一个任务。不使用任务参数，因此将其设置为NULL。 </span></span><br><span class="line"><span class="comment">    任务句柄也未使用，因此同样设置为 NULL 。 */</span></span><br><span class="line">    xTaskCreate( vTask1, <span class="string">"Task 1"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* 该任务以优先级 1 创建 ____________________^. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动调度程序，以便任务开始执行。 */</span></span><br><span class="line">    vTaskStartScheduler();    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 由于调度程序已经启动，main() 永远不会到达此处。 */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 37. 示例 9 的 main() 的实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t xTask2Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line"><span class="type">const</span> TickType_txDelay100ms = pdMS_TO_TICKS( <span class="number">100UL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* 打印这个任务的名称 */</span></span><br><span class="line">        vPrintString( <span class="string">"Task 1 is running\r\n"</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创创建优先级更高的任务 2。 同样没有使用任务参数，所以将其设置为 NULL </span></span><br><span class="line"><span class="comment">        —— 但是这次需要任务句柄，因此将 xTask2Handle 的地址作为最后一个参数传递。*/</span></span><br><span class="line">        xTaskCreate( vTask2, <span class="string">"Task 2"</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">2</span>, &amp;xTask2Handle );</span><br><span class="line">        <span class="comment">/* 任务句柄是最后一个参数 _____^^^^^^^^^^^^^ */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务 2 具有更高的优先级，因此，任务 1 到达此处时，</span></span><br><span class="line"><span class="comment">        任务 2 必须已执行并删除自身。延迟 100 毫秒。 */</span></span><br><span class="line">        vTaskDelay( xDelay100ms );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 38. 示例 9 的任务 1 的实现</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* 任务 2 什么也不做，只是删除自身。为此，它可以使用 NULL </span></span><br><span class="line"><span class="comment">    作为参数来调用 vTaskDelete()，但出于演示目的，</span></span><br><span class="line"><span class="comment">    它调用 vTaskDelete() 并传递自己的任务句柄。 */</span></span><br><span class="line">    vPrintString( <span class="string">"Task 2 is running and about to delete itself\r\n"</span> );</span><br><span class="line">    vTaskDelete( xTask2Handle );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>清单 39. 示例 9 的任务 2 的实现</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240610022134603.png" alt="执行示例 9 时产生的输出"></p>
<p>![图 25. 示例 9 的执行顺序](Chapter 3 任务管理/image-20240610023224251.png)</p>
<h2 id="3-11-线程本地存储"><a href="#3-11-线程本地存储" class="headerlink" title="3.11 线程本地存储"></a>3.11 线程本地存储</h2><p>待完成。本节将在最终发布之前编写。</p>
<blockquote>
<p>译者注 : 原文就是待完成。</p>
</blockquote>
<h2 id="3-12-调度算法"><a href="#3-12-调度算法" class="headerlink" title="3.12 调度算法"></a>3.12 调度算法</h2><h3 id="任务状态和事件的回顾"><a href="#任务状态和事件的回顾" class="headerlink" title="任务状态和事件的回顾"></a>任务状态和事件的回顾</h3><p>实际正在运行 ( 使用处理时间 ) 的任务处于运行状态。在单核处理器上，在任何给定时间只能有一个任务处于运行状态。</p>
<p>未实际运行但未处于阻塞状态或暂停状态的任务处于就绪状态。处于就绪状态的任务可被调度程序选择为进入运行状态的任务。调度程序将始终选择优先级最高的就绪状态任务进入运行状态。</p>
<p>任务可以在阻塞状态下等待事件，并在事件发生时自动移回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发出异步活动信号，例如数据到达外设。</p>
<p>任务可以在阻塞状态下等待事件，并在事件发生时自动返回就绪状态。时间事件发生在特定时间，例如阻塞时间到期时，通常用于实现周期性或超时行为。当任务或中断服务例程使用任务通知、队列、事件组或多种信号量之一发送信息时，就会发生同步事件。它们通常用于发信号通知异步活动，例如数据到达外设。</p>
<h3 id="配置调度算法"><a href="#配置调度算法" class="headerlink" title="配置调度算法"></a>配置调度算法</h3><p>调度算法是决定哪个就绪状态任务转换到运行状态的软件例程。</p>
<p>到目前为止，所有示例都使用了相同的调度算法，但可以使用 <code>configUSE_PREEMPTION</code> 和 <code>configUSE_TIME_SLICING</code> 配置常量更改算法。这两个常量都在 <code>FreeRTOSConfig.h</code> 中定义。</p>
<p>第三个配置常量 <code>configUSE_TICKLESS_IDLE</code> 也会影响调度算法，因为使用该常量会导致嘀嗒中断在较长时间内完全关闭。<code>configUSE_TICKLESS_IDLE</code> 是一个高级选项，专门用于必须最小化其功耗的应用程序。第 10 章 “ 低功耗支持 “ 中介绍了 <code>configUSE_TICKLESS_IDLE</code> 。本节提供的描述假设 <code>configUSE_TICKLESS_IDLE</code> 设置为 0，如果常量未定义，则这是默认设置。</p>
<p>在所有可能的配置中，FreeRTOS 调度程序将确保选择具有同等优先级的任务依次进入运行状态。这种 “ 轮流使用 take it in turn” 策略通常称为 <code>" 循环调度 ( Round Robin Scheduling ) "</code> 。循环调度算法不保证在具有同等优先级的任务之间平均分配时间，而只保证具有同等优先级的就绪状态任务将依次进入运行状态。</p>
<h3 id="带时间片的优先抢占式调度"><a href="#带时间片的优先抢占式调度" class="headerlink" title="带时间片的优先抢占式调度"></a>带时间片的优先抢占式调度</h3><p>表 14 中显示的配置将 FreeRTOS 调度程序设置为使用一种称为 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code> 的调度算法，这是大多数小型 RTOS 应用程序使用的调度算法，也是本书迄今为止介绍的所有示例使用的算法。表 15 提供了算法名称中使用的术语的描述。</p>
<p>表 14. 将内核配置为使用带时间片的优先抢占式调度的 <code>FreeRTOSConfig.h</code> 设置</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>configUSE_PREEMPTION</code></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>configUSE_TIME_SLICING</code></td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>表 15. 用于描述调度策略的术语的解释</p>
<table>
<thead>
<tr>
<th align="center">术语</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">固定优先级<br>( Fixed Priority  )</td>
<td>被描述为 “ 固定优先级 “ 的调度算法不会更改分配给被调度任务的优先级，但也不会阻止任务本身更改自己的优先级或其他任务的优先级。</td>
</tr>
<tr>
<td align="center">抢占<br>( Pre-emptive )</td>
<td>如果优先级高于运行状态任务的任务进入就绪状态，抢占式调度算法将立即 “ 抢占 ( pre-empt ) “ 运行状态任务。被抢占意味着非自愿地 ( 无需显式地让出 yielding 或阻塞 blocking ) 移出运行状态并进入就绪状态，以允许不同的任务进入运行状态。</td>
</tr>
<tr>
<td align="center">时间片<br>( Time Slicing )</td>
<td>时间片用于在优先级相同的任务之间共享处理时间，即使任务没有显式地让出 ( yield ) 或进入阻塞 ( blocked) 状态。如果存在其他与运行任务具有相同优先级的就绪状态任务，描述为使用 <code>" 时间片 ( Time Slicing ) "</code> 的调度算法将在每个时间片结束时选择一个新任务进入运行状态。时间片等于两个 RTOS 嘀嗒中断之间的时间。</td>
</tr>
</tbody></table>
<p>图 26 和图 27 说明了当使用具有时间分片算法的固定优先级抢占式调度时如何调度任务。 图 26 显示了当应用程序中的所有任务具有唯一优先级时，选择任务以进入“运行”状态的顺序。 图 27 显示了当应用程序中的两个任务共享优先级时，选择任务以进入“运行”状态的顺序。</p>
<p>图 26 和图 27 演示了使用 <code>" 带时间片的固定优先级抢占式调度 ( Fixed Priority Pre-emptive Scheduling with Time Slicing ) "</code>  算法时任务的调度方式。图 26 显示了当应用程序中的所有任务都具有唯一的优先级时，选择任务进入运行状态的顺序。图 27 显示了当应用程序中的两个任务共享一个优先级时，选择任务进入运行状态的顺序。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240610125928163.png" alt="图 26. 执行模式突出显示假设应用程序中的任务优先级和抢占，其中每个任务都被分配了唯一的优先级"></p>
<p>参考图26 : </p>
<ol>
<li><p><strong>空闲任务</strong> ：空闲任务以最低优先级运行，因此每次较高优先级的任务进入就绪状态时，空闲任务都会被抢占 —— 例如在时间 t3、t5 和 t9。</p>
</li>
<li><p><strong>任务 3</strong> ：任务 3 是一个事件驱动的任务，它以相对较低的优先级执行，但高于空闲优先级。 它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次事件发生时从阻塞状态转换到就绪状态。 所有 FreeRTOS 任务间通信机制 ( 任务通知，队列，信号量，事件组等 ) 都可用于以这种方式发出事件信号和解除任务阻塞。</p>
<p>事件发生在时间 t3 和 t5，以及 t9 和 t12 之间的某个时间。发生在时间 t3 和 t5 的事件会立即得到处理，因为在这些时间，任务 3 是能够运行的最高优先级任务。发生在时间 t9 和 t12 之间的某个时间的事件直到 t12 才会得到处理，因为在此之前，优先级较高的任务任务 1 和任务 2 仍在执行。只有在时间 t12 时，任务 1 和任务 2 才处于阻塞状态，从而使任务 3 成为优先级最高的就绪状态任务。</p>
</li>
<li><p><strong>任务 2</strong> : 任务 2 是一个周期性任务，其执行优先级高于任务 3 的优先级，但低于任务 1 的优先级。该任务的周期间隔意味着任务 2 想要在时间 t1、t6 和 t9 执行。</p>
<p>在时间 t6，任务 3 处于运行状态，但任务 2 具有较高的相对优先级，因此抢占任务 3 并立即开始执行。任务 2 完成其处理并在时间 t7 重新进入阻塞状态，此时任务 3 可以重新进入运行状态以完成其处理。任务 3 本身在时间 t8 阻塞。</p>
</li>
<li><p><strong>任务 1</strong> : 任务 1 也是一个事件驱动任务。它以最高的优先级执行，因此可以抢占系统中的任何其他任务。图中显示的唯一任务 1 事件发生在时间 t10，此时任务 1 抢占任务 2。只有在任务 1 于时间 t11 重新进入阻塞状态后，任务 2 才能完成其处理。</p>
</li>
</ol>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240610154453687.png" alt="图 27. 执行模式突出显示假设应用程序中的任务优先级和时间片，其中两个任务以相同的优先级运行"></p>
<p>参考图 27 : </p>
<ol>
<li><p><strong>空闲任务与任务 2</strong>：空闲任务和任务 2 都是连续处理 ( continuous processing ) 任务，优先级均为 0 ( 最低优先级 ) 。调度程序仅在没有更高优先级的任务可运行时才将处理时间分配给优先级 0 任务，并通过时间分片共享分配给优先级 0 任务的时间。每次嘀嗒中断都会开始一个新的时间片，在图 27 中，时间片为 t1、t2、t3、t4、t5、t8、t9、t10 和 t11。</p>
<p>空闲任务和任务 2 依次进入运行状态，这会导致两个任务在同一时间片的部分时间内处于运行状态，就像在时间 t5 和时间 t8 之间发生的情况一样。</p>
</li>
<li><p><strong>任务 1</strong>：任务 1 的优先级高于空闲优先级。任务 1 是一个事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件，每次发生事件时，它都会从阻塞状态转换到就绪状态。</p>
<p>感兴趣的事件发生在时间 t6，因此在 t6 时任务 1 成为能够运行的最高优先级任务，因此任务 1 在时间片中抢占空闲任务。事件处理在时间 t7 时完成，此时任务 1 重新进入阻塞状态。</p>
</li>
</ol>
<p>图 27 显示了空闲任务与应用程序编写者创建的任务共享处理时间。如果应用程序编写者创建的空闲优先级任务有工作要做，而空闲任务没有工作要做，那么为空闲任务分配那么多处理时间可能并不可取。<code>configIDLE_SHOULD_YIELD</code> 编译时配置常量可用于更改空闲任务的调度方式：</p>
<ul>
<li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 0，则空闲任务将在整个时间片内保持运行状态，除非它被更高优先级的任务抢占。</li>
<li>如果 <code>configIDLE_SHOULD_YIELD</code> 设置为 1，则如果有其他空闲优先级任务处于就绪状态，则空闲任务将在其循环的每次迭代中让出 yield ( 自愿放弃其分配的时间片的剩余部分 ) 。</li>
</ul>
<p>图 27 中所示的执行模式是当 <code>configIDLE_SHOULD_YIELD</code> 设置为 0 时将观察到的内容。图 28 中所示的执行模式是在 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时在相同场景中观察到的内容。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240611075853590.png" alt="图 28. 与图 27 所示场景相同的执行模式，但这次将 configIDLE_SHOULD_YIELD 设置为 1"></p>
<p>图 28 还显示，当 <code>configIDLE_SHOULD_YIELD</code> 设置为 1 时，在空闲任务之后被选择进入运行状态的任务不会执行整个时间片，而是执行空闲任务让出的时间片的剩余部分。</p>
<h3 id="优先级抢占式调度-无时间片"><a href="#优先级抢占式调度-无时间片" class="headerlink" title="优先级抢占式调度 ( 无时间片 )"></a>优先级抢占式调度 ( 无时间片 )</h3><p>没有时间切片的优先抢占式调度保持与上一节中描述的相同的任务选择和抢占算法，但不使用时间切片在具有相同优先级的任务之间共享处理时间。</p>
<p>表 16 显示了将 FreeRTOS 调度程序配置为使用无时间片的优先级抢占式调度的 <code>FreeRTOSConfig.h</code> 设置。</p>
<p>表 16.  <code>FreeRTOSConfig.h</code> 设置，用于将内核配置为使用无时间片的优先级抢占式调度 </p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>configUSE_PREEMPTION</code></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>configUSE_TIME_SLICING</code></td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>如图 27 所示，如果使用时间分片，并且有多个处于最高优先级的就绪状态任务能够运行，那么调度程序将在每个RTOS滴答中断 ( 标记时间片结束的滴答中断 ) 期间选择一个新任务进入运行状态。如果不使用时间分片，则调度程序将仅在以下任一情况下选择新任务进入运行状态 :  &lt;—- here</p>
<ul>
<li>更高优先级的任务进入就绪状态。</li>
<li>处于运行状态的任务进入阻塞状态或者暂停状态。</li>
</ul>
<p>不使用时间片时，任务上下文切换次数比使用时间片时少。因此，关闭时间片可减少调度程序的处理开销。但是，关闭时间片也会导致优先级相同的任务收到的处理时间量相差很大，如图 29 所示。因此，不使用时间片运行调度程序被视为一种高级技术，仅应由经验丰富的用户使用。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240612131241019.png" alt="图 29. 执行模式，演示当不使用时间片时，相同优先级的任务如何获得截然不同的处理时间"></p>
<p>参考图 29 ，假设 <code>configIDLE_SHOULD_YIELD</code> 设置为 0：</p>
<ol>
<li><p><strong>嘀嗒中断</strong>：</p>
<p>嘀嗒中断发生在时间 t1、t2、t3、t4、t5、t8、t11、t12 和 t13 。</p>
</li>
<li><p><strong>任务 1</strong>：</p>
<p>任务 1 是一个高优先级事件驱动任务，它大部分时间都处于阻塞状态，等待其感兴趣的事件。每次事件发生时，任务 1 都会从阻塞状态转换为就绪状态 ( 随后，由于它是优先级最高的就绪状态任务，因此会转换为运行状态 ) 。图 29 显示任务 1 在时间 t6 和 t7 之间处理事件，然后在时间 t9 和 t10 之间再次处理事件。</p>
</li>
<li><p><strong>空闲任务与任务 2</strong>：</p>
<p>空闲任务和任务2都是连续处理任务，并且优先级都为 0  ( 空闲优先级 ) 。连续处理任务不进入阻塞状态。</p>
<p>由于未使用时间片，因此处于运行状态的空闲优先级任务将保持运行状态，直到被更高优先级的任务 1 抢占。</p>
<p>在图 29 中，空闲任务在时间 t1 开始运行，并保持运行状态，直到在时间 t6 被任务 1 抢占——此时距离其进入运行状态已过去了四个完整的嘀嗒周期以上。 </p>
<p>任务 2 在时间 t7 开始运行，此时任务 1 重新进入阻塞状态以等待另一个事件。任务 2 一直处于运行状态，直到它也在时间 t9 被任务 1 抢占——此时距离它进入运行状态还不到一个嘀嗒周期。</p>
<p>在时间 t10，空闲任务重新进入运行状态，尽管其已获得比任务 2 多四倍以上的处理时间。</p>
</li>
</ol>
<h3 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h3><p>本书主要介绍抢占式调度，但 FreeRTOS 也可以使用 <code>协作式调度 ( co-operative scheduling )</code> 。配置 FreeRTOS 调度程序使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置如表 17 所示。</p>
<p>表 17. 将内核配置为使用协作式调度的 <code>FreeRTOSConfig.h</code> 设置</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>configUSE_PREEMPTION</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>configUSE_TIME_SLICING</code></td>
<td align="center">任何值</td>
</tr>
</tbody></table>
<p>当使用协作式调度程序时，仅当运行状态任务进入阻塞状态，或运行状态任务通过调用 <code>taskYIELD()</code> 显式地让出 ( 手动请求重新调度 ) 时，才会发生上下文切换。任务永远不会被抢占，因此不能使用时间片。</p>
<p>图 30 演示了协作式调度程序的行为。图 30 中的水平虚线显示任务何时处于就绪状态。</p>
<p><img src="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/image-20240613005719519.png" alt="图 30. 演示协作式调度程序行为的执行模式"></p>
<p>参考图 30 : </p>
<ol>
<li><p><strong>任务 1</strong>：</p>
<p>任务 1 有最高优先级，它开始于阻塞状态，等待一个信号量。</p>
<p>在时间 t3 处，一个中断会 <code>给出 ( give )</code> 信号量，导致任务 1 离开阻塞状态并进入就绪状态 ( 第 6 章介绍从中断给出信号量 ) 。</p>
<p>在时间 t3 时，任务 1 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 1 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 1 保持在就绪状态，直到时间 t4 — 即运行状态任务调用 <code>taskYIELD()</code> 时。</p>
</li>
<li><p><strong>任务 2</strong>：</p>
<p>任务 2 的优先级介于任务 1 和任务 3 之间。它开始于阻塞状态，等待由任务 3 在时间 t2 发送给它的消息。</p>
<p>在时间 t2 时，任务 2 是优先级最高的就绪状态任务，如果使用抢占式调度程序，任务 2 将成为运行状态任务。但是，由于正在使用协作式调度程序，任务 2 保持在就绪状态，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 。</p>
<p>运行状态任务在时刻 t4 调用 <code>taskYIELD()</code> ，但此时任务 1 是优先级最高的就绪状态任务，因此直到任务 1 在时刻 t5 重新进入阻塞状态时，任务 2 才真正成为运行状态任务。</p>
<p>在时间 t6 时，任务 2 重新进入阻塞状态以等待下一条消息，此时任务 3 再次成为最高优先级的就绪状态任务。</p>
</li>
</ol>
<p>在一个多任务应用程序中，应用程序编写者必须注意不要让多个任务同时访问同一个资源，因为同时访问可能会损坏资源。例如，考虑以下场景，其中访问的资源是 UART ( 串行端口 )。两个任务正在将字符串写入 UART；任务 1 正在写入 <code>"abcdefghijklmnop"</code>，任务 2 正在写入 <code>"123456789"</code> ：</p>
<ol>
<li>任务 1 处于运行状态并开始写入其字符串。它将 <code>"abcdefg"</code> 写入 UART，但在写入任何其他字符之前离开运行状态。</li>
<li>任务 2 进入运行状态，并在离开运行状态之前将 <code>"123456789"</code> 写入UART。</li>
<li>任务 1 重新进入运行状态，并将其字符串的剩余字符写入 UART。</li>
</ol>
<p>在这种情况下，实际写入 UART 的是 <code>"abcdefg123456789hijklmnop"</code> 。任务 1 写入的字符串并未按预期以不间断的顺序写入 UART，而是被破坏了，因为任务 2 写入 UART 的字符串出现在其中。</p>
<p>通常，使用协作调度程序比使用抢占式调度程序更容易避免由同时访问引起的问题 [1]：</p>
<blockquote>
<p>[1] : 在任务之间安全共享资源的方法将在本书后面介绍。FreeRTOS 本身提供的资源 ( 如队列和信号量 ) 始终可以在任务之间安全共享。</p>
</blockquote>
<ul>
<li>当使用抢占式调度程序时，运行状态任务可以随时被抢占，包括当它与另一个任务共享的资源处于不一致状态时。正如 UART 示例所展示的那样，让资源处于不一致状态可能会导致数据损坏。</li>
<li>当使用协作调度程序时，应用程序编写者可以控制何时切换到另一个任务。因此，应用程序编写者可以确保在资源处于不一致状态时不会切换到另一项任务。</li>
<li>在上面的 UART 示例中，应用程序编写者可以确保任务 1 在其整个字符串写入 UART 之前不会离开运行状态，这样就消除了字符串被另一个任务的操作破坏的可能性。</li>
</ul>
<p>如图 30 所示，使用协作调度程序时系统的响应速度比使用抢占式调度程序时要慢：</p>
<ul>
<li>当使用抢占式调度器时，一旦某个任务成为最高优先级的就绪状态任务，调度器会立即开始运行该任务。这在必须在规定时间内响应高优先级事件的实时系统中通常是至关重要的。</li>
<li>当使用协作调度程序时，直到运行状态任务进入阻塞状态或调用 <code>taskYIELD()</code> 时，才会切换到成为最高优先级的就绪状态任务的任务。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/Blogs/about" rel="external nofollow noreferrer">Koito Yuu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://koito-yuu153.github.io/Blogs/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/">https://koito-yuu153.github.io/Blogs/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/Blogs/about" target="_blank">Koito Yuu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/Blogs/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/Blogs/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/Blogs/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/Blogs/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/Blogs/2024/06/14/chapter-3-ren-wu-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/21.jpg" class="responsive-img" alt="Chapter 3 任务管理">
                        
                        <span class="card-title">Chapter 3 任务管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-06-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Koito Yuu
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/Blogs/2024/03/21/hexo-de-shi-yong-jiao-cheng/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/3.jpg" class="responsive-img" alt="hexo的使用教程">
                        
                        <span class="card-title">hexo的使用教程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Koito Yuu
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/Blogs/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/Blogs/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/Blogs/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/Blogs/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="9479612817"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/Blogs/libs/aplayer/APlayer.min.js"></script>
<script src="/Blogs/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <a href="/Blogs/about" target="_blank">Koito Yuu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Koito-Yuu153" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2810880357" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2810880357" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/Blogs/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/Blogs/libs/materialize/materialize.min.js"></script>
    <script src="/Blogs/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/Blogs/libs/aos/aos.js"></script>
    <script src="/Blogs/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/Blogs/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/Blogs/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/Blogs/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/Blogs/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/Blogs/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/Blogs/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
