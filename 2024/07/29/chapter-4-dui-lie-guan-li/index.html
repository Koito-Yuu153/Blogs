<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Chapter 4 队列管理, Koito Yuu&#39;s Blogs">
    <meta name="description" content="队列管理4.1 章节介绍与范围&#34; 队列 ( Queues ) &#34; 提供了一个任务到任务，任务到中断和中断到任务的通讯机制。
范围本章节的目标是告诉读者很好的理解：

如何创建一个队列。
队列如何管理它所包含的数据。
如何发送数据到队列。
如">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Chapter 4 队列管理 | Koito Yuu&#39;s Blogs</title>
    <link rel="icon" type="image/png" href="/Blogs/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/Blogs/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/matery.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/my.css">
<link rel="stylesheet" type="text/css" href="/Blogs/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/Blogs/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/Blogs/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/Blogs/css/reward.css">
    



    <script src="/Blogs/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/Blogs/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/Blogs/" class="waves-effect waves-light">
                    
                    <img src="/Blogs/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Koito Yuu&#39;s Blogs</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/Blogs/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/Blogs/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Koito Yuu&#39;s Blogs</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/Blogs/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Koito-Yuu153/Koito-Yuu-s-Blog.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/Blogs/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Chapter 4 队列管理</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/Blogs/categories/FreeRTOS/" class="post-category">
                                FreeRTOS
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-07-29
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h1><h2 id="4-1-章节介绍与范围"><a href="#4-1-章节介绍与范围" class="headerlink" title="4.1 章节介绍与范围"></a>4.1 章节介绍与范围</h2><p><code>" 队列 ( Queues ) "</code> 提供了一个<strong>任务到任务</strong>，<strong>任务到中断</strong>和<strong>中断到任务</strong>的通讯机制。</p>
<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>本章节的目标是告诉读者很好的理解：</p>
<ul>
<li>如何创建一个队列。</li>
<li>队列如何管理它所包含的数据。</li>
<li>如何发送数据到队列。</li>
<li>如何从队列接收数据。</li>
<li>阻塞队列意味着什么。</li>
<li>如何阻塞多个队列。</li>
<li>如何覆盖队列中的数据。</li>
<li>如何清除一个队列。</li>
<li>读取和写入一个队列对任务优先级的影响。</li>
</ul>
<p>本章节只涵盖了任务到任务通讯。任务到中断与中断到任务通讯在第 6 章中说明。</p>
<h2 id="4-2-队列的特征"><a href="#4-2-队列的特征" class="headerlink" title="4.2 队列的特征"></a>4.2 队列的特征</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>一个队列可以容纳有限数量的固定大小的数据项。一个队列可以容纳的最大项数称为它的  <code>“长度”(length)</code>。每个数据项的长度和大小都在创建队列时设置。</p>
<p>队列通常是一个先进先出（FIFO）的缓冲区，即数据在队列末端（tail）被写入，在队列前端（head）移出。图 31 展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。    </p>
<p><img src="Chapter 4 队列管理/image-20240615213504445.png" alt="图 31. 队列写入和读取的示例序列"></p>
<p>有两种方法可以实现队列的行为：</p>
<ol>
<li>通过复制实现队列：复制队列是指将发送到队列的数据一个字节一个字节地复制到队列中。</li>
<li>通过引用实现队列：引用队列意味着队列只持有指向发送到队列的数据的指针，而不是数据本身。</li>
</ol>
<p>FreeRTOS 是通过使用复制方法实现队列。这是考虑到复制队列比引用队列更强大，更容易使用，因为：</p>
<ul>
<li>堆栈变量可以直接发送到队列，即使该变量将在声明它的函数退出后，不再存在。</li>
<li>可以将数据发送到队列，而无需先分配缓冲区来保存数据，然后将数据复制到分配的缓冲区中。</li>
<li>发送任务可以立即重用发送到队列的变量或缓冲区。</li>
<li>发送任务和接收任务是完全分离的，应用程序设计人员不需要关心哪个任务 <code>"拥有"(owns)</code> 数据，或者哪个任务负责 <code>"发布"(releasing)</code> 数据。</li>
<li>复制队列并不会阻塞队列也被用于引用队列。例如，当正在排队的数据的大小使得将数据复制到队列不切实际时，可以将指向数据的指针复制到队列中。</li>
<li>RTOS 完全负责分配用于存储数据的内存。</li>
<li>在受内存保护的系统中，任务可以访问的 RAM 将受到限制。在这种情况下，只有当发送和接收任务都可以访问存储数据的 RAM 时，才可以使用引用队列。而复制队列不受此限制；内核总是以完全特权运行，从而允许使用队列跨内存保护边界传递数据。</li>
</ul>
<h3 id="多任务访问"><a href="#多任务访问" class="headerlink" title="多任务访问"></a>多任务访问</h3><p>队列本身就是对象，任何知道它们存在的任务或 ISR 都可以访问它们。任意数量的任务可以写入同一个队列，任意数量的任务也可以从同一个队列读取。在实践中，队列有多个写入者是非常常见的，但是队列有多个读取者就不那么常见了。</p>
<h3 id="读取队列时阻塞"><a href="#读取队列时阻塞" class="headerlink" title="读取队列时阻塞"></a>读取队列时阻塞</h3><p>当任务尝试从队列中读取时，它可以选择指定 <code>“阻塞” (block)</code> 时间。 如果队列已经为空，则这是任务将保持在阻塞状态以等待队列中的数据可用的时间。 当另一个任务或中断将数据放入队列时，处于阻塞状态且等待队列中的数据可用的任务将自动移至就绪状态。 如果在数据可用之前指定的阻塞时间到期，任务也会自动从阻塞状态转移到就绪状态。</p>
<p>队列可以有多个读取者，因此单个队列可能会由多个在其上阻塞等待数据的任务。 在这种情况下，只有一个任务在数据可用时会被解除阻塞。 取消阻塞的任务始终是等待数据的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待数据时间最长的任务将被解除阻塞。</p>
<h3 id="写入队列时阻塞"><a href="#写入队列时阻塞" class="headerlink" title="写入队列时阻塞"></a>写入队列时阻塞</h3><p>与从队列读取数据时一样，任务也可以在向队列写入数据时指定阻塞时间。在这种情况下，如果队列已经满了，则阻塞时间是任务应该保持在阻塞状态以等待队列上可用空间的最长时间。</p>
<p>队列可以有多个写入器，因此一个已满的队列可能有多个任务被阻塞，等待完成发送操作。在这种情况下，当队列上的空间可用时，只有一个任务将被解除阻塞。被解除阻塞的任务将始终是等待空间的最高优先级任务。如果阻塞的任务具有相同的优先级，则等待空间时间最长的任务将被解除阻塞。</p>
<h3 id="在多个队列上阻塞"><a href="#在多个队列上阻塞" class="headerlink" title="在多个队列上阻塞"></a>在多个队列上阻塞</h3><p>多个队列可以组成集合，允许任务进入阻塞状态以等待集合中任何队列上的数据可用。 <code>队列集(Queue sets)</code>在第 4.6 节“从多个队列接收”中演示。</p>
<h2 id="4-3-使用队列"><a href="#4-3-使用队列" class="headerlink" title="4.3 使用队列"></a>4.3 使用队列</h2><h3 id="xQueueCreate-API-函数"><a href="#xQueueCreate-API-函数" class="headerlink" title="xQueueCreate() API 函数"></a>xQueueCreate() API 函数</h3><p>一个队列在使用前必须被显式地创建。</p>
<p>队列由句柄引用，句柄是 <code>QueueHandle_t</code> 类型的变量。<code>xQueueCreate()</code> API 函数会创建一个队列，并给一个 <code>QueueHandle_t</code> 的变量用来引用这个被创建的队列。</p>
<p>FreeRTOS V9.0.0 还包含 <code>xQueueCreateStatic()</code> 函数，该函数在编译时静态地分配创建队列所需的内存：创建队列时，FreeRTOS 从 FreeRTOS 堆中分配 RAM。RAM 用于保存队列数据结构和队列中包含的项。如果没有足够的堆 RAM 可用于创建队列，xQueueCreate() 将返回 NULL。第 2 章提供了有关 FreeRTOS 堆的更多信息。</p>
<pre class=" language-lang-c"><code class="language-lang-c">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize);
</code></pre>
<p>清单 40. <code>xQueueCreate()</code> API 函数原型</p>
<p>表 18. <code>xQueueCreate()</code> 参数和返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>uxQueueLength</td>
<td>正在创建的队列一次可以容纳的最大项数。</td>
</tr>
<tr>
<td>uxItemSize</td>
<td>可以存储在队列中的每个数据项的字节大小。</td>
</tr>
<tr>
<td>返回值</td>
<td>如果返回 <code>NULL</code>，则无法创建队列，因为 FreeRTOS 没有足够的堆内存来分配队列数据结构和存储区域。返回的非空值表示队列已成功创建。返回的值应该存储为已创建队列的句柄。</td>
</tr>
</tbody>
</table>
</div>
<p>创建队列后，可以使用 <code>xQueueReset()</code> API 函数将队列返回到其原始的空状态。</p>
<h3 id="xQueueSendToBack-与-xQueueSendToFront-API-函数"><a href="#xQueueSendToBack-与-xQueueSendToFront-API-函数" class="headerlink" title="xQueueSendToBack() 与 xQueueSendToFront() API 函数"></a>xQueueSendToBack() 与 xQueueSendToFront() API 函数</h3><p>正如所料，<code>xQueueSendToBack()</code> 用于将数据发送到队列的末端（tail），<code>xQueueSendToFront()</code> 用于将数据发送到队列的前端（head）。</p>
<p><code>xQueueSend()</code> 与 <code>xQueueSendToBack()</code> 等价，并且完全相同。<br>永远不要从中断服务例程调用 <code>xQueueSendToFront()</code> 或 <code>xQueueSendToBack()</code>。应使用中断安全版本 <code>xQueueSendToFront()</code> 和 <code>xQueueSendToBack()</code> 代替它们。这些将在第 6 章中描述。</p>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueSendToFront( QueueHandle_t xQueue,
                              const void * pvItemToQueue,
                              TickType_t xTicksToWait );
</code></pre>
<p>清单 41. <code>xQueueSendToFront()</code> API 函数原型</p>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueSendToBack( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait );
</code></pre>
<p>清单 42. <code>xQueueSendToBack()</code> API 函数原型</p>
<p>表 19. <code>xQueueSendToFront()</code> 和 <code>xQueueSendToSendToBack()</code> 函数参数和返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueue</td>
<td>发送(写入)数据的队列的句柄。队列句柄将从用于创建队列的 <code>xQueueCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td>pvItemToQueue</td>
<td><p>指向要复制到队列中的数据的指针。</p><p>队列可以容纳的每个项的大小是在创建队列时设置的，因此这多个字节将从 <code>pvItemToQueue</code> 复制到队列存储区域中。</p></td>
</tr>
<tr>
<td>xTicksToWait</td>
<td><p>如果队列已满，任务应保持在阻塞状态以等待队列上的空间可用的最长时间。</p><p>如果 <code>xTicksToWait</code> 为零且队列已满，则 <code>xQueueSendToFront()</code> 和 <code>xQueueSendToBack()</code> 都将立即返回。</p><p>阻塞时间以滴答周期指定，因此它所表示的绝对时间依赖于滴答频率。宏 <code>pdMS TO TICKS()</code> 可用于将以毫秒为单位的时间转换为以节拍为单位的时间。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>INCLUDE_vTaskSuspend</code> 设置为 1，则将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致任务无限期地等待（没有超时期限）。</p></td>
</tr>
<tr>
<td>返回值</td>
<td><p>有两种可能的返回值：</p><ol><li>pdPASS：仅当数据成功发送到队列时，才会返回 <code>pdPASS</code>。如果指定了阻塞时间（<code>xTicksToWait</code> 不为零），那么调用任务可能被置于阻塞状态，在函数返回之前等待队列中的空间可用，但数据在阻塞时间到期之前已经成功写入队列。</li><li>errQUEUE_FULL：如果由于队列已满，无法将数据写入队列，将返回<code>errQUEUE_FULL</code> 。如果指定了阻塞时间（<code>xTicksToWait</code> 不为零），则调用任务将被置于阻塞状态以等待另一个任务或中断在队列中腾出空间，但指定的阻塞时间在该状态之前到期。</li></ol></td>
</tr>
</tbody>
</table>
</div>
<p><code>xQueueReceive()</code> 用来从队列中接收（读取）一个元素。收到的元素将从队列中删除。</p>
<blockquote>
<p>切勿从中断服务程序调用 <code>xQueueReceive()</code>。 中断安全 <code>xQueueReceiveFromISR()</code> API 函数在第 6 章中描述。</p>
</blockquote>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void *const pvBuffer,
                          TickType_t xTicksToWait );
</code></pre>
<p>清单 43. <code>xQueueReceive()</code> API 函数原型</p>
<p>表 20. <code>xQueueReceive()</code> 函数参数和返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xQueue</td>
<td><p>正在接收（读取）数据的队列句柄。</p><p>队列句柄将从用于创建队列的 <code>xQueueCreate()</code> 调用返回。</p></td>
</tr>
<tr>
<td style="text-align:left">pvBuffer</td>
<td><p>指向要将接收到的数据复制到的内存的指针。</p><p>队列保存的每个数据项的大小是在创建队列时设置的。   <code>pvBuffer</code> 指向的内存必须至少足够大，以容纳这么多字节</p></td>
</tr>
<tr>
<td style="text-align:left">xTicksToWait</td>
<td><p>如果队列已经为空，则任务应保持在阻塞状态以等待数据在队列上可用的最长时间。</p><p>如果 <code>xTicksToWait</code> 为零，那么如果队列已经为空，则 <code>xQueueReceive()</code> 将立即返回。</p><p>阻塞时间以滴答周期指定，因此它所表示的绝对时间依赖于滴答频率。宏 <code>pdMS TO TICKS()</code> 可用于将以毫秒为单位的时间转换为以节拍为单位的时间。</p><p>如果在 <code>FreeRTOSConfig.h</code> 中将 <code>INCLUDE_vTaskSuspend</code> 设置为 1，则将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY</code> 将导致任务无限期地等待（没有超时期限）。</p></td>
</tr>
<tr>
<td style="text-align:left">返回值</td>
<td><p>有两种可能的返回值：</p><ol><li>pdPASS：仅当从队列中成功读取数据时才会返回 <code>pdPASS</code>。 如果指定了阻塞时间（<code>xTicksToWait</code> 不为零），那么调用任务可能被置于阻塞状态，等待数据在队列中可用，但是在阻塞时间到期之前已成功从队列中读取数据。</li><li>errQUEUE_EMPTY：如果由于队列已经为空而无法从队列中读取数据，则将返回<code>errQUEUE_EMPTY</code>。如果指定了阻塞时间（<code>xTicksToWait</code> 不为零），那么调用任务将被置于阻塞状态以等待另一个任务或中断将数据发送到队列，但阻塞时间在该时间之前到期。</li></ol></td>
</tr>
</tbody>
</table>
</div>
<p><code>uxQueueMessagesWaiting()</code> 用于查询当前在队列中的项数。</p>
<p>注意：切勿从中断服务程序调用 <code>uxQueueMessagesWaiting()</code>。 应该在其位置使用中断安全版本 <code>uxQueueMessagesWaitingFromISR()</code>。</p>
<pre class=" language-lang-c"><code class="language-lang-c">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );
</code></pre>
<p>清单 44. <code>uxQueueMessagesWaiting()</code> API 函数原型</p>
<p>表 21. <code>uxQueueMessagesWaiting()</code> 函数参数或返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名称/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueue</td>
<td>正在查询队列的句柄。 将从用于创建队列的 <code>xQueueCreate()</code> 调用返回队列句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td>正在查询的队列当前持有的项数。 如果返回零，则队列为空。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="示例-10-从队列接收时阻塞"><a href="#示例-10-从队列接收时阻塞" class="headerlink" title="示例 10. 从队列接收时阻塞"></a>示例 10. 从队列接收时阻塞</h3><p>此示例演示了创建队列、从多个任务将数据发送到队列以及从队列接收数据。创建队列是为了保存 <code>int32_t</code> 类型的数据项。 发送到队列的任务不指定阻塞时间，而从队列接收的任务则指定。</p>
<p>发送到队列的任务的优先级低于从队列接收的任务的优先级。这意味着队列不应该包含多个项，因为一旦数据发送到队列，接收任务就会解除阻塞，抢占发送任务，并删除数据，从而再次使队列为空。</p>
<p>清单 45 显示了写入队列的任务的实现。 创建该任务的两个实例，一个将值 100 连续写入队列，另一个将值 200 连续写入同一队列。 任务参数用于将这些值传递到每个任务实例中。</p>
<pre class=" language-lang-c"><code class="language-lang-c">static void vSenderTask( void *pvParameters )
{
int32_t lValueToSend;
BaseType_t xStatus;

    /* 创建此任务的两个实例，以便通过任务参数传递发送到队列的值 —— 这样每个实例可以使用不同
    的值。创建队列是为了保存 int32_t 类型的值，因此将参数转换为所需的类型。 */
    lValueToSend = ( int32_t ) pvParameters;

    /* 与大多数任务一样，这个任务在无限循环中实现。 */
    for( ;; )
    {
        /* 将值发送到队列。

        第一个参数是数据发送到的队列。队列是在调度程序启动之前创建的，因此在此任务开始执行
        之前。

        第二个参数是要发送的数据的地址，在本例中是 lValueToSend 的地址。

        第三个参数是阻塞时间 —— 如果队列已经满了，任务应该保持在阻塞状态，等待队列上的空间
        可用。在这种情况下，不指定块时间，因为队列永远不会包含超过一个项，因此永远不会满。*/
        xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 );

        if( xStatus != pdPASS )
        {
            /* 由于队列已满，发送操作无法完成 - 这一定是一个错误，因为队列绝不可能包含超过一个项！ */
            vPrintString( "Could not send to the queue.\r\n" );
        }
    }
}
</code></pre>
<p>清单 45. 示例 10 中使用的发送任务的实现。</p>
<p>清单 46 显示了从队列接收数据的任务的实现。 接收任务指定阻塞时间为 100 毫秒，因此将进入阻塞状态以等待数据变为可用。 当队列上有数据可用，或者 100 毫秒后没有数据可用时，它将离开阻塞状态。 在此示例中，100 毫秒超时不应过期，因为有两个任务不断写入队列。</p>
<pre class=" language-lang-c"><code class="language-lang-c">static void vReceiverTask( void *pvParameters )
{
/* 声明用来保存从队列接收的值的变量。 */
int32_t lReceivedValue;
BaseType_t xStatus;
const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

    /* 此任务也在无限循环中定义。 */
    for( ;; )
    {
        /* 此调用应该始终发现队列为空，因为此任务将立即删除写入队列的任何数据。 */
        if( uxQueueMessagesWaiting( xQueue ) != 0 )
        {
            vPrintString( "Queue should have been empty!\r\n" );
        }

        /* 从队列中接收数据。 

        第一个参数是接收数据的队列。队列在调度程序启动之前创建，因此在此任务第一次运
        行之前创建。 

        第二个参数是用来将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有保存
        接收数据所需大小的变量的地址。

        最后一个参数是阻塞时间，如果队列已经为空，任务将保持在阻塞状态等待数据可用的最长
        时间。 */
        xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );

        if( xStatus == pdPASS )
        {
            /* 从队列中成功接收到数据，打印出接收到的值。 */
            vPrintStringAndNumber( "Received = ", lReceivedValue );
        }
        else
        {
            /* 即使等待 100ms 也没有从队列中收到数据。 这一定是一个错误，
            因为发送任务是自由运行的并且将不断写入队列。*/
            vPrintString( "Could not receive from the queue.\r\n" );
        }
    }
}
</code></pre>
<p>清单 46. 示例 10 接收任务的实现</p>
<p>清单 47 包含 <code>main()</code> 函数的定义。 这只是在启动调度程序之前创建队列和三个任务。 创建的队列最多可容纳 5 个 <code>int32_t</code> 值，即使任务的优先级被设置为队列永远不会一次包含多个项。</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 声明一个 QueueHandle_t 类型的变量。这用于存储由所有三个任务访问的队列的句柄。*/
QueueHandle_txQueue;

int main( void )
{
    /* 创建队列最多可以容纳5个值，每个值都足够大，可以容纳 int32_t 类型的变量。 */
    xQueue= xQueueCreate( 5, sizeof( int32_t) );if( xQueue != NULL )
    {
        /* 创建发送到队列的任务的两个实例。任务参数用于传递任务将写入队列的值，因此一个任务
        将持续向队列写入 100，而另一个任务将持续向队列写入 200。这两个任务均以优先级 1 创建。 */
        xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL );
        xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL );

        /* 创建从队列中读取的任务。创建任务的优先级为 2，因此高于发送任务的优先级。 */
        xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

        /* 启动调度程序，以便创建的任务开始执行。 */
        vTaskStartScheduler();
    }
    else
    {
        /* 无法创建队列。 */
    }

    /* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果
    main() 确实到达这里，那么很可能没有足够的 FreeRTOS 堆内存可用来创建空闲任务。第 2 章
    提供了关于堆内存管理的更多信息。 */
    for( ;; );
}
</code></pre>
<p>清单 47. 例 10 中 main() 的实现</p>
<p>发送到队列的两个任务都具有相同的优先级。 这使两个发送任务依次将数据发送到队列。 例 10 中产生的输出如图 32 所示。</p>
<p><img src="Chapter 4 队列管理/image-20240615230444671.png" alt="图 32. 执行示例 10 产生的输出"></p>
<p>图 33 演示了执行顺序</p>
<p><img src="Chapter 4 队列管理/image-20240615230737621.png" alt="图 33 . 示例 10 执行顺序"></p>
<h2 id="4-4-从多个源接收数据"><a href="#4-4-从多个源接收数据" class="headerlink" title="4.4 从多个源接收数据"></a>4.4 从多个源接收数据</h2><p>在 FreeRTOS 设计中，一项任务从多个源接收数据是很常见的。接收任务需要知道数据来自哪里，以确定如何处理数据。 一个简单的设计解决方案是使用单个队列来传输结构体，其中数据值和数据来源包含在结构体的字段中。 该方案如图 34 所示。</p>
<p><img src="Chapter 4 队列管理/image-20240615231043766.png" alt="图 34. 发送结构到队列的示例场景"></p>
<p>图 34 参考：</p>
<ul>
<li>创建一个保存 <code>Data_t</code> 类型结构体的队列。结构成员允许在一条消息中将数据值和指示数据含义的枚举类型发送到队列。</li>
<li>中央的 Controller 任务用于执行主要系统功能。 它必须对队列上传递给它的系统状态的输入和更改做出反应。</li>
<li>CAN bus task 用于封装 CAN 总线接口功能。当 CAN 总线任务接收并解码消息时，它将已解码的消息以 <code>Data_t</code> 结构发送到 Controller 任务。 传输结构的 <code>eDataID</code> 成员用于让 Controller 任务知道数据是什么 —— 在所描述的情况下，它是电机速度值。 传输结构的 <code>lDataValue</code> 成员用于让 Controller 任务知道实际的电机速度值。</li>
<li>HMI task（人机界面任务）用于封装所有 HMI 功能。机器操作员可能以多种方式输入命令和查询值，这些方式必须在 HMI 任务中检测和解释。输入新命令时，HMI 任务将命令以一个 <code>Data_t</code> 的结构发送到 Controller 任务。传输结构的 <code>eDataID</code> 成员用于让 Controller 任务知道数据是什么 —— 在所描述的情况下，它是一个新的设定点值。 传递结构的 <code>lDataValue</code> 成员用于让 Controller 任务知道实际设定点的值。</li>
</ul>
<h3 id="示例-11-发送到队列时阻塞，并在队列上发送结构"><a href="#示例-11-发送到队列时阻塞，并在队列上发送结构" class="headerlink" title="示例 11. 发送到队列时阻塞，并在队列上发送结构"></a>示例 11. 发送到队列时阻塞，并在队列上发送结构</h3><p>示例 11 与示例 10 类似，但任务优先级相反，因此接收任务的优先级低于发送任务。 此外，队列用于传递结构，而不是整数。</p>
<p>清单 48 显示了示例 11 使用的结构的定义。</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 定义用于标识数据源的枚举类型。 */
typedef enum
{
    eSender1,
    eSender2
} DataSource_t;

/* 定义将在队列上传递的结构类型。 */
typedef struct
{
    uint8_t ucValue;
    DataSource_t eDataSource;
} Data_t;

/* 声明两个将在队列中传递的 Data_t 类型的变量。 */
static const Data_txStructsToSend[ 2 ] = 
{
    { 100, eSender1 }, /* 由 Sender1 使用。 */
    { 200, eSender2 }  /* 由 Sender2 使用。 */
};
</code></pre>
<p>清单 48. 要在队列上传递的结构的定义，以及由示例使用的两个变量的声明</p>
<p>在示例 10 中，接收任务具有最高优先级，因此队列中永远不会存在多个元素。 这是因为一旦数据被放入队列中，接收任务就会抢占发送任务。 在示例 11 中，发送任务具有更高的优先级，因此队列通常是满的。 这是因为，一旦接收任务从队列中删除了一个项，它就会被其中一个发送任务抢占，然后立即重新填充队列。 然后，发送任务重新进入阻塞状态，等待空间再次在队列中可用。</p>
<p>清单 49 显示了发送任务的实现。 发送任务指定 100 毫秒的阻塞时间，因此每次队列变满时，它都会进入阻塞状态以等待有可用空间。当队列中有空间可用时，或者没有空间可用的情况下超过 100 毫秒时，它就会离开阻塞状态。在这个例子中，100 毫秒超时应该永不过期，因为接受任务通过从队列中删除元素来不断地腾出空间。</p>
<pre class=" language-lang-c"><code class="language-lang-c">static void vSenderTask( void *pvParameters )
{
BaseType_txStatus;
const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 );

    /* 与大多数任务一样，这个任务在无限循环中实现。 */
    for( ;; )
    {
        /* 发送到队列。

        第二个参数是正在发送的结构的地址。地址作为任务参数传入，因此直接使用 pvParameters。 

        第三个参数是阻塞时间 —— 如果队列已经满了，任务应该保持在阻塞状态，等待队列上的空间可用。
        之所以指定阻塞时间，是因为发送任务的优先级高于接收任务，因此预计队列将变满。当两个发送任
        务都处于阻塞状态时，接收任务将从队列中删除元素。 */
        xStatus = xQueueSendToBack( xQueue, pvParameters, xTicksToWait );

        if( xStatus != pdPASS )
        {
            /* 即使等待了 100ms，发送操作也无法完成。这一定是一个错误，因为一旦两个发送任务
            都处于阻塞状态，接收任务就应该在队列中留出空间。 */
            vPrintString( "Could not send to the queue.\r\n" );
        }
    }
}
</code></pre>
<p>清单 49. 示例 11 发送任务的实现</p>
<p>接收任务的优先级最低，所以只有当两个发送任务都处于阻塞状态时，接收任务才会运行。发送任务仅在队列满时才进入阻塞状态，因此接收任务仅在队列满时才会执行。因此，即使没有指定阻塞时间，它也总是期望接收数据。</p>
<p>清单 50 显示了接收任务的实现。</p>
<pre class=" language-lang-c"><code class="language-lang-c">static void vReceiverTask( void *pvParameters )
{
/* 声明将保存从队列接收的值的结构。 */
Data_t xReceivedStructure;
BaseType_t xStatus;

    /* 这个任务也是在一个无限循环中定义的。 */
    for( ;; )
    {
        /* 因为它的优先级最低，所以只有当发送任务处于阻塞状态时，该任务才会运行。发送任务只
        会在队列已满时进入阻塞状态，因此该任务总是期望队列中的项数等于队列长度，本例中为 3。*/
        if( uxQueueMessagesWaiting( xQueue ) != 3 )
        {
            vPrintString( "Queue should have been full!\r\n" );
        }

        /* 从队列中接收。

        第二个参数是将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有容纳接收结
        构所需大小的变量的地址。

        最后一个参数是阻塞时间 —— 如果队列已经为空，任务将保持在阻塞状态等待数据可用的最长时
        间。在当前情况下，不需要阻塞时间，因为此任务只在队列满时运行。 */
        xStatus = xQueueReceive( xQueue, &xReceivedStructure, 0 );

        if( xStatus == pdPASS )
        {
            /* 从队列中成功接收到数据，打印出接收到的值和值的源。 */
            if( xReceivedStructure.eDataSource== eSender1 )
            {
                vPrintStringAndNumber( "From Sender 1 = ", xReceivedStructure.ucValue );
            }
            else
            {
                vPrintStringAndNumber( "From Sender 2 = ", xReceivedStructure.ucValue );
            }
        }
        else
        {
            /* 队列中没有收到任何东西。这一定是一个错误，因为该任务应该只在队列满时运行。 */
            vPrintString( "Could not receive from the queue.\r\n" );
        }
    }
}
</code></pre>
<p>清单 50. 示例 11 接收任务的定义</p>
<p><code>main()</code> 仅比前一个示例略有变化。 创建队列以容纳三个 <code>Data_t</code> 结构，并且发送和接收任务的优先级相反。 <code>main()</code> 的实现如清单 51 所示。</p>
<pre class=" language-lang-c"><code class="language-lang-c">int main( void )
{
    /* 创建队列以容纳最多 3 个 Data_t 类型的结构。 */
    xQueue = xQueueCreate( 3, sizeof( Data_t) );

    if( xQueue != NULL )
    {
        /* 创建将写入队列的任务的两个实例。该参数用于传递任务将写入队列的结构，因此一个任务将持
        续向队列发送 xStructsToSend[0]，而另一个任务将持续发送 xStructsToSend[1]。这两个任
        务都是在优先级 2 创建的，优先级高于接收方的优先级。 */
        xTaskCreate( vSenderTask, "Sender1", 1000, &( xStructsToSend[ 0 ] ), 2, NULL);
        xTaskCreate( vSenderTask, "Sender2", 1000, &( xStructsToSend[ 1 ] ), 2, NULL);

        /* 创建将从队列中读取的任务。创建任务的优先级为 1，因此低于发送方任务的优先级。 */
        xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 1, NULL );

        /* 启动调度程序，以便创建的任务开始执行。 */
        vTaskStartScheduler();
    }
    else
    {
        /* 无法创建队列。 */
    }

    /* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果 
    main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆内存管
    理的更多信息。 */
    for( ;; );
}
</code></pre>
<p>清单 51. 示例 11 <code>main()</code> 的实现</p>
<p>示例 11 生成的输出如图 35 所示。</p>
<p><img src="Chapter 4 队列管理/image-20240615235949760.png" alt="图 35. 示例 11 产生的输出"></p>
<p>图 36 显示了由于发送任务的优先级高于接收任务的优先级而导致的执行顺序。 表 22 提供了对图 36 的进一步说明，并描述了前四个消息是否来自同一任务。</p>
<p><img src="Chapter 4 队列管理/image-20240616000547598.png" alt="图 36. 示例 11 的执行顺序"></p>
<p>表 22. 图 36 的关键点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>时刻</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>任务发送方 1 执行并向队列发送 3 个数据项。</td>
</tr>
<tr>
<td>t2</td>
<td>队列已满，因此发送方 1 进入阻塞状态，等待下一次发送完成。任务发送方 2 现在是能够运行的最高优先级任务，因此进入运行状态。</td>
</tr>
<tr>
<td>t3</td>
<td>任务发送者 2 发现队列已经满了，因此进入阻塞状态，等待第一次发送完成。任务接收者现在是能够运行的最高优先级任务，因此进入运行状态。</td>
</tr>
<tr>
<td>t4</td>
<td>优先级高于接收任务优先级的两个任务正在等待队列中的空间可用，从而导致任务接收者在从队列中删除一个项后立即被抢占。 任务发送者 1 和发送者 2 具有相同的优先级，因此调度程序选择等待时间最长的任务作为将进入运行状态的任务 —— 在这种情况下是任务发送者 1。</td>
</tr>
<tr>
<td>t5</td>
<td><p>任务发送者 1 将另一个数据项发送到队列。 队列中只有一个空间，因此任务发送者 1 进入阻塞状态以等待下一次发送完成。 任务接收器再次是能够运行的最高优先级任务，因此进入运行状态。</p><p>任务发送者 1 现在已向队列发送了四个项，任务发送者 2 仍在等待将其第一个项发送到队列。</p></td>
</tr>
<tr>
<td>t6</td>
<td>优先级高于接收任务优先级的两个任务正在等待队列中的空间可用，因此任务接收者一旦从队列中删除了一个项就会被抢占。 此时发送者 2 等待的时间比发送者 1 长，因此发送者 2 进入运行状态。</td>
</tr>
<tr>
<td>t7</td>
<td>任务发送者 2 将数据项发送到队列。 队列中只有一个空格，因此发件人 2 进入阻塞状态以等待下一次发送完成。 发送者 1 和发送者 2 都在等待队列中的空间可用，因此任务接收者是唯一可以进入运行状态的任务。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="4-5-处理大型或可变大小的数据"><a href="#4-5-处理大型或可变大小的数据" class="headerlink" title="4.5 处理大型或可变大小的数据"></a>4.5 处理大型或可变大小的数据</h2><h3 id="用队列传输指针-Queuing-Pointers"><a href="#用队列传输指针-Queuing-Pointers" class="headerlink" title="用队列传输指针 (Queuing Pointers)"></a>用队列传输指针 (Queuing Pointers)</h3><p>如果队列中存储的数据大小很大，那么最好使用队列传输指向数据的指针，而不是将数据本身逐字节复制到队列中或从队列中复制出来。 传输指针在处理时间和创建队列所需的 RAM 量方面都更加高效。 然而，在对指针进行队列传输时，必须格外小心以确保：</p>
<ol>
<li><p>指向的 RAM 的所有者是明确定义的。</p>
<p>通过指针在任务之间共享内存时，必须确保两个任务不会同时修改内存内容，或采取任何其他可能导致内存内容无效或不一致的操作。 理想情况下，只允许发送任务访问内存，直到指向内存的指针已经排队，并且在从队列接收到指针之后，只允许接收任务访问内存。</p>
</li>
<li><p>指向的 RAM 仍然有效。</p>
<p>如果所指向的内存是动态分配的，或者是从预先分配的缓冲区池中获取的，那么只有一个任务应该负责释放内存。 任何任务都不应在释放内存后尝试访问该内存。永远不应使用指针来访问已在任务堆栈上分配的数据。 栈帧改变后数据将不再有效。</p>
</li>
</ol>
<p>举例来说，清单 52，清单 53 和清单 54 演示了如何使用队列从一个任务向另一个任务发送指向缓冲区的指针：</p>
<ul>
<li>清单 52 创建了一个最多可以容纳 5 个指针的队列。</li>
<li>清单 53 分配缓冲区，将字符串写入缓冲区，然后将指向缓冲区的指针发送到队列。</li>
<li>清单 54 从队列中接收指向缓冲区的指针，然后将包含在缓冲区中的字符串打印出来。</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">/* 声明 QueueHandle_t 类型的变量以保存正在创建的队列的句柄。 */
QueueHandle_t xPointerQueue;

/* 创建一个最多可容纳 5 个指针的队列，在本例中为字符指针。 */
xPointerQueue = xQueueCreate( 5, sizeof( char * ) );
</code></pre>
<p>清单 52. 创建一个包含指针的队列</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 获取缓冲区的任务，向缓冲区写入一个字符串，然后将缓冲区的地址发送到清单 52 中创建的队列。 */
void vStringSendingTask( void *pvParameters )
{
    char *pcStringToSend;
    const size_t xMaxStringLength = 50;
    BaseType_t xStringNumber = 0;

    for( ;; )
    {
        /* 获取至少为 xMaxStringLength 字符大的缓冲区。prvGetBuffer() 的实现没有显示，
        它可能从预先分配的缓冲区池中获取缓冲区，或者只是动态地分配缓冲区。 */
        pcStringToSend = ( char * ) prvGetBuffer( xMaxStringLength );

        /* 将字符串写入缓冲区。 */
        snprintf( pcStringToSend, xMaxStringLength, "String number %d\r\n", xStringNumber );

        /* 增加计数器，使字符串在此任务的每次迭代中都不同。 */
        xStringNumber++;

        /* 将缓冲区的地址发送到清单 52 中创建的队列。缓冲区的地址存储在 pcStringToSend 变量中。*/
        xQueueSend( xPointerQueue,     /* 队列的句柄。 */
                    &pcStringToSend,   /* 指向缓冲区的指针的地址。 */
                    portMAX_DELAY );
    }
}
</code></pre>
<p>清单 53. 使用队列发送指向缓冲区的指针</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 从清单 52 中创建的队列中接收缓冲区地址并写入清单 53 中的任务。缓冲区包含一个字符串，
该字符串被打印出来。 */
void vStringReceivingTask( void *pvParameters )
{
char *pcReceivedString;

    for( ;; )
    {
        /* 接收缓冲区的地址。 */
        xQueueReceive( xPointerQueue,     /* 队列的句柄。 */
                       &pcReceivedString, /* 将缓冲区地址存储在 pcReceivedString 中。 */
                       portMAX_DELAY );   

        /* 缓冲区保存一个字符串，将其打印出来。 */
        vPrintString( pcReceivedString );

        /* 不再需要缓冲区 —— 释放它以便可以释放或重新使用它。 */
        prvReleaseBuffer( pcReceivedString );
    }
}
</code></pre>
<p>清单 54. 使用队列接收指向缓冲区的指针</p>
<h3 id="使用队列发送不同类型和长度的数据"><a href="#使用队列发送不同类型和长度的数据" class="headerlink" title="使用队列发送不同类型和长度的数据"></a>使用队列发送不同类型和长度的数据</h3><p>前面几节已经证明了两个强大的设计模式：发送结构到一个队列，发送指针到一个队列。 组合这两个技术就可以允许一个任务使用一个队列接收来自任何数据源的任何数据类型。 FreeRTOS+TCP TCP/IP 协议栈的实现提供了如何这样实现的实际例子。</p>
<p>在自己的任务中运行的 TCP/IP 协议栈必须处理许多来自不同源的事件。 不同的事件类型与不同类型和长度的数据相关联。 在 TCP/IP 任务之外发生的所有事件都由 <code>IPStackEvent_t</code> 类型的结构描述，并发送到队列上的 TCP/IP 任务。 <code>IPStackEvent_t</code> 结构如清单 55 所示，<code>IPStackEvent_t</code> 结构的 <code>pvData</code> 成员是一个指针，可用于直接保存值或指向缓冲区。</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 在 TCP/IP 堆栈中用于识别事件的枚举类型的子集。 */
typedef enum
{
    eNetworkDownEvent = 0, /* 网络接口已丢失，或者需要（重新）连接。 */
    eNetworkRxEvent,       /* 从网络接收到一个数据包。 */
    eTCPAcceptEvent,       /* 调用 FreeRTOS_accept() 来接受或等待新客户端。 */

    /* 其他事件类型出现在这里，但没有显示在这个清单中。 */

} eIPEvent_t;

/* 描述事件的结构，并在队列中发送到TCP/IP任务。 */
typedef struct IP_TASK_COMMANDS
{
    /* 标识事件的枚举类型。请参见上面的 eIPEvent_t 定义。 */
    eIPEvent_t eEventType;

    /* 可以保存值或指向缓冲区的通用指针。 */
    void *pvData;

} IPStackEvent_t;
</code></pre>
<p>清单 55. 用于将事件发送到FreeRTOS + TCP 中的 TCP/IP 协议栈任务的结构</p>
<p>TCP/IP 事件及其相关数据的示例包括:</p>
<ul>
<li><p>eNetworkRxEvent：已从网络接收到数据包。</p>
<p>从网络接收的数据使用类型为 <code>IPStackEvent_t</code> 的结构发送到 TCP/IP 任务，该结构的 <code>eEventType</code> 成员设置为 <code>eNetworkRxEvent</code>，该结构的 <code>pvData</code> 成员用于指向包含接收数据的缓冲区。清单 56 显示了一个伪代码示例。</p>
</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">void vSendRxDataToTheTCPTask( NetworkBufferDescriptor_t *pxRxedData )
{
IPStackEvent_t xEventStruct;

    /* 完成 IPStackEvent_t 结构。接收到的数据存储在 pxRxedData。 */
    xEventStruct.eEventType = eNetworkRxEvent;
    xEventStruct.pvData = ( void * ) pxRxedData;

    /* 发送 IPStackEvent_t 结构到 TCP/IP 协议栈。 */
    xSendEventStructToIPTask( &xEventStruct );

}
</code></pre>
<p>清单 56. 伪代码，显示如何使用 <code>IPStackEvent_t</code> 结构将从网络接收的数据发送到 TCP/IP 任务</p>
<ul>
<li><p>eTCPAcceptEvent：套接字用于接受或等待来自客户端的连接。</p>
<p>接受事件是使用 <code>IPStackEvent_t</code> 类型的结构从调用 <code>FreeRTOS_accept()</code> 的任务发送到 TCP/IP 任务的。该结构的 <code>eEventType</code> 成员设置为 <code>eTCPAcceptEvent</code>，该结构的 <code>pvData</code> 成员设置为正在接受连接的套接字的句柄。清单 57 显示了一个伪代码示例。</p>
</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">void vSendAcceptRequestToTheTCPTask( Socket_t xSocket )
{
IPStackEvent_t xEventStruct;

    /* 完成 IPStackEvent_t 结构。 */
    xEventStruct.eEventType = eTCPAcceptEvent;
    xEventStruct.pvData = ( void * ) xSocket;

    /* 发送 IPStackEvent_t 结构到 TCP/IP 任务。*/
    xSendEventStructToIPTask( &xEventStruct );
}
</code></pre>
<p>清单 57. 伪代码，显示如何使用 <code>IPStackEvent_t</code> 结构发送正在接受到 TCP/IP 任务的连接的套接字句柄</p>
<ul>
<li><p>eNetworkDownEvent：网络需要连接或重新连接。</p>
<p>网络关闭事件是使用 <code>IPStackEvent_t</code> 类型的结构从网络接口发送到 TCP/IP 任务的。该结构的 <code>eEventType</code> 成员设置为 <code>eNetworkDownEvent</code>。网络关闭事件不与任何数据相关联，因此不使用该结构的 <code>pvData</code> 成员。清单 58 显示了一个伪代码示例。</p>
</li>
</ul>
<pre class=" language-lang-c"><code class="language-lang-c">void vSendNetworkDownEventToTheTCPTask(Socket_t xSocket)
{
IPStackEvent_t xEventStruct;

    /* 完成 IPStackEvent_t 结构。 */
    xEventStruct.eEventType = eNetworkDownEvent;
    xEventStruct.pvData = NULL; /* 未使用，但设置为 NULL 保证完整性。 */

    /* 发送 IPStackEvent_t 类型的结构体到 TCP/IP 任务。*/
    xSendEventStructToIPTask( &xEventStruct );
}
</code></pre>
<p>清单 58. 伪代码，显示如何使用 <code>IPStackEvent_t</code> 结构向 TCP 发送网络关闭事件</p>
<p>清单 59 中显示了在 TCP/IP 任务中接收和处理这些事件的代码。可以看出，从队列接收的 <code>IPStackEvent_t</code> 结构的 <code>eEventType</code> 成员用于确定如何解释 <code>pvData</code> 成员。</p>
<pre class=" language-lang-c"><code class="language-lang-c">IPStackEvent_t xReceivedEvent;

    /* 阻塞网络事件队列，直到接收到事件，或者经过 xNextIPSleep 滴答节拍而没有接收到事件。
    如果对 xQueueReceive() 的调用返回是因为超时，而不是因为接收到事件，则将 eEventType 
    设置为 eNoEvent。 */
    xReceivedEvent.eEventType = eNoEvent;
    xQueueReceive( xNetworkEventQueue, &xReceivedEvent, xNextIPSleep );

    /* 收到了哪个事件(如果有)? */
    switch( xReceivedEvent.eEventType )
    {
        case eNetworkDownEvent :
            /* 尝试(重新)建立连接。此事件与任何数据都没有关联。 */
            prvProcessNetworkDownEvent();
            break;
        case eNetworkRxEvent:
            /* 网络接口收到了一个新数据包。指向接收到的数据的指针存储在接收到的 
            IPStackEvent_t 结构的 pvData 成员中。处理接收到的数据。*/
            prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * )( xReceivedEvent.pvData ) );
            break;
        case eTCPAcceptEvent:
            /* 调用了 FreeRTOS_accept() API函数。接受连接的套接字句柄存储在
            接收到的 IPStackEvent_t 结构的 pvData 成员中。 */
            xSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
            xTCPCheckNewClient( pxSocket );
            break;

        /* 其他事件类型以相同的方式处理，但在此不显示。 */
    }
</code></pre>
<p>清单 59. 显示如何接收和处理 IPStackEvent_t 结构的伪代码</p>
<h2 id="4-6-从多个队列接收"><a href="#4-6-从多个队列接收" class="headerlink" title="4.6 从多个队列接收"></a>4.6 从多个队列接收</h2><h3 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h3><p>应用程序设计通常需要单个任务来接收不同大小的数据、不同含义的数据以及来自不同来源的数据。上一节演示了如何使用接收结构体的单个队列以简洁高效的方式实现这一点。然而，有时应用程序的设计者会遇到限制其设计选择的约束，这就需要对某些数据源使用单独的队列。例如，集成到设计中的第三方代码可能假设存在专用队列。在这种情况下，可以使用 “队列集”。</p>
<p>队列集允许任务从多个队列接收数据，而无需任务依次轮询每个队列以确定哪个队列（如果有的话）包含数据。</p>
<p>与使用接收结构的单个队列实现相同功能的设计相比，使用队列集从多个源接收数据的设计不那么整洁，效率也较低。因此，建议仅在设计约束使得使用队列集成为绝对必要的情况下使用队列集。</p>
<p>以下各节介绍如何使用队列集:</p>
<ol>
<li><p>创建队列集。</p>
</li>
<li><p>向队列集中添加队列。信号量也可以添加到队列集中。信号量将在本书后面描述。</p>
</li>
<li><p>从队列集读取，以确定集内哪些队列包含数据。</p>
<p>当作为集合的成员的队列接收数据时，接收队列的句柄被发送到队列集，并在任务调用从队列集读取的函数时返回。因此，如果从队列集返回队列句柄，则已知该句柄引用的队列包含数据，然后任务可以直接从队列中读取。</p>
</li>
</ol>
<blockquote>
<p>注意: 如果队列是队列集的成员，则不要直接从队列中读取数据，除非先从队列集中读取了队列句柄。</p>
</blockquote>
<p>队列集功能是通过在 <code>FreeRTOSConfig.h</code> 中将 <code>configUSE_QUEUE_SETS</code> 编译时配置常数设置为 1 来启用的。</p>
<h3 id="xQueueCreateSet-API函数"><a href="#xQueueCreateSet-API函数" class="headerlink" title="xQueueCreateSet() API函数"></a>xQueueCreateSet() API函数</h3><p>必须先显式创建队列集，然后才能使用它。</p>
<p>队列集由句柄引用，句柄是 <code>QueueSetHandle_t</code> 类型的变量。<code>xQueueCreateSet()</code> API 函数创建一个队列集，并返回一个引用它创建的队列集的 <code>QueueSetHandle_t</code>。</p>
<pre class=" language-lang-c"><code class="language-lang-c">QueueSetHandle_t xQueueCreateSet(const UBaseType_t uxEventQueueLength);
</code></pre>
<p>清单 60. <code>xQueueCreateSet()</code> 函数原型</p>
<p>表格 23. <code>xQueueCreateSet()</code> 参数与返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>uxEventQueueLength</td>
<td><p>当队列集中的一个队列接收数据时，接收队列的句柄被发送到队列集。 <code>uxEventQueueLength</code> 定义了正在创建的队列集在任何时候可以容纳的队列句柄的最大数量。</p><p>队列句柄仅在队列集中的队列接收数据时发送给队列集。如果队列已满，则无法接收数据，因此如果队列集中的所有队列都已满，则无法向队列集发送队列句柄。因此，**队列集中一次必须容纳的最大项数是该集合中每个队列的长度的总和**。</p><p>例如，如果集合中有三个空队列，每个队列的长度为五，那么集合中的队列总共可以在集合中的所有队列都满之前接收十五个项(三个队列乘以五个项)。在该示例中，`uxEventQueueLength` 必须设置为 15，以保证队列集可以接收发送给它的每个项。</p><p>信号量也可以添加到队列集中。二进制和计数信号量将在本书后面介绍。为了计算必要的 `uxEventQueueLength` ，二进制信号量的长度为 1，计数信号量的长度由信号量的最大计数值给出。</p><p>作为另一个例子，如果队列集将包含长度为 3 的队列和一个二进制信号量 (长度为 1 )，<code>uxEventQueueLength</code> 必须设置为 4 (3+1)。</p></td>
</tr>
<tr>
<td>返回值</td>
<td><p>如果返回 NULL ，则无法创建队列集，因为FreeRTOS没有足够的堆内存来分配队列集数据结构和存储区域。</p><p>返回的非 NULL 值指示队列集已成功创建。返回的值应存储为所创建的队列集的句柄</p></td>
</tr>
</tbody>
</table>
</div>
<p><code>xQueueAddToSet()</code> 将队列或信号量添加到队列集中。信号量将在本书后面描述。</p>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, 
                           QueueSetHandle_t xQueueSet );
</code></pre>
<p>清单 61. <code>xQueueAddToSet()</code> API 函数原型</p>
<p>表格 24. <code>xQueueAddToSet()</code> 参数与返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueueOrSemaphore</td>
<td><p>要添加到队列集中的队列或信号量的句柄。</p><p>队列句柄和信号量句柄都可以强制转换为 <code>QueueSetMemberHandle_t</code> 类型。</p></td>
</tr>
<tr>
<td>xQueueSet</td>
<td>要添加队列或信号量的队列集的句柄。</td>
</tr>
<tr>
<td>返回值</td>
<td><p>有两种可能的返回值:</p><ol><li>pdPASS: 只有当队列或信号量成功添加到队列集中时，才会返回 pdPASS。</li><li>pdFAIL: 如果队列或信号量无法添加到队列集中，将返回 pdFAIL。队列和二进制信号量只有在为空时才能添加到集合中。计数信号量只能在其计数为零时添加到集合中。队列和信号量一次只能是一个集合的成员。</li></ol></td>
</tr>
</tbody>
</table>
</div>
<p><code>xQueueSelectFromSet()</code> 从队列集中读取队列句柄。</p>
<p>当作为集合成员的队列或信号量接收数据时，接收数据的队列或信号量的句柄被发送到队列集，并在任务调用 <code>xQueueSelectFromSet()</code> 时被返回。如果从对 <code>xQueueSelectFromSet()</code> 的调用中返回句柄，则句柄引用的队列或信号量已知包含数据，并且调用任务必须直接从队列或信号量中读取。</p>
<blockquote>
<p>注意: 不要从作为集合成员的队列或信号量中读取数据，除非队列或信号量的句柄是从对 <code>xQueueSelectFromSet()</code> 的调用中首先返回的。每次调用 <code>xQueueSelectFromSet()</code> 返回队列句柄或信号量句柄时，只从队列或信号量中读取一个项。</p>
</blockquote>
<pre class=" language-lang-c"><code class="language-lang-c">QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                            const TickType_t xTicksToWait );
</code></pre>
<p>清单 62. <code>xQueueSelectFromSet()</code> API 函数原型</p>
<p>表格 25. <code>xQueueSelectFromSet()</code> 参数与返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueueSet</td>
<td>队列集的句柄，从中接收(读取)队列句柄或信号量句柄。对用于创建队列集的 <code>xQueueCreateSet()</code> 的调用将返回队列集句柄。</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td><p>如果队列集中的所有队列和信号量都为空，则调用任务应保持在阻塞状态以等待从队列集中接收队列或信号量句柄的最长时间。如果 <code>xTicksToWait</code> 为零，那么如果集合中的所有队列和信号量都为空，<code>xQueueSelectFromSet()</code> 将立即返回。</p><p>阻塞时间以滴答周期指定，因此它表示的绝对时间取决于滴答频率。宏 <code>pdMS_TO_TICKS()</code> 可用于将以毫秒为单位指定的时间转换为以滴答为单位指定的时间。</p><p>将 <code>xTicksToWait</code> 设置为 <code>portMAXDELAY</code> 将导致任务无限期等待 ( 没有超时期限 ) ，前提是在 <code>FreeRTOSConfig.h</code> 中将 <code>INCLUDE_vTaskSuspend</code> 设置为 1。</p></td>
</tr>
<tr>
<td>返回值</td>
<td><p>非 NULL 的返回值将是已知包含数据的队列或信号量的句柄。如果指定了阻塞时间(<code>xTicksToWait</code> 不为零)，那么调用任务可能被置于阻塞状态，以等待数据从集合中的队列或信号量变得可用，但是在阻塞时间到期之前，从队列集中成功读取了句柄。句柄以 <code>QueueSetMemberHandle_t</code> 类型返回，可以转换为 <code>QueueHandle_t</code> 类型或 <code>SemaphoreHandle_t</code> 类型。</p><p>如果返回值为 NULL，则无法从队列集中读取句柄。如果指定了阻塞时间(<code>xTicksToWait</code> 不为零)，则调用任务将被置于阻塞状态，以等待另一个任务或中断向集合中的一个或多个信号量发送数据，但阻塞时间在此之前已经过期。</p></td>
</tr>
</tbody>
</table>
</div>
<h3 id="示例-12-使用队列集"><a href="#示例-12-使用队列集" class="headerlink" title="示例 12. 使用队列集"></a>示例 12. 使用队列集</h3><p>本示例创建两个发送任务和一个接收任务。发送任务通过两个独立的队列向接收任务发送数据，每个任务一个队列。这两个队列被添加到队列集中，接收任务从队列集中读取以确定这两个队列中的哪一个包含数据。</p>
<p>任务、队列和队列集都是在 <code>main()</code> 中创建的，请参见清单 63 了解其实现。</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 声明两个队列句柄类型的变量。两个队列都被添加到同一个队列集中。 */
static QueueHandle_t xQueue1 = NULL, xQueue2 = NULL;

/* 声明 QueueSetHandle_t 类型的变量。这是两个队列将要添加到的队列集。 */
static QueueSetHandle_t xQueueSet = NULL;

int main( void )
{
    /* 创建两个队列，这两个队列都发送 char 指针。接收任务的优先级高于发送任务的优先级，
    因此队列中任何时候都不会有一个以上的项*/
    xQueue1 = xQueueCreate( 1, sizeof( char * ) );
    xQueue2 = xQueueCreate( 1, sizeof( char * ) );

    /* 创建队列集。两个队列将被添加到该组中，每个队列可以包含 1 个项，因此该队列集必须
    同时保存的队列句柄的最大数量为 2 ( 2 个队列乘以每个队列 1 个项)。 */
    xQueueSet = xQueueCreateSet( 1 * 2 );

    /* 将两个队列添加到集合中。 */
    xQueueAddToSet( xQueue1, xQueueSet );
    xQueueAddToSet( xQueue2, xQueueSet );

    /* 创建发送到队列的任务。 */
    xTaskCreate( vSenderTask1, "Sender1", 1000, NULL, 1, NULL );
    xTaskCreate( vSenderTask2, "Sender2", 1000, NULL, 1, NULL );

    /* 创建从队列集中读取的任务，以确定两个队列中的哪个队列包含数据。 */
    xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );

    /* 启动调度程序，以便创建的任务开始执行。 */
    vTaskStartScheduler();

    /* 正常情况下，vTaskStartScheduler() 不应该返回，因此下面几行永远不会执行。 */
    for( ;; );
    return 0;
}
</code></pre>
<p>清单 63. 示例 12 <code>main()</code> 实现</p>
<p>第一个发送任务使用 <code>xQueue1</code> 每 100 毫秒向接收任务发送一个字符指针。第二个发送任务使用 <code>xQueue2</code> 每 200 毫秒向接收任务发送一个字符指针。字符指针被设置为指向标识发送任务的字符串。清单 64 显示了两个发送任务的实现。</p>
<pre class=" language-lang-c"><code class="language-lang-c">void vSenderTask1( void *pvParameters )
{
const TickType_t xBlockTime = pdMS_TO_TICKS( 100 );
const char * const pcMessage = "Message from vSenderTask1\r\n";

    /* 与大多数任务一样，这个任务在无限循环中实现。 */
    for( ;; )
    {
        /* 阻塞 100ms. */
        vTaskDelay( xBlockTime );

        /* 将此任务的字符串发送到 xQueue1。没有必要使用阻塞时间，即使队列只能容纳一个
        项。这是因为从队列中读取的任务的优先级高于该任务的优先级；一旦该任务写入队列，
        它将被从队列中读取的任务抢占，因此当对 xQueueSend() 的调用返回时，队列已经再次
        为空。阻塞时间设置为 0。 */
        xQueueSend( xQueue1, &pcMessage, 0 );
    }
}
/*-----------------------------------------------------------*/

void vSenderTask2( void *pvParameters )
{
const TickType_t xBlockTime = pdMS_TO_TICKS( 200 );
const char * const pcMessage = "Message from vSenderTask2\r\n";

    /* 与大多数任务一样，这个任务在无限循环中实现。 */
    for( ;; )
    {
        /* 阻塞 200ms. */
        vTaskDelay( xBlockTime );

        /* 将此任务的字符串发送到 xQueue2。没有必要使用阻塞时间，即使队列只能容纳一个
        项。这是因为从队列中读取的任务的优先级高于该任务的优先级；一旦该任务写入队列，
        它将被从队列中读取的任务抢占，因此当对 xQueueSend() 的调用返回时，队列已经再次
        为空。阻塞时间设置为 0。 */
        xQueueSend( xQueue2, &pcMessage, 0 );
    }
}
</code></pre>
<p>清单 64. 示例 12 中使用的发送任务</p>
<p>发送任务写入的队列是同一队列集的成员。每次任务发送到其中一个队列时，队列的句柄都会被发送到队列集中。接收任务调用 <code>xQueueSelectFromSet()</code> 从队列集中读取队列句柄。接收任务从集合中接收到队列句柄后，它知道接收句柄引用的队列包含数据，因此直接从队列中读取数据。它从队列中读取的数据是指向字符串的指针，接收任务将打印出该字符串。</p>
<p>如果对 <code>xQueueSelectFromSet()</code> 的调用超时，则它将返回空值。在示例 12 中，<code>xQueueSelectFromSet()</code> 是以不确定的块时间调用的，因此永远不会超时，并且只能返回有效的队列句柄。因此，在使用返回值之前，接收任务不需要检查 <code>xQueueSelectFromSet()</code> 是否返回空值。</p>
<p><code>xQueueSelectFromSet()</code> 只有在句柄引用的队列包含数据时才会返回队列句柄，因此从队列中读取时没有必要使用块时间。</p>
<p>清单 65 显示了接收任务的实现。</p>
<pre class=" language-lang-c"><code class="language-lang-c">void vReceiverTask( void *pvParameters )
{
QueueHandle_t xQueueThatContainsData;
char *pcReceivedString;

    /* 根据大多数任务，这个任务是在无限循环中实现的。 */
    for( ;; )
    {
        /* 阻塞队列集中的一个队列包含数据。将从 xQueueSelectFromSet() 返回的 
        QueueSetMemberHandle_t 值转换为 QueueHandle_t，因为已知该集的所有成员都是队列
        (队列集不包含任何信号量)。*/
        xQueueThatContainsData = ( QueueHandle_t ) xQueueSelectFromSet( xQueueSet,
                                                                        portMAX_DELAY );

        /* 读取队列集时使用了不确定的阻塞时间，因此除非队列集中的一个队列包含数据，否则 
        xQueueSelectFromSet() 不会返回，并且 xQueueThatContainsData 不能为空。从队
        列中读取。没有必要指定阻塞时间，因为已知队列包含数据。阻塞时间设置为 0。 */
        xQueueReceive( xQueueThatContainsData, &pcReceivedString, 0 );

        /* 打印从队列接收到的字符串。 */
        vPrintString( pcReceivedString );
    }
}
</code></pre>
<p>清单 65. 示例 12 使用的接受任务</p>
<p>图 37 显示了示例 12 产生的输出。可以看出，接收任务从两个发送任务接收字符串。<code>vSenderTask1()</code> 使用的阻塞时间是 <code>vSenderTask2()</code> 使用的块时间的一半，导致 <code>vSenderTask1()</code> 发送的字符串打印频率是 <code>vSenderTask2()</code> 发送的字符串的两倍。</p>
<p><img src="Chapter 4 队列管理/image-20240616001831459.png" alt="图 37. 执行示例 12 时产生的输出"></p>
<h3 id="更实际的队列集用例"><a href="#更实际的队列集用例" class="headerlink" title="更实际的队列集用例"></a>更实际的队列集用例</h3><p>例 12 展示了一个非常简单的例子；队列集只包含队列，它包含的两个队列都用于发送字符指针。在真实的应用程序中，队列集可能包含队列和信号量，并且队列可能不都包含相同的数据类型。在这种情况下，在使用返回值之前，有必要测试 <code>xQueueSelectFromSet()</code> 返回的值。清单 66 演示了当集合具有以下成员时，如何使用从 <code>xQueueSelectFromSet()</code> 返回的值:</p>
<ol>
<li>二进制信号量。</li>
<li>从中读取 <code>char</code> 指针的队列。</li>
<li>从中读取 <code>uint32_t</code> 值的队列。</li>
</ol>
<p>清单 66 假设队列和信号量已经被创建并添加到队列集中。</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 从中接收 char 指针的队列句柄。 */
QueueHandle_t xCharPointerQueue;

/* 接收 uint32_t 值的队列句柄。 */
QueueHandle_t xUint32tQueue;

/* 二进制信号量的句柄。 */
SemaphoreHandle_t xBinarySemaphore;

/* 两个队列和二进制信号量所属的队列集。 */
QueueSetHandle_t xQueueSet;

void vAMoreRealisticReceiverTask( void *pvParameters )
{
QueueSetMemberHandle_t xHandle;
char *pcReceivedString;
uint32_t ulRecievedValue;
const TickType_t xDelay100ms = pdMS_TO_TICKS( 100 );

    for( ;; )
    {
        /* 在队列集中阻塞最长100毫秒，以等待队列集中的一个成员包含数据。*/
         xHandle = xQueueSelectFromSet( xQueueSet, xDelay100ms);

         /* 测试从 xQueueSelectFromSet() 返回的值。如果返回值为 NULL，则对 
         xQueueSelectFromSet() 的调用超时。如果返回值不为 NULL，则返回值将是集合成员之一的句柄。
         QueueSetMemberHandle_t 值可以强制转换为 QueueHandle_t 或 SemaphoreHandle_t。是否需
         要显式强制转换取决于编译器。 */

         if( xHandle == NULL )
         {
             /* 对 xQueueSelectFromSet() 的调用超时。 */
         }
         else if( xHandle == ( QueueSetMemberHandle_t ) xCharPointerQueue )
         {
             /* 对 xQueueSelectFromSet() 的调用返回了接收 char 指针的队列句柄。从队列中读取。已
             知队列包含数据，因此使用阻塞时间 0。*/
             xQueueReceive(xCharPointerQueue, &pcReceivedString, 0 );

             /* 这里可以处理接收到的字符指针... */
         }
         else if( xHandle == ( QueueSetMemberHandle_t ) xUint32tQueue )
         {
             /* 对 xQueueSelectFromSet() 的调用返回了接收 uint32_t 类型的队列句柄。从队列中
             读取。已知队列包含数据，因此使用 0 的阻塞时间。 */
             xQueueReceive(xUint32tQueue, &ulRecievedValue, 0 );

             /* 接收到的值可以在这里处理... */
         }
         else if( xHandle == ( QueueSetMemberHandle_t ) xBinarySemaphore )
         {
             /* 对 xQueueSelectFromSet() 的调用返回了二进制信号量的句柄。现在获取信号量。信号量已知
             可用，因此使用 0 的阻塞时间。*/
             xSemaphoreTake(xBinarySemaphore, 0 );

             /* 获取信号量时需要的任何处理都可以在这里执行... */
         }
     }
 }
</code></pre>
<p>清单 66. 使用包含队列和信号量的队列集</p>
<h2 id="4-7-使用队列创建邮箱"><a href="#4-7-使用队列创建邮箱" class="headerlink" title="4.7 使用队列创建邮箱"></a>4.7 使用队列创建邮箱</h2><p>嵌入式社区内部对术语没有共识，<code>“邮箱”(mailbox)</code>在不同的实时操作系统中意味着不同的东西。在这本书里，术语邮箱是指一个长度为1的队列。队列之所以被描述为邮箱，是因为它在应用程序中的使用方式，而不是因为它与队列的功能不同:</p>
<ul>
<li>队列用于将数据从一个任务发送到另一个任务，或者从中断服务例程发送到一个任务。发送者在队列中放置一个项，接收者从队列中移除该项。数据通过队列从发送方传递到接收方。</li>
<li>邮箱用于保存任何任务或任何中断服务例程都可以读取的数据。数据不通过邮箱，而是保留在邮箱中，直到被覆盖。发件人会覆盖邮箱中的值。接收器从邮箱中读取该值，但不从邮箱中删除该值。</li>
</ul>
<p>本章介绍允许将队列用作邮箱的两个队列 API 函数。</p>
<p>清单 67 显示了一个创建来用作邮箱的队列</p>
<pre class=" language-lang-c"><code class="language-lang-c">/* 邮箱可以容纳固定大小的数据项。创建邮箱(队列)时设置数据项的大小。在本例中，邮箱被创建来保存
Example_t结构。Example_t 包含一个时间戳，允许邮箱中保存的数据记录邮箱上次更新的时间。本例中使用的
时间戳仅用于演示目的——邮箱可以保存应用程序作者想要的任何数据，并且数据不需要包含时间戳。 */
typedef struct xExampleStructure
{
    TickType_t xTimeStamp;
    uint32_t ulValue;
} Example_t;

/* 邮箱是一个队列，因此它的句柄存储在 QueueHandle_t 类型的变量中。*/
QueueHandle_t xMailbox;

void vAFunction( void )
{
    /* 创建将用作邮箱的队列。队列的长度为1，允许它与xQueueOverwrite() API 函数一起
    使用，如下所述。 */
    xMailbox = xQueueCreate( 1, sizeof( Example_t ) );
}
</code></pre>
<p>清单 67. 正在创建用作邮箱的队列</p>
<h3 id="xQueueOverwrite-API-函数"><a href="#xQueueOverwrite-API-函数" class="headerlink" title="xQueueOverwrite() API 函数"></a>xQueueOverwrite() API 函数</h3><p>像 <code>xQueueSendToBack()</code> API 函数类似，<code>xQueueOverwrite()</code>  API 函数将数据发送到队列。与 <code>xQueueSendToBack()</code> 不同，如果队列已经满了，那么 <code>xQueueOverwrite()</code> 将覆盖队列中已经存在的数据。</p>
<p><code>xQueueOverwrite()</code> 只能用于长度为1的队列。这种限制避免了函数的实现在队列已满的情况下任意决定要覆盖队列中的哪个项。</p>
<blockquote>
<p>注意: 永远不要从中断服务例程调用 <code>xQueueOverwrite()</code>。应该使用中断安全版本<code>xQueueOverwriteFromISR()</code> 来代替它。</p>
</blockquote>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );
</code></pre>
<p>清单 68. <code>xQueueOverwrite()</code> API 函数原型</p>
<p>表 26. <code>xQueueOverwrite()</code> 参数和返回值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名/返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>xQueue</td>
<td>数据被发送(写入)到的队列的句柄。队列句柄将从用于创建队列的 <code>xQueueCreate()</code> 调用中返回。</td>
</tr>
<tr>
<td>pvItemToQueue</td>
<td><p>指向要复制到队列中的数据的指针。</p><p>队列可以容纳的每个项的大小是在创建队列时设置的，因此这些字节将从 <code>pvItemToQueue</code> 复制到队列存储区域。</p></td>
</tr>
<tr>
<td>返回值</td>
<td><code>xQueueOverwrite()</code> 将写入队列，即使队列已满，因此 <code>pdPASS</code> 是唯一可能的返回值。</td>
</tr>
</tbody>
</table>
</div>
<p>清单 69 显示了 xQueueOverwrite() 用于写入清单 67 中创建的邮箱 (队列)。</p>
<pre class=" language-lang-c"><code class="language-lang-c">void vUpdateMailbox( uint32_t ulNewValue )
{
    /* 清单 67 中定义了 Example_t */
    Example_t xData;

    /* 新数据写入到Example_t结构。*/
    xData.ulValue = ulNewValue;

    /* 使用RTOS滴答计数作为Example_t结构中存储的时间戳。 */
    xData.xTimeStamp = xTaskGetTickCount();

    /* 将结构发送到邮箱-覆盖邮箱中已有的任何数据。 */
    xQueueOverwrite( xMailbox, &xData );
}
</code></pre>
<p>清单 69. 使用 xQueueOverwrite() API 函数</p>
<h3 id="xQueuePeek-API-函数"><a href="#xQueuePeek-API-函数" class="headerlink" title="xQueuePeek() API 函数"></a>xQueuePeek() API 函数</h3><p><code>xQueuePeek()</code> 用于从队列中接收(读取)项，而不从队列中移除项。<code>xQueuePeek()</code> 从队列头部接收数据，而不修改存储在队列中的数据或数据在队列中的存储顺序。</p>
<blockquote>
<p>注意: 永远不要从中断服务例程调用 <code>xQueuePeek()</code>。应该使用中断安全版本 <code>xQueuePeekFromISR()</code> 来代替它。</p>
</blockquote>
<p><code>xQueuePeek()</code> 具有与 <code>xQueueReceive()</code> 相同的函数参数和返回值。</p>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_txQueuePeek( QueueHandle_t xQueue,
                      void *const pvBuffer,
                      TickType_t xTicksToWait );
</code></pre>
<p>清单 70. <code>xQueuePeek()</code> API 函数原型</p>
<p>清单 71 显示了 xQueuePeek() 用于接收发布到清单 69 中邮箱(队列)的项</p>
<pre class=" language-lang-c"><code class="language-lang-c">BaseType_t vReadMailbox( Example_t *pxData )
{
    TickType_t xPreviousTimeStamp;
    BaseType_t xDataUpdated;

    /* 此函数使用从邮箱接收的最新值更新 Example_t 结构。
    在被新数据覆盖之前，记录 * pxData 中已包含的时间戳。 */
    xPreviousTimeStamp = pxData->xTimeStamp;

    /* 使用邮箱中包含的数据更新 pxData 指向的 Example_t 结构。 如果在此处使用
    xQueueReceive()，则邮箱将被留空，然后其他任何任务都无法读取数据。使用
    xQueuePeek() 而不是 xQueueReceive() 可以确保数据保留在邮箱中。指定了阻塞时间，
    因此如果邮箱为空，则调用任务将被置于阻塞状态以等待邮箱包含数据。 由于使用了无限的
    阻塞时间，因此不必检查从 xQueuePeek() 返回的值，因为 xQueuePeek() 仅在数据可用时
    才返回。 */
    xQueuePeek( xMailbox, pxData, portMAX_DELAY );

    /* 如果从邮箱读取的值自上次调用此函数以来已更新，则返回 pdTRUE。否则，返回 pdFALSE。 */
    if( pxData->xTimeStamp > xPreviousTimeStamp )
    {
        xDataUpdated = pdTRUE;
    }
    else
    {
        xDataUpdated = pdFALSE;
    }

    return xDataUpdated;
}
</code></pre>
<p>清单71. 使用 xQueuePeek() API 函数</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/Blogs/about" rel="external nofollow noreferrer">Koito Yuu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://koito-yuu153.github.io/Blogs/Blogs/2024/07/29/chapter-4-dui-lie-guan-li/">https://koito-yuu153.github.io/Blogs/Blogs/2024/07/29/chapter-4-dui-lie-guan-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/Blogs/about" target="_blank">Koito Yuu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/Blogs/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/Blogs/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/Blogs/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/Blogs/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/Blogs/2024/07/29/xian-xing-dai-shu-zhong-de-xian-xing-fang-cheng-zu/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/18.jpg" class="responsive-img" alt="线性代数中的线性方程组">
                        
                        <span class="card-title">线性代数中的线性方程组</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-07-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/Blogs/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-category">
                                    线性代数
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/Blogs/2024/06/15/chapter-6-zhong-duan-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/Blogs/medias/featureimages/22.jpg" class="responsive-img" alt="Chapter 6 中断管理">
                        
                        <span class="card-title">Chapter 6 中断管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-06-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/Blogs/categories/FreeRTOS/" class="post-category">
                                    FreeRTOS
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/Blogs/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/Blogs/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/Blogs/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/Blogs/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="9479612817"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/Blogs/libs/aplayer/APlayer.min.js"></script>
<script src="/Blogs/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024</span>
            
            <a href="/Blogs/about" target="_blank">Koito Yuu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Koito-Yuu153" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2810880357" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2810880357" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/Blogs/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/Blogs/libs/materialize/materialize.min.js"></script>
    <script src="/Blogs/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/Blogs/libs/aos/aos.js"></script>
    <script src="/Blogs/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/Blogs/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/Blogs/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/Blogs/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/Blogs/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/Blogs/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/Blogs/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
